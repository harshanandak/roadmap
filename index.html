<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platform Roadmap Manager</title>
    <style>
        :root {
            /* Background colors */
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --bg-elevated: #ffffff;
            
            /* Surface colors */
            --surface: #ffffff;
            --surface-alt: #f9fafb;
            --surface-hover: #f3f4f6;
            --surface-active: #e5e7eb;
            --surface-striped: #fafafa;
            
            /* Text colors */
            --text: #111827;
            --text-primary: #111827;
            --text-secondary: #374151;
            --text-muted: #6b7280;
            --text-inverse: #ffffff;
            --text-placeholder: #6b7280;
            
            /* Border colors */
            --border: #e5e7eb;
            --border-subtle: #f3f4f6;
            --border-strong: #d1d5db;
            
            /* Interactive colors */
            --interactive: #667eea;
            --interactive-hover: #5568d3;
            --interactive-active: #4c5dd1;
            
            /* Brand colors */
            --primary: #667eea;
            --primary-contrast: #ffffff;
            --primary-hover: #5568d3;
            --primary-active: #4c5dd1;
            
            /* Status colors */
            --success: #10b981;
            --success-hover: #059669;
            --success-light: #d1fae5;
            --success-text: #065f46;
            
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --danger-light: #fee2e2;
            --danger-text: #991b1b;
            
            --warning: #f59e0b;
            --warning-hover: #d97706;
            --warning-light: #fef3c7;
            --warning-text: #92400e;
            
            --info: #3b82f6;
            --info-hover: #2563eb;
            --info-light: #dbeafe;
            --info-text: #1e40af;
            
            /* Badge colors */
            --badge-mvp-bg: #fef3c7;
            --badge-mvp-text: #92400e;
            --badge-short-bg: #dbeafe;
            --badge-short-text: #1e40af;
            --badge-long-bg: #e0e7ff;
            --badge-long-text: #4338ca;
            --badge-easy-bg: #d1fae5;
            --badge-easy-text: #065f46;
            --badge-medium-bg: #fed7aa;
            --badge-medium-text: #9a3412;
            --badge-hard-bg: #fecaca;
            --badge-hard-text: #991b1b;
            --badge-feature-bg: #ddd6fe;
            --badge-feature-text: #5b21b6;
            --badge-service-bg: #fce7f3;
            --badge-service-text: #9f1239;
            
            /* Tag colors */
            --tag-bg: #e0e7ff;
            --tag-text: #4338ca;
            
            /* Shadow colors */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 20px 60px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 6px 20px rgba(0, 0, 0, 0.15);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 10px 25px rgba(0, 0, 0, 0.2);
            
            /* Modal overlay */
            --overlay: rgba(0, 0, 0, 0.5);
            
            /* Neutral colors */
            --neutral-light: #f9fafb;
            --neutral-medium: #9ca3af;
            --neutral-dark: #374151;
            
            /* Spacing */
            --radius: 12px;
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
        }

        /* Dark theme overrides */
        [data-theme="dark"] {
            /* Background colors */
            --bg-gradient-start: #1f2937;
            --bg-gradient-end: #111827;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-elevated: #1e293b;
            
            /* Surface colors */
            --surface: #111827;
            --surface-alt: #1f2937;
            --surface-hover: #1e293b;
            --surface-active: #334155;
            --surface-striped: #1f2937;
            
            /* Text colors */
            --text: #f1f5f9;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --text-inverse: #0f172a;
            --text-placeholder: #64748b;
            
            /* Border colors */
            --border: #334155;
            --border-subtle: #1e293b;
            --border-strong: #475569;
            
            /* Interactive colors */
            --interactive: #8b5cf6;
            --interactive-hover: #a78bfa;
            --interactive-active: #c4b5fd;
            
            /* Brand colors */
            --primary: #8b5cf6;
            --primary-contrast: #f1f5f9;
            --primary-hover: #a78bfa;
            --primary-active: #c4b5fd;
            
            /* Status colors */
            --success: #10b981;
            --success-hover: #34d399;
            --success-light: #064e3b;
            --success-text: #6ee7b7;
            
            --danger: #ef4444;
            --danger-hover: #f87171;
            --danger-light: #7f1d1d;
            --danger-text: #fca5a5;
            
            --warning: #f59e0b;
            --warning-hover: #fbbf24;
            --warning-light: #78350f;
            --warning-text: #fcd34d;
            
            --info: #3b82f6;
            --info-hover: #60a5fa;
            --info-light: #1e3a8a;
            --info-text: #93c5fd;
            
            /* Badge colors */
            --badge-mvp-bg: #78350f;
            --badge-mvp-text: #fcd34d;
            --badge-short-bg: #1e3a8a;
            --badge-short-text: #93c5fd;
            --badge-long-bg: #312e81;
            --badge-long-text: #c4b5fd;
            --badge-easy-bg: #064e3b;
            --badge-easy-text: #6ee7b7;
            --badge-medium-bg: #78350f;
            --badge-medium-text: #fcd34d;
            --badge-hard-bg: #7f1d1d;
            --badge-hard-text: #fca5a5;
            --badge-feature-bg: #4c1d95;
            --badge-feature-text: #c4b5fd;
            --badge-service-bg: #831843;
            --badge-service-text: #f9a8d4;
            
            /* Tag colors */
            --tag-bg: #312e81;
            --tag-text: #c4b5fd;
            
            /* Shadow colors */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 20px 60px rgba(0, 0, 0, 0.6);
            --shadow-md: 0 6px 20px rgba(0, 0, 0, 0.4);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 10px 25px rgba(0, 0, 0, 0.5);
            
            /* Modal overlay */
            --overlay: rgba(0, 0, 0, 0.7);
            
            /* Neutral colors */
            --neutral-light: #1e293b;
            --neutral-medium: #64748b;
            --neutral-dark: #94a3b8;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 12px;
            color: var(--text);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-inverse);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            margin: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .header-main-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex: 1;
            min-width: 0;
        }

        .header-actions {
            display: flex;
            gap: 6px;
            flex-wrap: nowrap;
            align-items: center;
            flex-shrink: 0;
        }

        /* Sync Status Indicator */
        .sync-status {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: default;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .sync-status-success {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .sync-status-syncing {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
            animation: pulse 2s infinite;
        }

        .sync-status-offline {
            background: rgba(148, 163, 184, 0.15);
            color: #94a3b8;
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        .sync-status-error {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        [data-theme="dark"] .sync-status-success {
            background: rgba(16, 185, 129, 0.2);
            color: #34d399;
        }

        [data-theme="dark"] .sync-status-syncing {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        [data-theme="dark"] .sync-status-offline {
            background: rgba(148, 163, 184, 0.2);
            color: #cbd5e1;
        }

        [data-theme="dark"] .sync-status-error {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .header-search {
            padding: 6px 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            font-size: 13px;
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-secondary);
            min-width: 200px;
            max-width: 300px;
            flex: 1;
            transition: all 0.3s ease;
        }

        /* Dark mode header improvements */
        [data-theme="dark"] .header {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        [data-theme="dark"] .header h1 {
            color: #f1f5f9;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            font-weight: 700;
        }

        [data-theme="dark"] .header-search {
            background: rgba(30, 41, 59, 0.95);
            border-color: rgba(148, 163, 184, 0.3);
            color: #f1f5f9;
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .header-search:focus {
            background: #1e293b;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.25), var(--shadow-md);
        }

        [data-theme="dark"] .header-search::placeholder {
            color: #64748b;
        }

        /* Dark mode header buttons */
        [data-theme="dark"] .header .btn-primary {
            background: rgba(255, 255, 255, 0.12);
            color: #f1f5f9;
            border: 1px solid rgba(255, 255, 255, 0.18);
            font-weight: 600;
        }

        [data-theme="dark"] .header .btn-primary:hover {
            background: rgba(255, 255, 255, 0.22);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        [data-theme="dark"] .header .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .header .btn-secondary {
            background: rgba(255, 255, 255, 0.08);
            color: #f1f5f9;
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
        }

        [data-theme="dark"] .header .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.18);
            border-color: rgba(255, 255, 255, 0.22);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .header .btn-secondary:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        [data-theme="dark"] .header .btn-success {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        [data-theme="dark"] .header .btn-success:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 3px 8px rgba(16, 185, 129, 0.2);
        }

        [data-theme="dark"] .header .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        [data-theme="dark"] .header .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.4);
            box-shadow: 0 3px 8px rgba(239, 68, 68, 0.2);
        }

        [data-theme="dark"] .bulk-actions {
            background: rgba(30, 41, 59, 0.95);
            border-color: rgba(148, 163, 184, 0.3);
            color: #f1f5f9;
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .bulk-actions span {
            color: #cbd5e1;
            font-weight: 600;
        }

        .header-search::placeholder {
            color: var(--text-placeholder);
            font-size: 13px;
        }

        .header-search:focus {
            outline: none;
            background: var(--bg-elevated);
            border-color: var(--bg-elevated);
            box-shadow: var(--shadow-md);
        }

        .header-menu-toggle {
            display: none;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--text-inverse);
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            align-items: center;
            justify-content: center;
        }

        .header-menu {
            position: relative;
        }

        .header-menu-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--surface);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            min-width: 200px;
            z-index: 1000;
            display: none;
            padding: 8px;
            border: 1px solid var(--border);
        }

        .header-menu-dropdown.active {
            display: block;
        }

        .header-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            transition: background 0.2s;
            border: none;
            width: 100%;
            text-align: left;
            background: transparent;
        }

        .header-menu-item:hover {
            background: var(--surface-hover);
        }

        .header-menu-item.danger {
            color: var(--danger);
        }

        .header-menu-item.danger:hover {
            background: var(--danger-light);
            color: var(--danger-text);
        }

        .header-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 6px 0;
        }

        .btn-compact {
            padding: 6px 12px;
            font-size: 12px;
            white-space: nowrap;
        }

        .btn-icon-only {
            padding: 6px;
            min-width: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 1200px) {
            .header h1 {
                font-size: 18px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 10px 15px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            .header-search {
                min-width: 150px;
                max-width: 200px;
            }
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--bg-elevated);
            color: var(--primary);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            background: var(--surface-hover);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-inverse);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-danger {
            background: var(--danger);
            color: var(--text-inverse);
        }

        .btn-danger:hover {
            background: var(--danger-hover);
        }

        .btn-success {
            background: var(--success);
            color: var(--text-inverse);
        }

        .btn-success:hover {
            background: var(--success-hover);
        }

        .btn-ai-create {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .btn-ai-create::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .btn-ai-create:hover::before {
            left: 100%;
        }

        .btn-ai-create:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .content {
            padding: 12px 20px;
        }

        /* Table View */
        .table-container {
            overflow: auto;
            max-height: calc(100vh - 120px);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 900px;
        }

        thead {
            background: var(--surface-alt);
        }

        th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border);
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            background: var(--surface-alt);
            z-index: 10;
        }

        th:hover {
            background: var(--surface-hover);
        }

        th.sortable::after {
            content: ' ⇅';
            opacity: 0.3;
        }

        th.sorted-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        th.sorted-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        th.th-with-filter {
            cursor: pointer;
            padding: 12px;
            position: sticky;
            top: 0;
            background: var(--surface-alt);
            z-index: 10;
            user-select: none;
        }

        th.th-with-filter:hover {
            background: var(--surface-hover);
        }

        th.th-with-filter::after {
            content: '▼';
            opacity: 0.3;
            font-size: 10px;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
        }

        .th-label {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 14px;
            pointer-events: none;
        }

        .th-filter {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            z-index: 1;
        }

        td {
            padding: 14px 12px;
            border-bottom: 1px solid var(--border);
            vertical-align: top;
        }

        tr:nth-child(even) {
            background: var(--surface-striped);
        }

        tr:hover {
            background: var(--surface-hover);
        }

        .clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-clamp: 2;
            overflow: hidden;
        }

        .focus-ring:focus-visible, button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .tag {
            display: inline-block;
            padding: 4px 10px;
            background: var(--tag-bg);
            color: var(--tag-text);
            border-radius: 12px;
            font-size: 12px;
            margin: 2px;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-mvp { background: var(--badge-mvp-bg); color: var(--badge-mvp-text); }
        .badge-short { background: var(--badge-short-bg); color: var(--badge-short-text); }
        .badge-long { background: var(--badge-long-bg); color: var(--badge-long-text); }
        .badge-easy { background: var(--badge-easy-bg); color: var(--badge-easy-text); }
        .badge-medium { background: var(--badge-medium-bg); color: var(--badge-medium-text); }
        .badge-hard { background: var(--badge-hard-bg); color: var(--badge-hard-text); }
        .badge-feature { background: var(--badge-feature-bg); color: var(--badge-feature-text); }
        .badge-service { background: var(--badge-service-bg); color: var(--badge-service-text); }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Kanban View */
        .kanban-board {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .kanban-column {
            background: var(--surface-alt);
            border-radius: 8px;
            padding: 15px;
            min-height: 400px;
        }

        .kanban-column h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        .kanban-card {
            background: var(--surface);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: var(--shadow-sm);
            cursor: move;
            transition: all 0.2s ease;
        }

        .kanban-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .kanban-card.dragging {
            opacity: 0.5;
        }

        .kanban-card h4 {
            font-size: 14px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .kanban-card p {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .kanban-card-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            font-size: 24px;
            color: var(--text-primary);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .close-btn:hover {
            color: var(--text-primary);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            background: var(--surface);
            color: var(--text-primary);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 8px;
            border: 2px solid var(--border);
            border-radius: 6px;
            min-height: 42px;
            background: var(--surface);
        }

        .tag-input-container:focus-within {
            border-color: var(--primary);
        }

        .tag-input-container input {
            border: none;
            flex: 1;
            min-width: 120px;
            padding: 4px;
            background: transparent;
            color: var(--text-primary);
        }

        .tag-input-container input:focus {
            outline: none;
        }

        .tag-suggestions {
            position: relative;
        }

        .tag-suggestions-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .tag-suggestions-list.active {
            display: block;
        }

        .tag-suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .tag-suggestion-item:hover {
            background: var(--surface-hover);
        }

        /* AI Chat */
        .chat-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-inverse);
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: var(--shadow-xl);
            z-index: 999;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .chat-button:hover {
            transform: scale(1.08);
            box-shadow: var(--shadow-lg);
        }

        .chat-button:active {
            transform: scale(1.02);
        }

        [data-theme="dark"] .chat-button {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        [data-theme="dark"] .chat-button:hover {
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.6);
        }

        .chat-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            min-width: 300px;
            max-width: 90vw;
            height: 100vh;
            background: var(--surface);
            box-shadow: var(--shadow-lg);
            z-index: 1001;
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        [data-theme="dark"] .chat-panel {
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.5);
            border-left: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chat-panel.active {
            right: 0;
        }

        .chat-panel-resizer {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: transparent;
            z-index: 1002;
            transition: all 0.2s ease;
            pointer-events: auto;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-panel-resizer::before {
            content: '';
            width: 3px;
            height: 40px;
            background: repeating-linear-gradient(
                to bottom,
                var(--border) 0px,
                var(--border) 3px,
                transparent 3px,
                transparent 6px
            );
            border-radius: 2px;
            opacity: 0.4;
            transition: opacity 0.2s ease;
        }

        .chat-panel-resizer:hover {
            background: rgba(102, 126, 234, 0.1);
            width: 8px;
        }

        .chat-panel-resizer:hover::before {
            opacity: 1;
            background: repeating-linear-gradient(
                to bottom,
                var(--primary) 0px,
                var(--primary) 3px,
                transparent 3px,
                transparent 6px
            );
        }

        .chat-panel-resizer.dragging {
            background: rgba(102, 126, 234, 0.15);
            width: 8px;
        }

        .chat-panel-resizer.dragging::before {
            opacity: 1;
            background: repeating-linear-gradient(
                to bottom,
                var(--primary) 0px,
                var(--primary) 3px,
                transparent 3px,
                transparent 6px
            );
        }

        /* Bulk actions bar */
        .bulk-actions {
            display: none;
            align-items: center;
            gap: 6px;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
        }
        .bulk-actions.active { display: flex; }

        .chat-header {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-inverse);
            padding: 12px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] .chat-header {
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chat-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .chat-header-top h3 {
            flex: 1;
            text-align: center;
        }

        .chat-header-top .chat-header-api-status {
            flex-shrink: 0;
        }

        .chat-header-top .chat-header-actions {
            flex-shrink: 0;
        }

        .chat-header h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .chat-header-actions {
            display: flex;
            gap: 8px;
        }

        .chat-header-api-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chat-header-api-status:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .chat-header-api-indicator {
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(16, 185, 129, 0.6);
        }

        .chat-header-api-toggle {
            font-size: 10px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--text-inverse);
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
        }

        .chat-header-api-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .chat-icon-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: var(--text-inverse);
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .chat-icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        [data-theme="dark"] .chat-icon-btn {
            background: rgba(255, 255, 255, 0.15);
        }

        [data-theme="dark"] .chat-icon-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .memory-panel {
            background: var(--surface-alt);
            border-bottom: 1px solid var(--border);
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        [data-theme="dark"] .memory-panel {
            background: #1e293b;
            border-bottom-color: rgba(255, 255, 255, 0.05);
        }

        .memory-panel h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        [data-theme="dark"] .memory-panel h4 {
            color: #cbd5e1;
        }

        .memory-actions {
            display: flex;
            gap: 5px;
        }

        .memory-actions button {
            font-size: 10px;
            padding: 4px 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .memory-actions button:hover {
            background: var(--surface-hover);
            border-color: var(--border-strong);
            color: var(--text-primary);
        }

        [data-theme="dark"] .memory-actions button {
            background: #334155;
            border-color: rgba(255, 255, 255, 0.1);
            color: #94a3b8;
        }

        [data-theme="dark"] .memory-actions button:hover {
            background: #475569;
            border-color: rgba(255, 255, 255, 0.15);
            color: #cbd5e1;
        }

        .context-warning {
            background: var(--warning-light);
            border-left: 3px solid var(--warning);
            padding: 10px;
            margin: 10px 20px;
            font-size: 12px;
            color: var(--warning-text);
            border-radius: 4px;
        }

        [data-theme="dark"] .context-warning {
            background: #78350f;
            border-left-color: var(--warning);
            color: #fcd34d;
        }

        /* Enhancement Panel Styles */
        .enhancement-panel {
            position: fixed;
            left: 20px;
            bottom: -600px;
            width: 500px;
            max-width: calc(100vw - 440px);
            max-height: 600px;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .enhancement-panel:not(.hidden) {
            bottom: 20px;
        }

        [data-theme="dark"] .enhancement-panel {
            background: #1e293b;
            border-color: rgba(102, 126, 234, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 768px) {
            .enhancement-panel {
                left: 10px;
                right: 10px;
                width: auto;
                max-width: calc(100vw - 20px);
            }
        }

        .enhancement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .enhancement-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .enhancement-content {
            padding: 15px 20px;
            overflow-y: auto;
            flex: 1;
        }

        .enhancement-section {
            margin-bottom: 20px;
        }

        .enhancement-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }

        .enhancement-understanding {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .understanding-item {
            display: flex;
            font-size: 13px;
            line-height: 1.5;
        }

        .understanding-label {
            font-weight: 600;
            color: var(--text-muted);
            min-width: 80px;
        }

        .understanding-item span:last-child {
            color: var(--text-primary);
            flex: 1;
        }

        .enhancement-gaps {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .gap-badge {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        [data-theme="dark"] .gap-badge {
            background: rgba(239, 68, 68, 0.15);
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .enhancement-questions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .enhancement-loading {
            font-size: 13px;
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .question-item {
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid rgba(102, 126, 234, 0.15);
            border-radius: 8px;
            padding: 10px;
        }

        .question-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 6px;
            display: block;
        }

        .question-input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 13px;
            background: var(--surface);
            color: var(--text-primary);
            font-family: inherit;
        }

        .question-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        [data-theme="dark"] .question-input {
            background: #334155;
            border-color: rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .question-input:focus {
            border-color: #667eea;
        }

        .enhancement-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .enhancement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .enhancement-progress-text {
            font-size: 12px;
            color: var(--text-muted);
            text-align: center;
        }

        .enhancement-actions {
            display: flex;
            gap: 10px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
            margin-top: 15px;
        }

        .enhancement-actions button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .enhancement-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Memory Analysis Toast */
        .memory-analysis-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--primary);
            color: var(--text-inverse);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
            max-width: 350px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        [data-theme="dark"] .memory-analysis-toast {
            background: #334155;
            color: #cbd5e1;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .memory-analysis-toast.fade-out {
            animation: slideOutRight 0.3s ease-out forwards;
        }

        /* Memory Context Indicator */
        .memory-context-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
            padding: 8px 12px;
            background: var(--surface-alt);
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .memory-context-indicator:hover {
            background: rgba(102, 126, 234, 0.08);
            border-color: rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }

        [data-theme="dark"] .memory-context-indicator {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.6);
            border-color: rgba(255, 255, 255, 0.05);
        }

        [data-theme="dark"] .memory-context-indicator:hover {
            background: rgba(102, 126, 234, 0.12);
            border-color: rgba(102, 126, 234, 0.25);
        }

        .memory-context-indicator.has-memory {
            color: var(--primary);
            background: rgba(102, 126, 234, 0.12);
            border-color: rgba(102, 126, 234, 0.25);
        }

        .memory-context-indicator.has-memory:hover {
            background: rgba(102, 126, 234, 0.18);
            border-color: rgba(102, 126, 234, 0.35);
        }

        [data-theme="dark"] .memory-context-indicator.has-memory {
            color: #818cf8;
            background: rgba(102, 126, 234, 0.18);
            border-color: rgba(102, 126, 234, 0.3);
        }

        [data-theme="dark"] .memory-context-indicator.has-memory:hover {
            background: rgba(102, 126, 234, 0.25);
            border-color: rgba(102, 126, 234, 0.4);
        }

        .memory-context-indicator .memory-icon {
            font-size: 14px;
            flex-shrink: 0;
        }

        .memory-context-indicator .memory-text {
            flex: 1;
            font-weight: 500;
        }

        .memory-context-indicator .info-icon {
            cursor: help;
            opacity: 0.6;
            font-size: 13px;
            flex-shrink: 0;
            transition: opacity 0.2s ease;
        }

        .memory-context-indicator:hover .info-icon {
            opacity: 1;
        }

        .memory-context-indicator .action-hint {
            opacity: 0;
            font-size: 10px;
            color: var(--primary);
            transition: opacity 0.2s ease;
            font-weight: 600;
            margin-left: auto;
        }

        .memory-context-indicator:hover .action-hint {
            opacity: 0.7;
        }

        .memory-context-indicator.has-memory .action-hint {
            opacity: 0.5;
        }

        .memory-notification {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-inverse);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .memory-notification {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-bottom-color: rgba(255, 255, 255, 0.05);
        }

        .memory-notification:hover {
            background: linear-gradient(135deg, var(--primary-hover) 0%, var(--primary-active) 100%);
        }

        [data-theme="dark"] .memory-notification:hover {
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
        }

        .memory-notification-collapsed {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            font-weight: 600;
        }

        .memory-notification-badge {
            background: rgba(255, 255, 255, 0.3);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
        }

        [data-theme="dark"] .memory-notification-badge {
            background: rgba(255, 255, 255, 0.15);
        }

        .memory-notification-expanded {
            display: none;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .memory-notification-expanded.active {
            display: block;
        }

        .memory-suggestion-item {
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: start;
            gap: 10px;
        }

        [data-theme="dark"] .memory-suggestion-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .memory-suggestion-content {
            flex: 1;
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-inverse);
        }

        [data-theme="dark"] .memory-suggestion-content {
            color: #cbd5e1;
        }

        .memory-suggestion-actions {
            display: flex;
            gap: 5px;
        }

        .memory-suggestion-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .memory-suggestion-btn.approve {
            background: var(--success);
            color: var(--text-inverse);
        }

        .memory-suggestion-btn.approve:hover {
            background: var(--success-hover);
            transform: scale(1.1);
        }

        [data-theme="dark"] .memory-suggestion-btn.approve {
            background: rgba(16, 185, 129, 0.3);
            color: #6ee7b7;
        }

        [data-theme="dark"] .memory-suggestion-btn.approve:hover {
            background: rgba(16, 185, 129, 0.4);
        }

        .memory-suggestion-btn.reject {
            background: var(--danger);
            color: var(--text-inverse);
        }

        .memory-suggestion-btn.reject:hover {
            background: var(--danger-hover);
            transform: scale(1.1);
        }

        [data-theme="dark"] .memory-suggestion-btn.reject {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        [data-theme="dark"] .memory-suggestion-btn.reject:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        .memory-notification-bulk-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        [data-theme="dark"] .memory-notification-bulk-actions {
            border-top-color: rgba(255, 255, 255, 0.1);
        }

        .memory-notification-bulk-actions button {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-inverse);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .memory-notification-bulk-actions button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        [data-theme="dark"] .memory-notification-bulk-actions button {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        [data-theme="dark"] .memory-notification-bulk-actions button:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Link Notification Styles */
        .link-notification {
            background: linear-gradient(135deg, var(--success) 0%, var(--success-hover) 100%);
            color: var(--text-inverse);
            padding: 12px 20px;
            cursor: pointer;
            margin: 0 20px 15px 20px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .link-notification {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(16, 185, 129, 0.3) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #6ee7b7;
        }

        .link-notification:hover {
            background: linear-gradient(135deg, var(--success-hover) 0%, var(--success) 100%);
        }

        [data-theme="dark"] .link-notification:hover {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3) 0%, rgba(16, 185, 129, 0.4) 100%);
            border-color: rgba(16, 185, 129, 0.4);
        }

        .link-notification-collapsed {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .link-notification-badge {
            background: rgba(255, 255, 255, 0.3);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
        }

        [data-theme="dark"] .link-notification-badge {
            background: rgba(255, 255, 255, 0.15);
        }

        .link-notification-expanded {
            display: none;
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .link-notification-expanded.active {
            display: block;
        }

        .link-suggestion-item {
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: default;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .link-suggestion-item {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .link-suggestion-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            gap: 10px;
        }

        .link-suggestion-features {
            flex: 1;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-inverse);
        }

        [data-theme="dark"] .link-suggestion-features {
            color: #cbd5e1;
        }

        .link-suggestion-arrow {
            color: rgba(255, 255, 255, 0.7);
            margin: 0 6px;
        }

        [data-theme="dark"] .link-suggestion-arrow {
            color: rgba(203, 213, 225, 0.6);
        }

        .link-suggestion-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .link-type-dependency {
            background: var(--danger);
            color: var(--text-inverse);
        }

        [data-theme="dark"] .link-type-dependency {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        .link-type-complements {
            background: var(--info);
            color: var(--text-inverse);
        }

        [data-theme="dark"] .link-type-complements {
            background: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        .link-suggestion-confidence {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .confidence-high {
            background: var(--success);
            color: var(--text-inverse);
        }

        [data-theme="dark"] .confidence-high {
            background: rgba(16, 185, 129, 0.3);
            color: #6ee7b7;
        }

        .confidence-medium {
            background: var(--warning);
            color: var(--text-inverse);
        }

        [data-theme="dark"] .confidence-medium {
            background: rgba(245, 158, 11, 0.3);
            color: #fcd34d;
        }

        .link-suggestion-reason {
            font-size: 13px;
            opacity: 0.9;
            margin-bottom: 10px;
            line-height: 1.4;
            color: var(--text-inverse);
        }

        [data-theme="dark"] .link-suggestion-reason {
            color: #94a3b8;
            opacity: 0.95;
        }

        .link-suggestion-actions {
            display: flex;
            gap: 8px;
        }

        .link-suggestion-actions button {
            flex: 1;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .link-suggestion-actions button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .link-notification-bulk-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .link-notification-bulk-actions button {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.2s;
        }

        .link-notification-bulk-actions button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Manual Link Management Styles */
        .timeline-item-links {
            margin-top: 10px;
            padding: 10px;
            background: var(--surface-alt);
            border-radius: 6px;
        }

        .timeline-item-links-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .timeline-item-links-header h4 {
            font-size: 13px;
            color: var(--text-secondary);
            margin: 0;
        }

        .add-link-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: var(--success);
            color: var(--text-inverse);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .add-link-btn:hover {
            background: var(--success-hover);
        }

        .link-item {
            background: var(--surface);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .link-item-info {
            flex: 1;
            color: var(--text-primary);
        }

        .link-item-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            margin-right: 6px;
        }

        .link-item-type.dependency {
            background: var(--danger-light);
            color: var(--danger-text);
        }

        [data-theme="dark"] .link-item-type.dependency {
            background: var(--danger-light);
            color: var(--danger-text);
        }

        .link-item-type.complements {
            background: var(--info-light);
            color: var(--info-text);
        }

        [data-theme="dark"] .link-item-type.complements {
            background: var(--info-light);
            color: var(--info-text);
        }

        .remove-link-btn {
            padding: 2px 6px;
            font-size: 11px;
            background: var(--danger);
            color: var(--text-inverse);
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .remove-link-btn:hover {
            background: var(--danger-hover);
        }

        .link-picker-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--surface);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 10001;
            max-width: 500px;
            width: 90%;
        }

        .link-picker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay);
            z-index: 10000;
        }

        .link-picker-modal h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .link-picker-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .link-picker-form label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .link-picker-form select,
        .link-picker-form input {
            padding: 8px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
            background: var(--surface);
            color: var(--text-primary);
        }

        .link-picker-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .link-picker-actions button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
        }

        /* AI Action Queue Styles */
        .ai-action-queue-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            transition: all 0.2s;
        }

        .ai-action-queue-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #667eea;
        }

        .ai-action-queue-item.approved {
            background: rgba(16, 185, 129, 0.1);
            border-color: #10b981;
            opacity: 0.7;
        }

        .ai-action-queue-item.rejected {
            background: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
            opacity: 0.7;
        }

        .ai-action-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .ai-action-type {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .ai-action-number {
            font-size: 12px;
            color: var(--text-muted);
            background: rgba(102, 126, 234, 0.15);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .ai-action-reason {
            font-size: 13px;
            color: var(--text-secondary);
            margin: 8px 0;
            font-style: italic;
        }

        .ai-action-preview {
            font-size: 12px;
            color: var(--text-primary);
            background: rgba(0, 0, 0, 0.1);
            padding: 8px;
            border-radius: 6px;
            margin: 8px 0;
            max-height: 150px;
            overflow-y: auto;
        }

        .ai-action-buttons {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }

        .ai-action-buttons button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .ai-action-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ai-action-buttons .approve-btn {
            background: var(--success);
            color: white;
            flex: 1;
        }

        .ai-action-buttons .reject-btn {
            background: var(--danger);
            color: white;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: var(--surface);
        }

        [data-theme="dark"] .chat-messages {
            background: #0f172a;
        }

        .chat-message {
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            position: relative;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.user {
            background: var(--primary);
            color: var(--text-inverse);
            align-self: flex-end;
            margin-left: auto;
            white-space: pre-wrap;
            border-bottom-right-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] .chat-message.user {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            box-shadow: 0 2px 12px rgba(139, 92, 246, 0.3);
        }

        .chat-message.ai {
            background: var(--surface-alt);
            color: var(--text-primary);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--border-subtle);
        }

        [data-theme="dark"] .chat-message.ai {
            background: #1e293b;
            border-color: rgba(255, 255, 255, 0.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .chat-message.ai p {
            margin: 0 0 10px 0;
            color: var(--text-primary);
        }

        .chat-message.ai p:last-child {
            margin-bottom: 0;
        }

        .chat-message.ai ul,
        .chat-message.ai ol {
            margin: 8px 0;
            padding-left: 20px;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 12px 0;
            max-width: 100%;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .chat-message.ai table {
            width: 100%;
            min-width: fit-content;
            border-collapse: collapse;
            margin: 0;
            font-size: 13px;
            display: table;
            table-layout: auto;
        }

        .chat-message.ai table thead,
        .chat-message.ai table tbody,
        .chat-message.ai table tr {
            display: table-row;
        }

        .chat-message.ai table th,
        .chat-message.ai table td {
            padding: 8px 12px;
            border: 1px solid var(--border);
            text-align: left;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: nowrap;
        }

        .chat-message.ai table td {
            white-space: normal;
        }

        .chat-message.ai table th {
            background: var(--surface-alt);
            font-weight: 600;
            color: var(--text-primary);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .chat-message.expandable {
            overflow: hidden;
            position: relative;
        }

        .chat-message.expandable.collapsed {
            max-height: 400px;
        }

        .chat-message.expandable.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to bottom, transparent, var(--surface-alt));
            pointer-events: none;
        }

        [data-theme="dark"] .chat-message.expandable.collapsed::after {
            background: linear-gradient(to bottom, transparent, #1e293b);
        }

        .message-expand-btn {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: var(--text-inverse);
            border: none;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.2s;
        }

        .message-expand-btn:hover {
            background: var(--primary-hover);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .message-expand-btn.expanded {
            position: relative;
            bottom: auto;
            left: auto;
            transform: none;
            margin-top: 12px;
            width: 100%;
        }

        .chat-message.ai li {
            margin: 4px 0;
            color: var(--text-primary);
        }

        .chat-message.ai code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
        }

        [data-theme="dark"] .chat-message.ai code {
            background: #334155;
            border-color: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
        }

        .chat-message.ai pre {
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 10px 0;
            border: 1px solid var(--border);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] .chat-message.ai pre {
            background: #0f172a;
            border-color: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .chat-message.ai pre code {
            background: none;
            padding: 0;
            color: inherit;
            border: none;
        }

        .chat-message.ai strong {
            font-weight: 600;
            color: var(--text-secondary);
        }

        [data-theme="dark"] .chat-message.ai strong {
            color: #cbd5e1;
        }

        .chat-message.ai h1,
        .chat-message.ai h2,
        .chat-message.ai h3 {
            margin: 12px 0 8px 0;
            font-weight: 600;
            color: var(--text-primary);
        }

        [data-theme="dark"] .chat-message.ai h1,
        [data-theme="dark"] .chat-message.ai h2,
        [data-theme="dark"] .chat-message.ai h3 {
            color: #f1f5f9;
        }

        .chat-message.ai h1 { font-size: 18px; }
        .chat-message.ai h2 { font-size: 16px; }
        .chat-message.ai h3 { font-size: 14px; }

        .chat-message.ai table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 13px;
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .chat-message.ai table {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .chat-message.ai table th {
            background: var(--surface-alt);
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border);
        }

        [data-theme="dark"] .chat-message.ai table th {
            background: #334155;
            color: #cbd5e1;
        }

        .chat-message.ai table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-subtle);
            color: var(--text-primary);
        }

        .chat-message.ai table tr:last-child td {
            border-bottom: none;
        }

        .chat-message.ai table tr:hover {
            background: var(--surface-hover);
        }

        [data-theme="dark"] .chat-message.ai table tr:hover {
            background: #334155;
        }

        .chat-input-container {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            background: var(--surface);
        }

        [data-theme="dark"] .chat-input-container {
            background: #111827;
            border-top-color: rgba(255, 255, 255, 0.05);
        }

        .chat-input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-input-wrapper .memory-context-indicator {
            flex-shrink: 0;
        }

        .chat-input-wrapper .input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input-wrapper textarea {
            flex: 1;
            min-width: 0;
            padding: 10px 14px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            resize: none;
            min-height: 44px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.5;
            background: var(--surface);
            color: var(--text-primary);
            transition: all 0.2s ease;
            width: 100%;
        }

        [data-theme="dark"] .chat-input-wrapper textarea {
            background: #1e293b;
            border-color: rgba(255, 255, 255, 0.1);
            color: #f1f5f9;
        }

        .chat-input-wrapper textarea::placeholder {
            color: var(--text-placeholder);
        }

        .chat-input-wrapper textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: var(--bg-elevated);
        }

        [data-theme="dark"] .chat-input-wrapper textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
            background: #1e293b;
        }

        .chat-input-wrapper button {
            padding: 10px 18px;
            min-width: auto;
            white-space: nowrap;
            border-radius: 12px;
            font-weight: 600;
        }

        [data-theme="dark"] .chat-input-wrapper button {
            background: var(--primary);
            color: var(--text-inverse);
        }

        [data-theme="dark"] .chat-input-wrapper button:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .api-key-input {
            margin-bottom: 15px;
        }

        .api-key-input input,
        .api-key-input select {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 12px;
            margin-bottom: 10px;
            background: var(--surface);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        [data-theme="dark"] .api-key-input input,
        [data-theme="dark"] .api-key-input select {
            background: #1e293b;
            border-color: rgba(255, 255, 255, 0.1);
            color: #f1f5f9;
        }

        .api-key-input input:focus,
        .api-key-input select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        [data-theme="dark"] .api-key-input input:focus,
        [data-theme="dark"] .api-key-input select:focus {
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
        }

        .api-key-input label {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 5px;
            font-weight: 600;
        }

        [data-theme="dark"] .api-key-input label {
            color: #94a3b8;
        }

        .api-key-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: var(--surface-alt);
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 11px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        [data-theme="dark"] .api-key-status {
            background: #1e293b;
            color: #94a3b8;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .api-key-status:hover {
            background: var(--surface-hover);
        }

        [data-theme="dark"] .api-key-status:hover {
            background: #334155;
        }

        .api-key-status-text {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .api-key-indicator {
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(16, 185, 129, 0.4);
        }

        [data-theme="dark"] .api-key-indicator {
            box-shadow: 0 0 6px rgba(16, 185, 129, 0.6);
        }

        .api-key-toggle {
            font-size: 10px;
            padding: 2px 6px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
        }

        .api-key-toggle:hover {
            background: var(--surface-hover);
            border-color: var(--border-strong);
            color: var(--text-primary);
        }

        [data-theme="dark"] .api-key-toggle {
            border-color: rgba(255, 255, 255, 0.1);
            color: #94a3b8;
        }

        [data-theme="dark"] .api-key-toggle:hover {
            background: #334155;
            border-color: rgba(255, 255, 255, 0.15);
            color: #cbd5e1;
        }

        .hidden {
            display: none !important;
        }

        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 3px solid rgba(102, 126, 234, 0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 8px;
        }

        .chat-input-wrapper.loading {
            position: relative;
            animation: pulse 2s ease-in-out infinite;
        }

        .chat-input-wrapper.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .search-synthesis {
            margin: 10px 0;
            padding: 12px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .ai-answer {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .search-sources {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(102, 126, 234, 0.2);
        }

        .sources-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 13px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sources-toggle:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .sources-toggle::before {
            content: '▶';
            font-size: 10px;
            transition: transform 0.2s;
        }

        .sources-toggle.expanded::before {
            transform: rotate(90deg);
        }

        .sources-list {
            margin-top: 8px;
            padding-left: 20px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .sources-list.expanded {
            max-height: 500px;
            transition: max-height 0.3s ease-in;
        }

        .source-item {
            margin: 8px 0;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
        }

        .source-item:last-child {
            border-bottom: none;
        }

        .source-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .source-url {
            color: #667eea;
            text-decoration: none;
            font-size: 11px;
            word-break: break-all;
        }

        .source-url:hover {
            text-decoration: underline;
        }

        /* Batched search results styles */
        .batched-search-results {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .batch-search-header {
            padding: 10px 14px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            border-left: 4px solid #667eea;
        }

        .search-result-section {
            background: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(102, 126, 234, 0.1);
        }

        .search-query-label {
            font-size: 13px;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.15);
        }

        .failed-searches {
            padding: 10px;
            background: rgba(239, 68, 68, 0.05);
            border-radius: 6px;
            border-left: 3px solid #ef4444;
        }

        .search-error {
            font-size: 13px;
            color: #dc2626;
            padding: 4px 0;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .chat-panel {
                width: 100%;
                right: -100%;
            }

            .kanban-board {
                grid-template-columns: 1fr;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 22px;
            }

            .header-actions {
                width: 100%;
            }

            .header-search {
                width: 100%;
                min-width: unset;
                order: -1;
            }
        }

        /* ==================== Detail View Styles ==================== */

        .detail-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow-y: auto;
            background: var(--bg-primary);
            animation: fadeIn 0.2s ease-in;
        }

        .detail-view.hidden {
            display: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Detail Header */
        .detail-header {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 24px 32px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .back-btn:hover {
            background: var(--surface-hover);
            transform: translateX(-2px);
        }

        .detail-header-content {
            flex: 1;
        }

        .detail-header-content h1 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .detail-badges {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .detail-header-actions {
            display: flex;
            gap: 12px;
        }

        /* Detail Tabs */
        .detail-tabs {
            display: flex;
            gap: 4px;
            padding: 0 32px;
            background: var(--surface);
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .detail-tab {
            padding: 16px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
            margin-bottom: -2px;
        }

        .detail-tab:hover {
            color: var(--text-primary);
            background: var(--surface-hover);
        }

        .detail-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* Detail Content */
        .detail-content {
            flex: 1;
            padding: 32px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .detail-tab-content {
            display: none;
            animation: slideInUp 0.3s ease-out;
        }

        .detail-tab-content.active {
            display: block;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .detail-section {
            margin-bottom: 32px;
            padding: 24px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
        }

        .detail-section h2 {
            margin: 0 0 16px 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .detail-text {
            margin: 0;
            font-size: 15px;
            line-height: 1.6;
            color: var(--text-secondary);
            white-space: pre-wrap;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .section-header h2 {
            margin: 0;
        }

        .btn-ai {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--primary), var(--primary-hover));
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .btn-ai:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Timeline Items Grid */
        .timeline-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
        }

        .timeline-item-card {
            padding: 16px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .timeline-item-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .timeline-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .timeline-item-badges {
            display: flex;
            gap: 8px;
        }

        .timeline-item-body h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .timeline-item-body p {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .timeline-item-categories {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        /* Execution Steps */
        .execution-steps {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .execution-step {
            display: flex;
            gap: 16px;
            padding: 16px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-left: 4px solid var(--primary);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .execution-step:hover {
            box-shadow: var(--shadow-sm);
        }

        .step-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            flex-shrink: 0;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            font-weight: 600;
            font-size: 14px;
        }

        .step-content {
            flex: 1;
        }

        .step-content h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .step-content p {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .step-meta {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .step-actions {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }

        .step-actions button {
            padding: 6px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .step-actions button:hover {
            background: var(--surface-hover);
            color: var(--text-primary);
        }

        .empty-state {
            padding: 48px 24px;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
            color: var(--text-secondary);
        }

        .empty-state p {
            margin: 0;
            font-size: 14px;
        }

        /* Resources Grid */
        .resources-grid {
            display: grid;
            gap: 20px;
        }

        .resource-section {
            padding: 16px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .resource-section h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .resource-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
        }

        .resource-label {
            color: var(--text-secondary);
        }

        .resource-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .tech-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tech-tag {
            padding: 6px 12px;
            background: var(--tag-bg);
            color: var(--tag-text);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
        }

        /* Milestones */
        .milestones-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .milestone {
            display: flex;
            gap: 16px;
            padding: 16px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .milestone:hover {
            box-shadow: var(--shadow-sm);
        }

        .milestone-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-top: 4px;
            flex-shrink: 0;
        }

        .milestone-status.pending {
            background: var(--text-muted);
        }

        .milestone-status.in-progress {
            background: var(--info);
        }

        .milestone-status.completed {
            background: var(--success);
        }

        .milestone-content {
            flex: 1;
        }

        .milestone-content h4 {
            margin: 0 0 4px 0;
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .milestone-date {
            font-size: 13px;
            color: var(--text-muted);
        }

        /* Risks */
        .risks-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .risk {
            padding: 16px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-left: 4px solid;
            border-radius: 8px;
        }

        .risk.low {
            border-left-color: var(--success);
        }

        .risk.medium {
            border-left-color: var(--warning);
        }

        .risk.high {
            border-left-color: var(--danger);
        }

        .risk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .risk-header h4 {
            margin: 0;
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .risk-severity {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .risk-severity.low {
            background: var(--success-light);
            color: var(--success-text);
        }

        .risk-severity.medium {
            background: var(--warning-light);
            color: var(--warning-text);
        }

        .risk-severity.high {
            background: var(--danger-light);
            color: var(--danger-text);
        }

        .risk-body p {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .risk-mitigation {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .risk-mitigation strong {
            font-size: 13px;
            color: var(--text-primary);
        }

        .risk-mitigation p {
            margin: 4px 0 0 0;
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Prerequisites */
        .prerequisites-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .prerequisite {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .prerequisite-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .prerequisite-text {
            flex: 1;
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Inspiration Grid */
        .inspiration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }

        .inspiration-card {
            display: flex;
            flex-direction: column;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }

        .inspiration-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-md);
        }

        .delete-inspiration-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            z-index: 10;
            padding: 8px;
            background: rgba(239, 68, 68, 0.9);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inspiration-card:hover .delete-inspiration-btn {
            opacity: 1;
        }

        .delete-inspiration-btn:hover {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.1);
        }

        .inspiration-image {
            width: 100%;
            height: 160px;
            object-fit: cover;
            background: var(--surface-hover);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 48px;
        }

        .inspiration-content {
            padding: 16px;
            flex: 1;
        }

        .inspiration-type {
            display: inline-block;
            padding: 4px 8px;
            background: var(--tag-bg);
            color: var(--tag-text);
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .inspiration-content h4 {
            margin: 0 0 8px 0;
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .inspiration-content p {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .inspiration-link {
            font-size: 12px;
            color: var(--primary);
            text-decoration: none;
            word-break: break-all;
        }

        .inspiration-link:hover {
            text-decoration: underline;
        }

        /* Linked Items List */
        .linked-items-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .linked-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .linked-item:hover {
            background: var(--surface-hover);
            box-shadow: var(--shadow-sm);
        }

        .linked-item-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .linked-item-content {
            flex: 1;
        }

        .linked-item-content h4 {
            margin: 0 0 4px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .linked-item-relationship {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .detail-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
                padding: 16px;
            }

            .detail-tabs {
                padding: 0 16px;
                overflow-x: scroll;
            }

            .detail-content {
                padding: 16px;
            }

            .timeline-items-grid,
            .inspiration-grid {
                grid-template-columns: 1fr;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
        }

        /* ========== WORKSPACE STYLES ========== */

        /* Header Left - Workspace Container */
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            flex: 1;
        }

        .workspace-selector-container {
            display: flex;
            align-items: center;
        }

        /* Workspace Button */
        .btn-workspace {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-workspace:hover {
            background: var(--hover-color);
            border-color: var(--primary);
        }

        .workspace-icon {
            font-size: 18px;
            line-height: 1;
        }

        .workspace-name {
            font-weight: 500;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .workspace-arrow {
            font-size: 10px;
            opacity: 0.6;
            transition: transform 0.2s;
        }

        .btn-workspace:hover .workspace-arrow {
            transform: translateY(2px);
        }

        /* Workspace Dropdown */
        .workspace-dropdown {
            position: relative;
        }

        .workspace-dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            padding: 8px;
        }

        .workspace-dropdown-menu.hidden {
            display: none;
        }

        .workspace-item {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 10px 12px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .workspace-item:hover {
            background: var(--hover-color);
        }

        .workspace-item.active {
            background: var(--primary-alpha);
            color: var(--primary);
        }

        .workspace-item .workspace-icon {
            font-size: 20px;
        }

        .workspace-item .workspace-name {
            flex: 1;
            font-weight: 400;
        }

        .workspace-item.active .workspace-name {
            font-weight: 600;
        }

        .workspace-check {
            color: var(--success);
            font-size: 16px;
        }

        .workspace-divider {
            height: 1px;
            background: var(--border-color);
            margin: 8px 0;
        }

        /* Workspace Modal */
        .workspace-modal {
            max-width: 500px;
        }

        .workspace-modal .form-group {
            margin-bottom: 16px;
        }

        .workspace-modal label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .workspace-modal .form-control {
            width: 100%;
            padding: 8px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .workspace-modal .form-control:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-elevated);
        }

        .workspace-modal textarea.form-control {
            resize: vertical;
            min-height: 80px;
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .color-picker input[type="color"] {
            width: 60px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
        }

        .form-hint {
            display: block;
            margin-top: 4px;
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Workspace Manage Modal */
        .workspace-manage-modal {
            max-width: 700px;
        }

        .workspace-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .workspace-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 16px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .workspace-list-item:hover {
            border-color: var(--primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .workspace-list-item.active {
            background: var(--primary-alpha);
            border-color: var(--primary);
        }

        .workspace-info {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            flex: 1;
        }

        .workspace-icon-lg {
            font-size: 32px;
            line-height: 1;
        }

        .workspace-details {
            flex: 1;
        }

        .workspace-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .workspace-meta {
            font-size: 13px;
            color: var(--text-muted);
        }

        .workspace-stats {
            margin-top: 4px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .workspace-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .workspace-badge-current {
            padding: 4px 10px;
            background: var(--success-alpha);
            color: var(--success);
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        /* Workspace Welcome Screen */
        .workspace-welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            text-align: center;
            padding: 40px;
        }

        .workspace-welcome-icon {
            font-size: 80px;
            margin-bottom: 24px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .workspace-welcome h2 {
            font-size: 28px;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .workspace-welcome p {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            max-width: 500px;
        }

        .workspace-welcome-subtitle {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 32px !important;
        }

        .btn-lg {
            padding: 12px 32px;
            font-size: 16px;
        }

        /* Button Sizes */
        .btn-sm {
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
            border: 1px solid var(--danger);
        }

        .btn-danger:hover {
            background: #c82333;
            border-color: #bd2130;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background: var(--bg-elevated);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 90%;
            max-height: 90vh;
            overflow: auto;
            animation: modalFadeIn 0.2s ease;
            padding: 24px;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: transparent;
            border: none;
            font-size: 28px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            line-height: 1;
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 24px;
        }

        .modal-footer {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 24px;
            border-top: 1px solid var(--border-color);
        }

        /* Responsive Workspace Styles */
        @media (max-width: 768px) {
            .header-left {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .workspace-name {
                max-width: 150px;
            }

            .workspace-dropdown-menu {
                min-width: 240px;
            }

            .workspace-list-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .workspace-actions {
                width: 100%;
                justify-content: flex-end;
            }

            .workspace-welcome {
                padding: 20px;
            }

            .workspace-welcome h2 {
                font-size: 22px;
            }

            .workspace-welcome-icon {
                font-size: 60px;
            }
        }

        /* ========== END WORKSPACE STYLES ========== */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>🚀 Platform Roadmap</h1>
                <div id="workspaceSelector" class="workspace-selector-container"></div>
            </div>
            <div class="header-main-actions">
                <input type="text" id="searchInput" class="header-search focus-ring" placeholder="🔍 Search..." oninput="app.debouncedApplyFilters()" title="Ctrl/Cmd+K">
                <button class="btn-primary btn-compact" onclick="app.showAddModal()" title="Add Feature (N)">+ Add</button>
                <button class="btn-ai-create btn-compact" onclick="app.showAIAssistedFeatureCreation()" title="Create with AI Assistant">✨ AI Create</button>
            </div>
            <div class="header-actions">
                <button class="btn-secondary btn-compact" onclick="app.exportAllData()" title="Export complete backup">💾</button>
                <button class="btn-secondary btn-compact" onclick="app.importAllData()" title="Import from backup">📂</button>
                <button class="btn-secondary btn-compact" onclick="app.analyzeBatchLinks(event)" title="AI-powered link detection">🔗</button>
                <button class="btn-secondary btn-compact" onclick="app.exportToCSV()" title="Export CSV">📥</button>
                <button class="btn-secondary btn-compact" onclick="app.toggleAIActionPanel()" title="AI Actions Log">📝 <span id="aiActionCount" style="background:var(--info); color:var(--text-inverse); border-radius:10px; padding:0 6px; font-size:11px; margin-left:4px;">0</span></button>
                <button class="btn-secondary btn-compact" onclick="app.toggleTheme()" title="Toggle dark mode">🌓</button>
                <div id="syncStatus" class="sync-status sync-status-offline" title="Sync status">📦 Offline</div>
                <div id="bulkActions" class="bulk-actions" role="region" aria-label="Bulk actions">
                    <span id="bulkCount" style="font-size:12px;">0</span>
                    <button class="btn-danger btn-compact" onclick="app.bulkDeleteSelected()" style="font-size:11px;">Delete</button>
                    <button class="btn-primary btn-compact" onclick="app.exportSelectedToCSV()" style="font-size:11px;">Export</button>
                </div>
            </div>
        </div>

        <!-- Link Suggestion Notification -->
        <div id="linkNotification" class="link-notification hidden" onclick="app.toggleLinkSuggestions()">
            <div class="link-notification-collapsed">
                <span>🔗 <span id="linkSuggestionCount">0</span> new link suggestions</span>
                <span class="link-notification-badge">Click to review</span>
            </div>
            <div class="link-notification-expanded" id="linkSuggestionsList" onclick="event.stopPropagation()">
                <!-- Link suggestions will be rendered here -->
            </div>
        </div>

        <div class="content">
            <!-- Table View -->
            <div id="tableView" class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width:36px;"> <input type="checkbox" id="selectAll" onchange="app.toggleSelectAll(this.checked)" class="focus-ring" aria-label="Select all"> </th>
                            <th class="sortable" onclick="app.sortTable(event,'name')">Name</th>
                            <th class="sortable" onclick="app.sortTable(event,'type')">Type</th>
                            <th class="th-with-filter">
                                <span class="th-label">Timeline</span>
                                <select id="timelineFilter" class="th-filter" onchange="app.applyFilters()">
                                    <option value="">All</option>
                                    <option value="MVP">MVP</option>
                                    <option value="SHORT">SHORT</option>
                                    <option value="LONG">LONG</option>
                                </select>
                            </th>
                            <th class="th-with-filter">
                                <span class="th-label">Difficulty</span>
                                <select id="difficultyFilter" class="th-filter" onchange="app.applyFilters()">
                                    <option value="">All</option>
                                    <option value="Easy">Easy</option>
                                    <option value="Medium">Medium</option>
                                    <option value="Hard">Hard</option>
                                </select>
                            </th>
                            <th>Purpose</th>
                            <th>USP</th>
                            <th>Integration Type</th>
                            <th class="th-with-filter">
                                <span class="th-label">Category</span>
                                <select id="categoryFilter" class="th-filter" onchange="app.applyFilters()">
                                    <option value="">All</option>
                                </select>
                            </th>
                            <th>Linked Items</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Rows will be inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- Detail View -->
            <div id="detailView" class="detail-view hidden">
                <div class="detail-header">
                    <button class="back-btn" onclick="app.showTableView()" aria-label="Back to table">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 18l-8-8 8-8 1.4 1.4L5.8 9H18v2H5.8l5.6 5.6L10 18z"/>
                        </svg>
                        Back
                    </button>
                    <div class="detail-header-content">
                        <h1 id="detailFeatureName"></h1>
                        <div class="detail-badges" id="detailBadges"></div>
                    </div>
                    <div class="detail-header-actions">
                        <button class="btn-ai-create btn-compact" onclick="app.startAIEnhancementWorkflow(app.currentFeatureId)" title="AI Enhance Feature">
                            ✨ AI Enhance
                        </button>
                        <button class="btn-secondary" onclick="app.editFeatureFromDetail()" title="Edit feature">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5L13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5z"/>
                            </svg>
                            Edit
                        </button>
                    </div>
                </div>

                <div class="detail-tabs">
                    <button class="detail-tab active" onclick="app.switchDetailTab('overview')">Overview</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('execution')">Execution Guide</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('resources')">Resources</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('planning')">Planning</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('inspiration')">Inspiration</button>
                </div>

                <div class="detail-content">
                    <!-- Overview Tab -->
                    <div id="overviewTab" class="detail-tab-content active">
                        <div class="detail-section">
                            <h2>Purpose</h2>
                            <p id="detailPurpose" class="detail-text"></p>
                        </div>

                        <div class="detail-section">
                            <h2>Unique Selling Proposition</h2>
                            <p id="detailUSP" class="detail-text"></p>
                        </div>

                        <div class="detail-section">
                            <h2>Integration Type</h2>
                            <p id="detailIntegration" class="detail-text"></p>
                        </div>

                        <div class="detail-section">
                            <h2>Timeline Items</h2>
                            <div id="detailTimelineItems" class="timeline-items-grid"></div>
                        </div>

                        <div class="detail-section">
                            <h2>Linked Features</h2>
                            <div id="detailLinkedItems" class="linked-items-list"></div>
                        </div>
                    </div>

                    <!-- Execution Guide Tab -->
                    <div id="executionTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Execution Steps</h2>
                                <button class="btn-ai" onclick="app.generateExecutionPlan()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Generate
                                </button>
                            </div>
                            <div id="executionStepsList" class="execution-steps"></div>
                            <button class="btn-secondary" onclick="app.addExecutionStep()">+ Add Step</button>
                        </div>
                    </div>

                    <!-- Resources Tab -->
                    <div id="resourcesTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Required Resources</h2>
                                <button class="btn-ai" onclick="app.suggestResources()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Suggest
                                </button>
                            </div>
                            <div id="resourcesContent" class="resources-grid"></div>
                        </div>
                    </div>

                    <!-- Planning Tab -->
                    <div id="planningTab" class="detail-tab-content">
                        <div class="detail-section">
                            <h2>Milestones</h2>
                            <div id="milestonesList" class="milestones-list"></div>
                            <button class="btn-secondary" onclick="app.addMilestone()">+ Add Milestone</button>
                        </div>

                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Risk Assessment</h2>
                                <button class="btn-ai" onclick="app.identifyRisks()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Identify
                                </button>
                            </div>
                            <div id="risksList" class="risks-list"></div>
                            <button class="btn-secondary" onclick="app.addRisk()">+ Add Risk</button>
                        </div>

                        <div class="detail-section">
                            <h2>Prerequisites</h2>
                            <div id="prerequisitesList" class="prerequisites-list"></div>
                            <button class="btn-secondary" onclick="app.addPrerequisite()">+ Add Prerequisite</button>
                        </div>
                    </div>

                    <!-- Inspiration Tab -->
                    <div id="inspirationTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>References & Inspiration</h2>
                                <button class="btn-ai" onclick="app.findInspiration()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                                    </svg>
                                    Find Inspiration
                                </button>
                            </div>
                            <div id="inspirationList" class="inspiration-grid"></div>
                            <button class="btn-secondary" onclick="app.addInspiration()">+ Add Reference</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Feature Modal -->
    <div id="featureModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Add Feature</h2>
                <button class="close-btn" onclick="app.closeModal()">&times;</button>
            </div>
            <form id="featureForm" onsubmit="app.saveFeature(event)">
                <div class="form-group">
                    <label>Name *</label>
                    <input type="text" id="featureName" required>
                </div>
                <div class="form-group">
                    <label>Type *</label>
                    <select id="featureType" required>
                        <option value="">Select type</option>
                        <option value="Feature">Feature</option>
                        <option value="Service">Service</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Purpose</label>
                    <textarea id="featurePurpose" placeholder="What is the purpose of this feature/service?"></textarea>
                </div>

                <!-- Timeline Breakdown Section -->
                <div class="form-group" style="border-top:2px solid var(--border); padding-top:15px; margin-top:15px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <label style="margin:0; font-size:16px; font-weight:600;">Timeline Breakdown *</label>
                        <button type="button" class="btn-primary" onclick="app.addTimelineItem()" style="font-size:12px; padding:6px 12px;">+ Add Timeline Item</button>
                    </div>
                    <div id="timelineItemsContainer">
                        <!-- Timeline items will be rendered here -->
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button type="button" class="btn-secondary" onclick="app.closeModal()">Cancel</button>
                    <button type="submit" class="btn-success">Save Feature</button>
                </div>
            </form>
        </div>
    </div>

    <!-- AI Chat -->
    <button class="chat-button" onclick="app.toggleChat()">💬</button>
    <div id="chatPanel" class="chat-panel">
        <div class="chat-panel-resizer" id="chatPanelResizer"></div>
        <div class="chat-header">
            <div class="chat-header-top">
                <div id="chatHeaderApiStatus" class="chat-header-api-status hidden" onclick="app.toggleApiKeyInput()">
                    <span class="chat-header-api-indicator"></span>
                    <span>API Connected</span>
                    <button class="chat-header-api-toggle" onclick="event.stopPropagation(); app.toggleApiKeyInput()">Settings</button>
                </div>
                <h3>🤖 AI Assistant</h3>
                <div class="chat-header-actions">
                    <button class="chat-icon-btn" onclick="app.toggleMemoryPanel()" title="Memory">🧠</button>
                    <button class="chat-icon-btn" onclick="app.compactConversation()" title="New Conversation">🔄</button>
                    <button class="close-btn" onclick="app.toggleChat()">&times;</button>
                </div>
            </div>
        </div>

        <!-- Link Picker Modal -->
        <div id="linkPickerOverlay" class="link-picker-overlay hidden" onclick="app.closeLinkPicker()"></div>
        <div id="linkPickerModal" class="link-picker-modal hidden">
            <h3>Add Link</h3>
            <div class="link-picker-form">
                <div>
                    <label>Target Feature *</label>
                    <select id="linkTargetFeature" onchange="app.updateLinkTargetItems()" required>
                        <option value="">Select feature...</option>
                    </select>
                </div>
                <div>
                    <label>Target Timeline Item *</label>
                    <select id="linkTargetItem" required>
                        <option value="">Select timeline item...</option>
                    </select>
                </div>
                <div>
                    <label>Relationship Type *</label>
                    <div style="display:flex; gap:15px; margin-top:8px;">
                        <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="linkType" value="dependency" checked>
                            <span>Dependency</span>
                        </label>
                        <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="linkType" value="complements">
                            <span>Complements</span>
                        </label>
                    </div>
                </div>
                <div>
                    <label>Reason (Optional)</label>
                    <input type="text" id="linkReason" placeholder="Why are these items linked?">
                </div>
            </div>
            <div class="link-picker-actions">
                <button onclick="app.closeLinkPicker()" style="background:var(--neutral-medium); color:var(--text-inverse);">Cancel</button>
                <button onclick="app.saveManualLink()" style="background:var(--success); color:var(--text-inverse);">Add Link</button>
            </div>
        </div>

        <!-- Rejection Reason Modal -->
        <div id="rejectionReasonOverlay" class="link-picker-overlay hidden" onclick="app.closeRejectionReason()"></div>
        <div id="rejectionReasonModal" class="link-picker-modal hidden">
            <h3>Why reject this link?</h3>
            <div class="link-picker-form">
                <div>
                    <label>Rejection Reason *</label>
                    <select id="rejectionCategory" required>
                        <option value="">Select reason...</option>
                        <option value="not-related">Not related to each other</option>
                        <option value="wrong-type">Wrong relationship type</option>
                        <option value="timeline-mismatch">Timeline mismatch (too early/late)</option>
                        <option value="already-covered">Already covered by another link</option>
                        <option value="other">Other reason</option>
                    </select>
                </div>
                <div>
                    <label>Additional Notes (Optional)</label>
                    <input type="text" id="rejectionNotes" placeholder="Any additional context...">
                </div>
            </div>
            <div class="link-picker-actions">
                <button onclick="app.closeRejectionReason()" style="background:var(--neutral-medium); color:var(--text-inverse);">Cancel</button>
                <button onclick="app.confirmRejection()" style="background:var(--danger); color:var(--text-inverse);">Reject Link</button>
            </div>
        </div>

        <!-- AI Action Approval Modal -->
        <div id="aiActionOverlay" class="link-picker-overlay hidden" onclick="app.closeAIActionApproval()"></div>
        <div id="aiActionModal" class="link-picker-modal hidden" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <h3 id="aiActionTitle">AI Suggested Actions</h3>

            <!-- Summary header -->
            <div id="aiActionSummary" style="margin: 10px 0; padding: 10px; background: rgba(102, 126, 234, 0.1); border-radius: 6px; font-size: 13px; font-weight: 600; color: var(--text-primary); border-left: 4px solid #667eea;">
                <!-- Summary will be inserted here -->
            </div>

            <!-- Actions list -->
            <div id="aiActionsQueue" style="margin: 15px 0; max-height: 400px; overflow-y: auto;">
                <!-- Dynamic queue of actions will be inserted here -->
            </div>

            <!-- Bulk action buttons -->
            <div class="link-picker-actions" style="display: flex; gap: 8px; flex-wrap: wrap;">
                <button onclick="app.rejectAllAIActions()" style="background:var(--danger); color:var(--text-inverse);">✕ Reject All</button>
                <button onclick="app.closeAIActionApproval()" style="background:var(--neutral-medium); color:var(--text-inverse);">Cancel</button>
                <button onclick="app.approveAllAIActions()" style="background:var(--success); color:var(--text-inverse); flex: 1;">✓ Approve All</button>
            </div>
        </div>

        <!-- Migration Modal -->
        <div id="migrationOverlay" class="link-picker-overlay hidden"></div>
        <div id="migrationModal" class="link-picker-modal hidden" style="max-width: 500px;">
            <h3>🚀 Migrate to Cloud Sync</h3>
            <div class="migration-content">
                <p>You have <strong id="migrationCount">0</strong> features saved locally.</p>
                <p>Would you like to migrate your data to the cloud for automatic sync across all your browsers and devices?</p>
                <div style="margin: 15px 0; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 6px; font-size: 13px;">
                    <strong>Benefits:</strong>
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Auto-sync across all browsers</li>
                        <li>Access from any device</li>
                        <li>Never lose your data</li>
                        <li>Real-time updates</li>
                    </ul>
                </div>
            </div>
            <div class="link-picker-actions" style="display: flex; gap: 8px;">
                <button onclick="app.skipMigration()" style="background:var(--neutral-medium); color:var(--text-inverse);">Skip</button>
                <button onclick="app.migrateToCloud()" style="background:var(--success); color:var(--text-inverse); flex: 1;">✓ Migrate to Cloud</button>
            </div>
        </div>

        <!-- Memory Suggestion Notification -->
        <div id="memoryNotification" class="memory-notification hidden" onclick="app.toggleMemorySuggestions()">
            <div class="memory-notification-collapsed">
                <span>🧠 <span id="suggestionCount">0</span> new memory suggestions</span>
                <span class="memory-notification-badge">Click to review</span>
            </div>
            <div class="memory-notification-expanded" id="memorySuggestionsList" onclick="event.stopPropagation()">
                <!-- Suggestions will be rendered here -->
            </div>
        </div>

        <!-- Memory Panel -->
        <div id="memoryPanel" class="memory-panel hidden">
            <h4>
                <span>Memory & Context</span>
                <div class="memory-actions">
                    <button onclick="app.clearMemory()">Clear All</button>
                    <button onclick="app.toggleMemoryPanel()">Close</button>
                </div>
            </h4>

            <!-- Custom Instructions -->
            <div style="margin-bottom:15px;">
                <label style="display:block; font-size:11px; font-weight:600; color:var(--text-muted); margin-bottom:5px;">Custom Instructions</label>
                <textarea id="customInstructionsInput"
                          placeholder="Enter custom instructions for the AI (e.g., your role, context, tone preferences)..."
                          style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:12px; font-family:inherit; resize:vertical; min-height:80px; background:var(--surface); color:var(--text-primary);"
                          onchange="app.saveCustomInstructions(this.value)"></textarea>
            </div>

            <!-- Memory Items -->
            <div>
                <label style="display:block; font-size:11px; font-weight:600; color:var(--text-muted); margin-bottom:5px;">Memory Items</label>

                <!-- Add Memory Input -->
                <div style="display:flex; gap:5px; margin-bottom:10px;">
                    <input type="text" id="addMemoryInput" placeholder="Add to memory..."
                           style="flex:1; padding:6px 8px; border:2px solid var(--border); border-radius:4px; font-size:12px; background:var(--surface); color:var(--text-primary);"
                           onkeypress="if(event.key==='Enter') app.addMemoryFromInput()">
                    <button onclick="app.addMemoryFromInput()"
                            style="padding:6px 12px; background:var(--primary); color:var(--text-inverse); border:none; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600;">Add</button>
                </div>

                <div id="memoryList"></div>
            </div>

            <!-- Message Counter -->
            <div style="margin-top:10px; padding:8px; background:var(--surface); border-radius:4px; font-size:11px; color:var(--text-muted);">
                Messages: <span id="messageCounter">0</span> | Memory items: <span id="memoryCounter">0</span>
            </div>
        </div>

        <!-- AI Action Log Panel -->
        <div id="actionLogPanel" class="memory-panel hidden">
            <h4>
                <span>AI Action Log</span>
                <div class="memory-actions">
                    <button onclick="app.exportAIActionLog()">Export</button>
                    <button onclick="app.clearAIActionLog()">Clear</button>
                    <button onclick="app.toggleAIActionPanel()">Close</button>
                </div>
            </h4>

            <div id="actionLogList" style="max-height:260px; overflow:auto;"></div>

            <div style="margin-top:10px; padding:8px; background:var(--surface); border-radius:4px; font-size:11px; color:var(--text-muted);">
                Total actions: <span id="aiActionTotal">0</span>
            </div>
        </div>

        <!-- Context Warning -->
        <div id="contextWarning" class="context-warning hidden">
            ⚠️ Conversation is getting long. Consider starting a new conversation to maintain performance.
            <button onclick="app.compactConversation()" style="margin-left:8px; padding:2px 8px; font-size:11px; background:var(--surface); border:1px solid var(--warning); border-radius:3px; cursor:pointer; color:var(--text-primary);">Start New</button>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="chat-message ai">
                👋 Hi! I'm your AI assistant. I can help you with:
                <br>• Analyzing your features
                <br>• Suggesting improvements
                <br>• Cleaning up data
                <br>• Answering questions
                <br><br>First, please add your OpenRouter API key below.
            </div>
        </div>
        <div class="chat-input-container">
            <div class="api-key-input">
                <div id="apiKeyInputSection" class="hidden">
                    <label>OpenRouter API Key</label>
                    <input type="password" id="apiKeyInput" placeholder="Enter your API key"
                           value="" onchange="app.saveApiKey(this.value)">
                    <label>AI Model</label>
                    <select id="modelSelect" onchange="app.saveModel(this.value)">
                        <option value="deepseek/deepseek-v3.1-terminus">DeepSeek V3.1 Terminus (671B params)</option>
                        <option value="anthropic/claude-haiku-4.5">Claude Haiku 4.5 (fastest)</option>
                        <option value="openai/gpt-4o-mini">GPT-4o Mini</option>
                        <option value="moonshotai/kimi-k2">Kimi K2 (1T params, 256K context)</option>
                        <option value="x-ai/grok-4-fast">Grok 4 Fast (2M context)</option>
                    </select>
                    <label style="margin-top: 10px;">Tavily API Key (Optional - for internet search)</label>
                    <input type="password" id="tavilyApiKeyInput" placeholder="Enter Tavily API key (optional)"
                           value="" onchange="app.saveTavilyApiKey(this.value)">
                    <small style="color: var(--text-muted); font-size: 11px; display: block; margin-top: 5px;">
                        Get free API key at <a href="https://tavily.com" target="_blank" style="color: #667eea;">tavily.com</a> (1000 searches/month free)
                    </small>
                    <button class="btn-secondary" style="width: 100%; margin-top: 10px;" onclick="app.toggleApiKeyInput()">Done</button>
                </div>
            </div>
            <div class="chat-input-wrapper">
                <div class="input-row">
                    <textarea id="chatInput" placeholder="Ask me anything..." rows="1"
                              oninput="app.autoResizeTextarea(this)"
                              onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); app.sendMessage(); }"></textarea>
                    <button class="btn-primary" onclick="app.sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhancement Panel (Independent) -->
    <div id="enhancementPanel" class="enhancement-panel hidden">
        <div class="enhancement-header">
            <h3>✨ AI Feature Enhancement</h3>
            <button class="close-btn" onclick="app.closeEnhancementPanel()">&times;</button>
        </div>

        <div class="enhancement-content">
            <!-- Understanding Section -->
            <div class="enhancement-section">
                <div class="enhancement-section-title">📋 Current Understanding</div>
                <div id="enhancementUnderstanding" class="enhancement-understanding">
                    <div class="understanding-item">
                        <span class="understanding-label">Feature:</span>
                        <span id="understandingName">-</span>
                    </div>
                    <div class="understanding-item">
                        <span class="understanding-label">Type:</span>
                        <span id="understandingType">-</span>
                    </div>
                    <div class="understanding-item">
                        <span class="understanding-label">Purpose:</span>
                        <span id="understandingPurpose">-</span>
                    </div>
                </div>
            </div>

            <!-- Gaps Section -->
            <div class="enhancement-section">
                <div class="enhancement-section-title">🎯 What's Missing</div>
                <div id="enhancementGaps" class="enhancement-gaps">
                    <!-- Gaps will be populated here -->
                </div>
            </div>

            <!-- Questions Section -->
            <div class="enhancement-section">
                <div class="enhancement-section-title">💬 Clarifying Questions</div>
                <div id="enhancementQuestions" class="enhancement-questions">
                    <p class="enhancement-loading">Analyzing feature...</p>
                </div>
            </div>

            <!-- Progress Section (hidden initially) -->
            <div id="enhancementProgress" class="enhancement-section hidden">
                <div class="enhancement-section-title">🔍 Research Progress</div>
                <div class="enhancement-progress-bar">
                    <div id="enhancementProgressFill" class="enhancement-progress-fill"></div>
                </div>
                <div id="enhancementProgressText" class="enhancement-progress-text">Searching...</div>
            </div>

            <!-- Actions -->
            <div class="enhancement-actions">
                <button class="btn-secondary" onclick="app.closeEnhancementPanel()">Cancel</button>
                <button id="enhancementSubmitBtn" class="btn-primary" onclick="app.submitEnhancementAnswers()" disabled>
                    Start Enhancement
                </button>
            </div>
        </div>
    </div>

    <!-- Supabase JS Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // Supabase Configuration
        const SUPABASE_URL = 'https://xobyeusefijdvsqkzxvm.supabase.co';
        const SUPABASE_ANON_KEY = 'REDACTED_SUPABASE_KEY';

        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Supabase Service Module
        const supabaseService = {
            isConnected: false,
            userId: null,
            subscriptions: [],

            // Initialize and get/create anonymous user ID
            async init() {
                try {
                    // Use a shared 'default' user ID so all browsers see the same data
                    // Perfect for personal roadmap manager - your data syncs everywhere!
                    this.userId = 'default';
                    console.log('✅ Using shared user ID for cross-browser sync:', this.userId);

                    // Test connection
                    const { error } = await supabase.from('features').select('count', { count: 'exact', head: true });
                    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows, which is fine
                        throw error;
                    }

                    this.isConnected = true;
                    console.log('✅ Supabase connected successfully');
                    return true;
                } catch (error) {
                    console.warn('⚠️ Supabase connection failed:', error.message);
                    this.isConnected = false;
                    return false;
                }
            },

            // Generate unique ID
            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
            },

            // Set user ID for RLS policies
            async setUserId() {
                try {
                    await supabase.rpc('set_config', {
                        setting: 'app.user_id',
                        value: this.userId
                    });
                } catch (error) {
                    // Fallback: use client-side filtering
                    console.log('Using client-side filtering for user data');
                }
            },

            // Load features from Supabase
            async loadFeatures() {
                if (!this.isConnected) return null;

                try {
                    await this.setUserId();

                    // Load features
                    const { data: features, error: featuresError } = await supabase
                        .from('features')
                        .select('*')
                        .eq('user_id', this.userId)
                        .order('created_at', { ascending: false });

                    if (featuresError) throw featuresError;

                    if (!features || features.length === 0) {
                        console.log('ℹ️ No features found in cloud');
                        return [];
                    }

                    // Load timeline items for all features
                    const { data: timelineItems, error: itemsError } = await supabase
                        .from('timeline_items')
                        .select('*')
                        .eq('user_id', this.userId);

                    if (itemsError) throw itemsError;

                    // Load linked items
                    const { data: linkedItems, error: linksError } = await supabase
                        .from('linked_items')
                        .select('*')
                        .eq('user_id', this.userId);

                    if (linksError) throw linksError;

                    // Combine data structure to match app format
                    const combinedFeatures = features.map(feature => {
                        // Get timeline items for this feature
                        const items = timelineItems.filter(item => item.feature_id === feature.id);

                        // Add linked items to each timeline item
                        const itemsWithLinks = items.map(item => {
                            const links = linkedItems
                                .filter(link => link.source_item_id === item.id || link.target_item_id === item.id)
                                .map(link => ({
                                    linkedItemId: link.target_item_id === item.id ? link.source_item_id : link.target_item_id,
                                    linkedFeatureId: '', // Will be populated by app
                                    relationshipType: link.relationship_type,
                                    reason: link.reason,
                                    direction: link.source_item_id === item.id ? 'outgoing' : 'incoming'
                                }));

                            return {
                                id: item.id,
                                timeline: item.timeline,
                                difficulty: item.difficulty,
                                usp: item.usp,
                                integrationType: item.integration_type,
                                category: item.category || [],
                                linkedItems: links.length > 0 ? links : undefined,
                                createdAt: item.created_at
                            };
                        });

                        return {
                            id: feature.id,
                            name: feature.name,
                            type: feature.type,
                            purpose: feature.purpose,
                            workspaceId: feature.workspace_id,
                            aiGenerated: feature.ai_generated,
                            aiCreated: feature.ai_created,
                            aiModified: feature.ai_modified,
                            timelineItems: itemsWithLinks,
                            createdAt: feature.created_at,
                            updatedAt: feature.updated_at
                        };
                    });

                    console.log(`✅ Loaded ${combinedFeatures.length} features from Supabase`);
                    return combinedFeatures;
                } catch (error) {
                    console.error('❌ Error loading from Supabase:', error);
                    return null;
                }
            },

            // Save all features to Supabase
            async syncFeatures(features) {
                if (!this.isConnected) return false;

                try {
                    await this.setUserId();

                    // Delete existing data for this user (full sync)
                    await supabase.from('features').delete().eq('user_id', this.userId);

                    if (features.length === 0) {
                        console.log('✅ Synced 0 features to Supabase');
                        return true;
                    }

                    // Prepare features for insert
                    const featuresData = features.map(f => ({
                        id: f.id,
                        user_id: this.userId,
                        workspace_id: f.workspaceId || null,
                        name: f.name,
                        type: f.type,
                        purpose: f.purpose,
                        ai_generated: f.aiGenerated || null,
                        ai_created: f.aiCreated || false,
                        ai_modified: f.aiModified || false,
                        created_at: f.createdAt || new Date().toISOString(),
                        updated_at: f.updatedAt || new Date().toISOString()
                    }));

                    // Insert features
                    const { error: featuresError } = await supabase
                        .from('features')
                        .insert(featuresData);

                    if (featuresError) throw featuresError;

                    // Prepare timeline items for insert
                    const timelineItemsData = [];
                    const linkedItemsData = [];

                    features.forEach(feature => {
                        if (feature.timelineItems && feature.timelineItems.length > 0) {
                            feature.timelineItems.forEach(item => {
                                timelineItemsData.push({
                                    id: item.id,
                                    feature_id: feature.id,
                                    user_id: this.userId,
                                    workspace_id: feature.workspaceId || null,
                                    timeline: item.timeline,
                                    difficulty: item.difficulty,
                                    usp: item.usp || null,
                                    integration_type: item.integrationType || null,
                                    category: item.category || [],
                                    created_at: item.createdAt || new Date().toISOString()
                                });

                                // Collect linked items
                                if (item.linkedItems && item.linkedItems.length > 0) {
                                    item.linkedItems.forEach(link => {
                                        linkedItemsData.push({
                                            user_id: this.userId,
                                            workspace_id: feature.workspaceId || null,
                                            source_item_id: link.direction === 'outgoing' ? item.id : link.linkedItemId,
                                            target_item_id: link.direction === 'outgoing' ? link.linkedItemId : item.id,
                                            relationship_type: link.relationshipType,
                                            reason: link.reason || null,
                                            direction: link.direction
                                        });
                                    });
                                }
                            });
                        }
                    });

                    // Insert timeline items
                    if (timelineItemsData.length > 0) {
                        const { error: itemsError } = await supabase
                            .from('timeline_items')
                            .insert(timelineItemsData);

                        if (itemsError) throw itemsError;
                    }

                    // Insert linked items (deduplicate first)
                    if (linkedItemsData.length > 0) {
                        const uniqueLinks = linkedItemsData.filter((link, index, self) =>
                            index === self.findIndex(l =>
                                l.source_item_id === link.source_item_id &&
                                l.target_item_id === link.target_item_id
                            )
                        );

                        if (uniqueLinks.length > 0) {
                            const { error: linksError } = await supabase
                                .from('linked_items')
                                .insert(uniqueLinks);

                            if (linksError) throw linksError;
                        }
                    }

                    console.log(`✅ Synced ${features.length} features to Supabase`);
                    return true;
                } catch (error) {
                    console.error('❌ Error syncing to Supabase:', error);
                    return false;
                }
            },

            // Subscribe to real-time changes
            subscribeToChanges(callback) {
                if (!this.isConnected) return;

                // Subscribe to features changes
                const featuresChannel = supabase
                    .channel('features-changes')
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'features',
                        filter: `user_id=eq.${this.userId}`
                    }, async (payload) => {
                        console.log('🔄 Features changed:', payload);
                        const features = await this.loadFeatures();
                        if (features) callback(features);
                    })
                    .subscribe();

                this.subscriptions.push(featuresChannel);

                // Subscribe to timeline_items changes
                const itemsChannel = supabase
                    .channel('timeline-items-changes')
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'timeline_items',
                        filter: `user_id=eq.${this.userId}`
                    }, async (payload) => {
                        console.log('🔄 Timeline items changed:', payload);
                        const features = await this.loadFeatures();
                        if (features) callback(features);
                    })
                    .subscribe();

                this.subscriptions.push(itemsChannel);

                console.log('✅ Subscribed to real-time updates');
            },

            // Unsubscribe from all changes
            unsubscribeAll() {
                this.subscriptions.forEach(sub => {
                    supabase.removeChannel(sub);
                });
                this.subscriptions = [];
                console.log('✅ Unsubscribed from all real-time updates');
            },

            // Load all workspaces
            async loadWorkspaces() {
                if (!this.isConnected) return null;

                try {
                    await this.setUserId();

                    const { data: workspaces, error } = await supabase
                        .from('workspaces')
                        .select('*')
                        .eq('user_id', this.userId)
                        .order('created_at', { ascending: false });

                    if (error) throw error;

                    console.log(`✅ Loaded ${workspaces?.length || 0} workspaces from Supabase`);
                    return workspaces || [];
                } catch (error) {
                    console.error('❌ Error loading workspaces:', error);
                    return null;
                }
            },

            // Create a new workspace
            async createWorkspace(workspace) {
                if (!this.isConnected) return false;

                try {
                    await this.setUserId();

                    const workspaceData = {
                        id: workspace.id,
                        user_id: this.userId,
                        name: workspace.name,
                        description: workspace.description || null,
                        color: workspace.color || '#3b82f6',
                        icon: workspace.icon || '📊',
                        custom_instructions: workspace.customInstructions || null,
                        ai_memory: workspace.aiMemory || [],
                        created_at: workspace.createdAt || new Date().toISOString(),
                        updated_at: workspace.updatedAt || new Date().toISOString()
                    };

                    const { error } = await supabase
                        .from('workspaces')
                        .insert([workspaceData]);

                    if (error) throw error;

                    console.log('✅ Created workspace:', workspace.name);
                    return true;
                } catch (error) {
                    console.error('❌ Error creating workspace:', error);
                    return false;
                }
            },

            // Update a workspace
            async updateWorkspace(workspaceId, updates) {
                if (!this.isConnected) return false;

                try {
                    await this.setUserId();

                    const updateData = {
                        name: updates.name,
                        description: updates.description,
                        color: updates.color,
                        icon: updates.icon,
                        custom_instructions: updates.customInstructions,
                        ai_memory: updates.aiMemory,
                        updated_at: new Date().toISOString()
                    };

                    const { error } = await supabase
                        .from('workspaces')
                        .update(updateData)
                        .eq('id', workspaceId)
                        .eq('user_id', this.userId);

                    if (error) throw error;

                    console.log('✅ Updated workspace:', workspaceId);
                    return true;
                } catch (error) {
                    console.error('❌ Error updating workspace:', error);
                    return false;
                }
            },

            // Delete a workspace (cascade deletes features)
            async deleteWorkspace(workspaceId) {
                if (!this.isConnected) return false;

                try {
                    await this.setUserId();

                    // Delete all features in this workspace (cascade will handle timeline_items and linked_items)
                    await supabase
                        .from('features')
                        .delete()
                        .eq('workspace_id', workspaceId)
                        .eq('user_id', this.userId);

                    // Delete the workspace
                    const { error } = await supabase
                        .from('workspaces')
                        .delete()
                        .eq('id', workspaceId)
                        .eq('user_id', this.userId);

                    if (error) throw error;

                    console.log('✅ Deleted workspace:', workspaceId);
                    return true;
                } catch (error) {
                    console.error('❌ Error deleting workspace:', error);
                    return false;
                }
            },

            // Load features for a specific workspace
            async loadWorkspaceFeatures(workspaceId) {
                if (!this.isConnected) return null;

                try {
                    await this.setUserId();

                    // Load features for this workspace
                    const { data: features, error: featuresError } = await supabase
                        .from('features')
                        .select('*')
                        .eq('user_id', this.userId)
                        .eq('workspace_id', workspaceId)
                        .order('created_at', { ascending: false });

                    if (featuresError) throw featuresError;

                    if (!features || features.length === 0) {
                        console.log('ℹ️ No features found in workspace');
                        return [];
                    }

                    // Load timeline items for all features in workspace
                    const { data: timelineItems, error: itemsError } = await supabase
                        .from('timeline_items')
                        .select('*')
                        .eq('user_id', this.userId)
                        .eq('workspace_id', workspaceId);

                    if (itemsError) throw itemsError;

                    // Load linked items for workspace
                    const { data: linkedItems, error: linksError } = await supabase
                        .from('linked_items')
                        .select('*')
                        .eq('user_id', this.userId)
                        .eq('workspace_id', workspaceId);

                    if (linksError) throw linksError;

                    // Combine data structure to match app format
                    const combinedFeatures = features.map(feature => {
                        // Get timeline items for this feature
                        const items = timelineItems.filter(item => item.feature_id === feature.id);

                        // Add linked items to each timeline item
                        const itemsWithLinks = items.map(item => {
                            const links = linkedItems
                                .filter(link => link.source_item_id === item.id || link.target_item_id === item.id)
                                .map(link => ({
                                    linkedItemId: link.target_item_id === item.id ? link.source_item_id : link.target_item_id,
                                    linkedFeatureId: '', // Will be populated by app
                                    relationshipType: link.relationship_type,
                                    reason: link.reason,
                                    direction: link.source_item_id === item.id ? 'outgoing' : 'incoming'
                                }));

                            return {
                                id: item.id,
                                timeline: item.timeline,
                                difficulty: item.difficulty,
                                usp: item.usp,
                                integrationType: item.integration_type,
                                category: item.category || [],
                                linkedItems: links.length > 0 ? links : undefined,
                                createdAt: item.created_at
                            };
                        });

                        return {
                            id: feature.id,
                            name: feature.name,
                            type: feature.type,
                            purpose: feature.purpose,
                            workspaceId: feature.workspace_id,
                            aiGenerated: feature.ai_generated,
                            aiCreated: feature.ai_created,
                            aiModified: feature.ai_modified,
                            timelineItems: itemsWithLinks,
                            createdAt: feature.created_at,
                            updatedAt: feature.updated_at
                        };
                    });

                    console.log(`✅ Loaded ${combinedFeatures.length} features from workspace`);
                    return combinedFeatures;
                } catch (error) {
                    console.error('❌ Error loading workspace features:', error);
                    return null;
                }
            },

            // Get connection status
            getStatus() {
                return {
                    connected: this.isConnected,
                    userId: this.userId
                };
            }
        };

        const app = {
            features: [],
            workspaces: [],
            currentWorkspaceId: null,
            currentView: 'table',
            currentFeatureId: null,
            currentTab: 'overview',
            editingId: null,
            currentTags: [],
            currentTimelineItems: [],
            allTags: new Set(),
            sortColumn: null,
            sortDirection: 'asc',
            apiKey: '',
            selectedModel: 'deepseek/deepseek-v3.1-terminus',
            tavilyApiKey: '',
            customInstructions: '',
            memory: [],
            memorySuggestions: [],
            linkSuggestions: [],
            rejectedLinks: [],
            conversationHistory: [],
            messageCount: 0,
            lastAnalysisCount: 0,
            pendingAIActions: [],
            aiActionLog: [],
            aiEditingEnabled: true,
            selectedFeatureIds: new Set(),
            inlineEditing: { id: null, field: null, prev: '' },
            isSavingFeature: false,
            aiFeatureCreationMode: false,
            aiFeatureEnhancementMode: false,

            async init() {
                // Initialize Supabase connection first
                await supabaseService.init();

                // Test localStorage availability
                if (!this.testLocalStorage()) {
                    this.showAlert({ title:'Storage disabled', message:'Browser storage is disabled or unavailable. Your data will NOT be saved. Check private mode, browser settings, or storage quota.', variant:'warning' });
                }

                // Check origin/path changes
                this.checkOriginChange();

                // Load workspaces first
                await this.loadWorkspaces();

                // Check if we have workspaces
                if (this.workspaces.length === 0) {
                    // Check if there are features that need a workspace
                    const stored = localStorage.getItem('roadmapFeatures');
                    const localFeatures = stored ? JSON.parse(stored) : [];

                    if (localFeatures.length > 0) {
                        // Features exist but no workspace - create one automatically
                        console.log(`⚠️ Found ${localFeatures.length} features without workspace. Creating default workspace...`);

                        const defaultWorkspace = await this.createWorkspace(
                            'My Roadmap',
                            'Default workspace containing your features',
                            '#3b82f6',
                            '📊'
                        );

                        // Assign all features to this workspace
                        localFeatures.forEach(f => {
                            if (!f.workspaceId) {
                                f.workspaceId = defaultWorkspace.id;
                            }
                        });
                        localStorage.setItem('roadmapFeatures', JSON.stringify(localFeatures));

                        // Set as current workspace
                        this.currentWorkspaceId = defaultWorkspace.id;
                        localStorage.setItem('currentWorkspaceId', defaultWorkspace.id);

                        // Sync to Supabase
                        await this.saveData();

                        console.log(`✅ Created default workspace and assigned ${localFeatures.length} features`);
                        // Continue with normal initialization
                    } else {
                        // No workspaces AND no features - show welcome screen
                        console.log('ℹ️ No workspaces found - showing welcome screen');
                        this.loadApiKey();
                        this.loadModel();
                        this.loadTavilyApiKey();
                        this.renderWorkspaceSelector();
                        this.showWorkspaceWelcome();
                        this.updateSyncStatus();
                        return;
                    }
                }

                // Load last used workspace or first workspace
                const lastWorkspaceId = localStorage.getItem('currentWorkspaceId');
                if (lastWorkspaceId && this.workspaces.find(w => w.id === lastWorkspaceId)) {
                    this.currentWorkspaceId = lastWorkspaceId;
                } else {
                    this.currentWorkspaceId = this.workspaces[0].id;
                    localStorage.setItem('currentWorkspaceId', this.currentWorkspaceId);
                }

                // Load features for current workspace
                if (supabaseService.isConnected) {
                    const workspaceFeatures = await supabaseService.loadWorkspaceFeatures(this.currentWorkspaceId);
                    if (workspaceFeatures !== null) {
                        this.features = workspaceFeatures;
                    }
                } else {
                    // Load all features from localStorage and filter by workspace
                    const stored = localStorage.getItem('roadmapFeatures');
                    if (stored) {
                        const allFeatures = JSON.parse(stored);
                        this.features = allFeatures.filter(f => f.workspaceId === this.currentWorkspaceId);
                    }
                }

                // Load workspace-specific AI settings
                const currentWorkspace = this.getCurrentWorkspace();
                if (currentWorkspace) {
                    this.customInstructions = currentWorkspace.customInstructions || '';
                    this.memory = currentWorkspace.aiMemory || [];
                }

                this.loadApiKey();
                this.loadModel();
                this.loadTavilyApiKey();
                this.loadMemorySuggestions();
                this.loadLinkSuggestions();
                this.loadRejectedLinks();
                this.loadAIActionLog();
                this.renderWorkspaceSelector();
                this.renderTable();
                this.setupTagInput();
                this.updateSuggestionNotification();
                this.updateLinkNotification();
                this.updateCounters();
                this.updateActionLogCounter();
                this.setupChatPanelResize();
                // set up debounced filters and restore UI state
                this.debouncedApplyFilters = this.debounce(this.applyFilters.bind(this), 200);
                this.restoreUIState();
                this.bindShortcuts();
                this.ensureLiveRegion();
                this.loadTheme();

                // Handle URL hash routing for deep links
                this.setupHashRouting();

                // Setup real-time sync for cross-browser updates
                if (supabaseService.isConnected) {
                    supabaseService.subscribeToChanges((updatedFeatures) => {
                        console.log('🔄 Real-time update received from another device/browser');
                        // Only update if features belong to current workspace
                        this.features = updatedFeatures.filter(f => f.workspaceId === this.currentWorkspaceId);
                        this.renderTable();
                        this.updateCounters();
                        // Also save to localStorage as cache
                        this.saveToLocalStorage();
                    });
                }

                // Show sync status
                this.updateSyncStatus();
            },

            setupHashRouting() {
                // Handle hash changes (back/forward buttons)
                window.addEventListener('hashchange', () => {
                    this.handleHashChange();
                });

                // Handle initial hash on page load
                this.handleHashChange();
            },

            handleHashChange() {
                const hash = window.location.hash.substring(1); // Remove #

                if (hash.startsWith('feature/')) {
                    const featureId = hash.substring(8); // Remove 'feature/'
                    if (featureId && this.features.find(f => f.id === featureId)) {
                        this.showDetailView(featureId);
                    } else {
                        this.showTableView();
                    }
                } else {
                    // No hash or unrecognized hash - show table
                    if (this.currentView !== 'table') {
                        this.showTableView();
                    }
                }
            },

            // --- Utilities: debounce + UI state persistence + shortcuts ---
            _debounceTimer: null,
            debounce(fn, wait = 200) {
                return (...args) => {
                    clearTimeout(this._debounceTimer);
                    this._debounceTimer = setTimeout(() => fn.apply(this, args), wait);
                };
            },
            debouncedApplyFilters: null,
            saveUIState() {
                try {
                    const state = {
                        search: document.getElementById('searchInput')?.value || '',
                        timeline: document.getElementById('timelineFilter')?.value || '',
                        difficulty: document.getElementById('difficultyFilter')?.value || '',
                        category: document.getElementById('categoryFilter')?.value || '',
                        sortColumn: this.sortColumn,
                        sortDirection: this.sortDirection
                    };
                    localStorage.setItem('uiState', JSON.stringify(state));
                } catch {}
            },
            restoreUIState() {
                try {
                    const raw = localStorage.getItem('uiState');
                    if (!raw) return;
                    const state = JSON.parse(raw);
                    const si = document.getElementById('searchInput');
                    if (si) si.value = state.search || '';
                    const tf = document.getElementById('timelineFilter');
                    if (tf) tf.value = state.timeline || '';
                    const df = document.getElementById('difficultyFilter');
                    if (df) df.value = state.difficulty || '';
                    const cf = document.getElementById('categoryFilter');
                    if (cf) cf.value = state.category || '';
                    this.sortColumn = state.sortColumn || this.sortColumn;
                    this.sortDirection = state.sortDirection || this.sortDirection;
                    this.applyFilters();
                } catch {}
            },
            bindShortcuts() {
                document.addEventListener('keydown', (e) => {
                    const inEditable = ['INPUT','TEXTAREA','SELECT'].includes((e.target || {}).tagName);
                    const mod = e.ctrlKey || e.metaKey;
                    if (mod && e.key.toLowerCase() === 'k') {
                        e.preventDefault();
                        document.getElementById('searchInput')?.focus();
                        return;
                    }
                    if (!inEditable) {
                        if (e.key.toLowerCase() === 'n') { e.preventDefault(); this.showAddModal(); return; }
                        if (e.key === '/') { e.preventDefault(); this.toggleChat(); return; }
                        if (e.key === 'Escape') {
                            const modals = ['featureModal','linkPickerModal','rejectionReasonModal','aiActionModal'];
                            for (let id of modals) {
                                const el = document.getElementById(id);
                                if (!el) continue;
                                const visible = (id==='featureModal') ? el.classList.contains('active') : !el.classList.contains('hidden');
                                if (visible) {
                                    if (id==='featureModal') this.closeModal();
                                    if (id==='linkPickerModal') this.closeLinkPicker();
                                    if (id==='rejectionReasonModal') this.closeRejectionReason();
                                    if (id==='aiActionModal') this.closeAIActionApproval();
                                    break;
                                }
                            }
                        }
                    }
                });
            },

            ensureLiveRegion() {
                if (!document.getElementById('srLive')) {
                    const sr = document.createElement('div');
                    sr.id = 'srLive';
                    sr.setAttribute('aria-live', 'polite');
                    sr.setAttribute('role', 'status');
                    sr.style.position = 'absolute';
                    sr.style.width = '1px';
                    sr.style.height = '1px';
                    sr.style.overflow = 'hidden';
                    sr.style.clip = 'rect(1px, 1px, 1px, 1px)';
                    document.body.appendChild(sr);
                }
                const chat = document.getElementById('chatMessages');
                if (chat) { chat.setAttribute('aria-live','polite'); chat.setAttribute('role','log'); }
            },

            // Theme
            loadTheme() {
                const stored = localStorage.getItem('theme');
                const theme = stored === 'dark' ? 'dark' : 'light';
                document.body.setAttribute('data-theme', theme === 'dark' ? 'dark' : 'light');
            },
            toggleTheme() {
                const current = document.body.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
                const next = current === 'dark' ? 'light' : 'dark';
                document.body.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                this.showToast(next === 'dark' ? 'Dark mode on' : 'Light mode on', 'info');
            },

            toggleHeaderMenu(event) {
                if (event) event.stopPropagation();
                const dropdown = document.getElementById('headerMenuDropdown');
                if (dropdown) {
                    dropdown.classList.toggle('active');
                    if (dropdown.classList.contains('active')) {
                        // Close on outside click
                        setTimeout(() => {
                            document.addEventListener('click', this.closeHeaderMenu.bind(this), { once: true });
                        }, 0);
                    }
                }
            },

            closeHeaderMenu() {
                const dropdown = document.getElementById('headerMenuDropdown');
                if (dropdown) {
                    dropdown.classList.remove('active');
                }
            },

            async checkOriginChange() {
                const currentOrigin = window.location.href;
                const lastOrigin = localStorage.getItem('lastOrigin');

                console.log('Current location:', currentOrigin);

                if (lastOrigin && lastOrigin !== currentOrigin) {
                    console.warn('⚠️ Origin changed!', {
                        previous: lastOrigin,
                        current: currentOrigin
                    });

                    // Check if we have data
                    const hasData = this.features?.length > 0 || localStorage.getItem('roadmapFeatures');

                    if (!hasData) {
                        const ok = await this.showConfirm({
                            title: 'WARNING: File location changed!',
                            message: `Previous: ${lastOrigin}<br>Current: ${currentOrigin}<br><br>You may have lost your data because you're opening the file from a different location.<br><br>Each file path has separate storage. To recover your data:<br>1. Close this tab<br>2. Open the file from the original location<br>3. Click "Backup All" to export your data<br>4. Then you can open from any location and use "Import Backup"<br><br>Would you like to import a backup now?`,
                            confirmText: 'Import backup',
                            cancelText: 'Not now',
                            variant: 'warning'
                        });
                        if (ok) this.importAllData();
                    }
                }

                // Save current origin
                localStorage.setItem('lastOrigin', currentOrigin);
            },

            testLocalStorage() {
                try {
                    const test = '__localStorage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    console.error('localStorage not available:', e);
                    this.showAlert({ title: 'Storage disabled', message: 'Browser storage is disabled or unavailable. Your data will NOT be saved. Check private mode, browser settings, or storage quota.' , variant:'warning'});
                    return false;
                }
            },

            getAITools() {
                return [
                    {
                        type: "function",
                        function: {
                            name: "update_feature",
                            description: "Update an existing feature's basic information (name, type, or purpose). Use this when the user wants to modify feature details.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature to update"
                                    },
                                    updates: {
                                        type: "object",
                                        properties: {
                                            name: { type: "string", description: "New feature name" },
                                            type: { type: "string", description: "New feature type (Platform or User-Facing)" },
                                            purpose: { type: "string", description: "New feature purpose/description" }
                                        },
                                        description: "Object containing the fields to update"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this change is being made"
                                    }
                                },
                                required: ["featureId", "updates", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "update_timeline_item",
                            description: "Update a timeline item's metadata (difficulty, categories, integration type, or USP). Use this to refine timeline item details.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature containing the timeline item"
                                    },
                                    itemId: {
                                        type: "string",
                                        description: "The ID of the timeline item to update"
                                    },
                                    updates: {
                                        type: "object",
                                        properties: {
                                            difficulty: { type: "string", description: "New difficulty (Easy, Medium, or Hard)" },
                                            category: { type: "array", items: { type: "string" }, description: "New categories array" },
                                            integrationType: { type: "string", description: "New integration type" },
                                            usp: { type: "string", description: "New USP (unique selling proposition)" }
                                        },
                                        description: "Object containing the fields to update"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this change is being made"
                                    }
                                },
                                required: ["featureId", "itemId", "updates", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "create_feature",
                            description: "Create a new feature with timeline items. Use this when the user wants to add a completely new feature to the roadmap.",
                            parameters: {
                                type: "object",
                                properties: {
                                    name: {
                                        type: "string",
                                        description: "Feature name"
                                    },
                                    type: {
                                        type: "string",
                                        description: "Feature type (Platform or User-Facing)"
                                    },
                                    purpose: {
                                        type: "string",
                                        description: "Feature purpose/description"
                                    },
                                    timelineItems: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                timeline: { type: "string", description: "Timeline phase (MVP, SHORT, MID, LONG)" },
                                                difficulty: { type: "string", description: "Difficulty (Easy, Medium, Hard)" },
                                                category: { type: "array", items: { type: "string" }, description: "Categories" },
                                                integrationType: { type: "string", description: "Integration type" },
                                                usp: { type: "string", description: "Unique selling proposition" }
                                            }
                                        },
                                        description: "Array of timeline items for this feature"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this feature should be added"
                                    }
                                },
                                required: ["name", "type", "purpose", "timelineItems", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "create_link_suggestion",
                            description: "Suggest a new cross-feature link between timeline items. Use this when you identify a dependency or complementary relationship.",
                            parameters: {
                                type: "object",
                                properties: {
                                    sourceFeatureId: {
                                        type: "string",
                                        description: "ID of the source feature"
                                    },
                                    sourceItemId: {
                                        type: "string",
                                        description: "ID of the source timeline item"
                                    },
                                    targetFeatureId: {
                                        type: "string",
                                        description: "ID of the target feature"
                                    },
                                    targetItemId: {
                                        type: "string",
                                        description: "ID of the target timeline item"
                                    },
                                    relationshipType: {
                                        type: "string",
                                        enum: ["dependency", "complements"],
                                        description: "Type of relationship"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Explanation of why these items are linked"
                                    }
                                },
                                required: ["sourceFeatureId", "sourceItemId", "targetFeatureId", "targetItemId", "relationshipType", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "add_timeline_item",
                            description: "Add a new timeline item to an existing feature. Use this when a feature needs additional phases or milestones.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature to add the timeline item to"
                                    },
                                    timelineItem: {
                                        type: "object",
                                        properties: {
                                            timeline: { type: "string", description: "Timeline phase (MVP, SHORT, MID, LONG)" },
                                            difficulty: { type: "string", description: "Difficulty (Easy, Medium, Hard)" },
                                            category: { type: "array", items: { type: "string" }, description: "Categories" },
                                            integrationType: { type: "string", description: "Integration type" },
                                            usp: { type: "string", description: "Unique selling proposition" }
                                        },
                                        required: ["timeline", "difficulty"],
                                        description: "The timeline item to add"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this timeline item is being added"
                                    }
                                },
                                required: ["featureId", "timelineItem", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "delete_timeline_item",
                            description: "Remove a timeline item from a feature. Use this when a timeline phase is no longer needed. Be cautious with this action.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature containing the timeline item"
                                    },
                                    itemId: {
                                        type: "string",
                                        description: "The ID of the timeline item to delete"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this timeline item is being removed"
                                    }
                                },
                                required: ["featureId", "itemId", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "create_feature_with_research",
                            description: "Create a comprehensive feature with AI-powered research. Use this ONLY when the user explicitly wants to create a feature with AI assistance (like clicking 'AI Create'). This tool will automatically research and generate execution steps, resources, planning, and inspiration.",
                            parameters: {
                                type: "object",
                                properties: {
                                    name: {
                                        type: "string",
                                        description: "Feature name"
                                    },
                                    type: {
                                        type: "string",
                                        description: "Feature type (Feature or Service)"
                                    },
                                    purpose: {
                                        type: "string",
                                        description: "Detailed feature purpose/description"
                                    },
                                    timelineItems: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                timeline: { type: "string", description: "Timeline phase (MVP, SHORT, MID, LONG)" },
                                                difficulty: { type: "string", description: "Difficulty (Easy, Medium, Hard)" },
                                                category: { type: "array", items: { type: "string" }, description: "Categories" },
                                                integrationType: { type: "string", description: "Integration type" },
                                                usp: { type: "string", description: "Unique selling proposition" }
                                            }
                                        },
                                        description: "Timeline items (can be minimal, will be enhanced by research)"
                                    }
                                },
                                required: ["name", "purpose"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "enhance_feature_with_research",
                            description: "Enhance an existing feature with AI-powered research. Use this ONLY when the user explicitly wants to enhance/enrich a feature they're viewing (like clicking 'AI Enhance'). This tool will analyze the existing feature, research it, and automatically populate or update execution steps, resources, planning, and inspiration.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature to enhance"
                                    },
                                    name: {
                                        type: "string",
                                        description: "Feature name (may be same as existing or updated)"
                                    },
                                    type: {
                                        type: "string",
                                        description: "Feature type (Feature or Service)"
                                    },
                                    purpose: {
                                        type: "string",
                                        description: "Detailed feature purpose/description"
                                    },
                                    additionalInfo: {
                                        type: "string",
                                        description: "Any additional information or answers to clarifying questions that should be considered"
                                    }
                                },
                                required: ["featureId"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "search_internet",
                            description: "Search the internet for current information, news, documentation, or any topic. Use this when you need up-to-date information that you don't have in your training data or when the user asks about current events, recent technologies, or real-time data.",
                            parameters: {
                                type: "object",
                                properties: {
                                    query: {
                                        type: "string",
                                        description: "The search query to find relevant information"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this search is needed"
                                    }
                                },
                                required: ["query", "reason"]
                            }
                        }
                    }
                ];
            },

            async loadData() {
                try {
                    let loadedFromCloud = false;

                    // Try loading from Supabase first if connected
                    if (supabaseService.isConnected) {
                        console.log('🔄 Loading data from Supabase...');
                        const cloudFeatures = await supabaseService.loadFeatures();

                        if (cloudFeatures !== null) {
                            this.features = cloudFeatures;
                            this.features.forEach(f => {
                                if (f.tags) f.tags.forEach(t => this.allTags.add(t));
                            });
                            console.log(`✅ Loaded ${this.features.length} features from Supabase`);
                            loadedFromCloud = true;

                            // Also save to localStorage as offline cache
                            this.saveToLocalStorage();

                            // Check if we need to show migration prompt
                            this.checkMigrationNeeded();
                        }
                    }

                    // Fallback to localStorage if Supabase not available or no data
                    if (!loadedFromCloud) {
                        console.log('📦 Loading data from localStorage...');
                        const stored = localStorage.getItem('roadmapFeatures');
                        if (stored) {
                            this.features = JSON.parse(stored);
                            this.features.forEach(f => {
                                if (f.tags) f.tags.forEach(t => this.allTags.add(t));
                            });
                            console.log(`✅ Loaded ${this.features.length} features from localStorage`);

                            // Check if we should migrate to cloud
                            this.checkMigrationNeeded();
                        } else {
                            console.log('ℹ️ No saved features found - starting fresh');
                        }
                    }
                } catch (error) {
                    console.error('❌ Error loading features:', error);
                    this.showAlert({ title:'Load error', message:'Error loading your saved features. Data may be corrupted.', variant:'danger' });
                    this.features = [];
                }
            },

            async saveData() {
                // Save to localStorage first (for offline cache)
                const localSaved = this.saveToLocalStorage();

                // Also sync to Supabase if connected
                if (supabaseService.isConnected) {
                    this.updateSyncStatus('syncing');
                    const cloudSaved = await supabaseService.syncFeatures(this.features);
                    if (cloudSaved) {
                        this.updateSyncStatus('synced');
                        console.log('✅ Data synced to cloud');
                    } else {
                        this.updateSyncStatus('error');
                        console.warn('⚠️ Cloud sync failed, data saved locally only');
                    }
                } else {
                    this.updateSyncStatus('offline');
                }

                return localSaved;
            },

            // Separate method for localStorage-only saves
            saveToLocalStorage() {
                try {
                    const dataToSave = JSON.stringify(this.features);
                    localStorage.setItem('roadmapFeatures', dataToSave);
                    console.log(`✅ Saved ${this.features.length} features to localStorage (${dataToSave.length} bytes)`);
                    return true;
                } catch (error) {
                    console.error('❌ Error saving to localStorage:', error);
                    if (error.name === 'QuotaExceededError') {
                        this.showAlert({ title:'Storage quota exceeded', message:'Your browser has run out of storage space. Try deleting some features, clearing browser data, or exporting your data as CSV backup.', variant:'warning' });
                    } else {
                        this.showAlert({ title:'Save error', message:'Error saving your data. Check browser console for details.', variant:'danger' });
                    }
                    return false;
                }
            },

            // Update sync status indicator
            updateSyncStatus(status = null) {
                const statusEl = document.getElementById('syncStatus');
                if (!statusEl) return;

                if (status === null) {
                    // Auto-detect status
                    if (!supabaseService.isConnected) {
                        status = 'offline';
                    } else {
                        status = 'synced';
                    }
                }

                const statuses = {
                    'synced': { text: '✓ Synced', class: 'sync-status-success', title: 'Data is synced to cloud' },
                    'syncing': { text: '⟳ Syncing...', class: 'sync-status-syncing', title: 'Syncing data to cloud' },
                    'offline': { text: '📦 Offline', class: 'sync-status-offline', title: 'Working offline - data saved locally' },
                    'error': { text: '⚠ Sync Error', class: 'sync-status-error', title: 'Failed to sync to cloud' }
                };

                const statusInfo = statuses[status] || statuses['offline'];
                statusEl.textContent = statusInfo.text;
                statusEl.className = 'sync-status ' + statusInfo.class;
                statusEl.title = statusInfo.title;
            },

            // Check if migration from localStorage to cloud is needed
            checkMigrationNeeded() {
                // Don't show migration if already migrated
                if (localStorage.getItem('migrationCompleted') === 'true') {
                    return;
                }

                // Check if we have localStorage data but no cloud data
                const localData = localStorage.getItem('roadmapFeatures');
                if (localData && supabaseService.isConnected) {
                    const localFeatures = JSON.parse(localData);
                    // If we have local data and Supabase is connected but returned empty, offer migration
                    if (localFeatures.length > 0 && this.features.length === 0) {
                        this.showMigrationModal(localFeatures);
                    } else if (localFeatures.length > 0 && this.features.length > 0) {
                        // Data already synced, mark as migrated
                        localStorage.setItem('migrationCompleted', 'true');
                    }
                }
            },

            // Show migration modal
            showMigrationModal(localFeatures) {
                const modal = document.getElementById('migrationModal');
                const overlay = document.getElementById('migrationOverlay');
                const count = document.getElementById('migrationCount');

                if (!modal || !overlay) {
                    // Modal elements don't exist yet, will be created later
                    return;
                }

                count.textContent = localFeatures.length;
                modal.classList.remove('hidden');
                overlay.classList.remove('hidden');
            },

            // Migrate data to cloud
            async migrateToCloud() {
                const localData = localStorage.getItem('roadmapFeatures');
                if (!localData) {
                    this.closeMigrationModal();
                    return;
                }

                try {
                    const localFeatures = JSON.parse(localData);
                    console.log(`🔄 Migrating ${localFeatures.length} features to cloud...`);

                    // Show progress
                    const modal = document.getElementById('migrationModal');
                    const content = modal.querySelector('.migration-content');
                    content.innerHTML = '<p>⟳ Migrating your data to cloud...</p><p>Please wait...</p>';

                    // Sync to Supabase
                    const success = await supabaseService.syncFeatures(localFeatures);

                    if (success) {
                        this.features = localFeatures;
                        localStorage.setItem('migrationCompleted', 'true');
                        content.innerHTML = '<p>✅ Migration completed successfully!</p><p>Your data is now synced across all browsers and devices.</p>';
                        setTimeout(() => {
                            this.closeMigrationModal();
                            this.renderTable();
                            this.updateSyncStatus('synced');
                        }, 2000);
                    } else {
                        content.innerHTML = '<p>❌ Migration failed. Please try again later.</p><button class="btn-primary" onclick="app.closeMigrationModal()">Close</button>';
                    }
                } catch (error) {
                    console.error('❌ Migration error:', error);
                    this.showAlert({ title:'Migration failed', message:'Failed to migrate data to cloud. Your data is still safe locally.', variant:'danger' });
                    this.closeMigrationModal();
                }
            },

            // Skip migration
            skipMigration() {
                localStorage.setItem('migrationCompleted', 'true');
                this.closeMigrationModal();
            },

            // Close migration modal
            closeMigrationModal() {
                const modal = document.getElementById('migrationModal');
                const overlay = document.getElementById('migrationOverlay');
                if (modal) modal.classList.add('hidden');
                if (overlay) overlay.classList.add('hidden');
            },

            // ========== WORKSPACE MANAGEMENT ==========

            // Load workspaces from Supabase or localStorage
            async loadWorkspaces() {
                try {
                    // Try loading from Supabase first
                    if (supabaseService.isConnected) {
                        const cloudWorkspaces = await supabaseService.loadWorkspaces();
                        if (cloudWorkspaces !== null) {
                            // Convert database format to app format
                            this.workspaces = cloudWorkspaces.map(w => ({
                                id: w.id,
                                name: w.name,
                                description: w.description || '',
                                color: w.color || '#3b82f6',
                                icon: w.icon || '📊',
                                customInstructions: w.custom_instructions || '',
                                aiMemory: w.ai_memory || [],
                                createdAt: w.created_at,
                                updatedAt: w.updated_at
                            }));
                            console.log(`✅ Loaded ${this.workspaces.length} workspaces`);

                            // Save to localStorage as cache
                            localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));
                            return;
                        }
                    }

                    // Fallback to localStorage
                    const stored = localStorage.getItem('roadmapWorkspaces');
                    if (stored) {
                        this.workspaces = JSON.parse(stored);
                        console.log(`✅ Loaded ${this.workspaces.length} workspaces from localStorage`);
                    } else {
                        this.workspaces = [];
                    }
                } catch (error) {
                    console.error('❌ Error loading workspaces:', error);
                    this.workspaces = [];
                }
            },

            // Get current workspace object
            getCurrentWorkspace() {
                return this.workspaces.find(w => w.id === this.currentWorkspaceId) || null;
            },

            // Create a new workspace
            async createWorkspace(name, description, color, icon) {
                const workspace = {
                    id: Date.now().toString(),
                    name: name,
                    description: description || '',
                    color: color || '#3b82f6',
                    icon: icon || '📊',
                    customInstructions: '',
                    aiMemory: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                this.workspaces.push(workspace);

                // Save to localStorage
                localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));

                // Save to Supabase
                if (supabaseService.isConnected) {
                    await supabaseService.createWorkspace(workspace);
                }

                console.log('✅ Created workspace:', workspace.name);
                return workspace;
            },

            // Update a workspace
            async updateWorkspace(workspaceId, updates) {
                const workspace = this.workspaces.find(w => w.id === workspaceId);
                if (!workspace) {
                    console.error('❌ Workspace not found:', workspaceId);
                    return false;
                }

                // Update properties
                if (updates.name !== undefined) workspace.name = updates.name;
                if (updates.description !== undefined) workspace.description = updates.description;
                if (updates.color !== undefined) workspace.color = updates.color;
                if (updates.icon !== undefined) workspace.icon = updates.icon;
                if (updates.customInstructions !== undefined) workspace.customInstructions = updates.customInstructions;
                if (updates.aiMemory !== undefined) workspace.aiMemory = updates.aiMemory;
                workspace.updatedAt = new Date().toISOString();

                // Save to localStorage
                localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));

                // Save to Supabase
                if (supabaseService.isConnected) {
                    await supabaseService.updateWorkspace(workspaceId, workspace);
                }

                console.log('✅ Updated workspace:', workspace.name);

                // Update UI if this is the current workspace
                if (workspaceId === this.currentWorkspaceId) {
                    this.renderWorkspaceSelector();
                }

                return true;
            },

            // Delete a workspace
            async deleteWorkspace(workspaceId) {
                const workspace = this.workspaces.find(w => w.id === workspaceId);
                if (!workspace) {
                    console.error('❌ Workspace not found:', workspaceId);
                    return false;
                }

                // Count features in this workspace
                const featureCount = this.features.filter(f => f.workspaceId === workspaceId).length;

                // Confirm deletion
                const confirmed = confirm(`Delete workspace "${workspace.name}"?\n\nThis will permanently delete ${featureCount} feature(s) in this workspace.\n\nThis action cannot be undone.`);
                if (!confirmed) return false;

                // Delete from Supabase first
                if (supabaseService.isConnected) {
                    await supabaseService.deleteWorkspace(workspaceId);
                }

                // Remove from local array
                this.workspaces = this.workspaces.filter(w => w.id !== workspaceId);

                // Remove all features in this workspace
                this.features = this.features.filter(f => f.workspaceId !== workspaceId);

                // Save to localStorage
                localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));
                this.saveToLocalStorage();

                console.log('✅ Deleted workspace:', workspace.name);

                // Switch to another workspace or show welcome screen
                if (workspaceId === this.currentWorkspaceId) {
                    if (this.workspaces.length > 0) {
                        await this.switchWorkspace(this.workspaces[0].id);
                    } else {
                        this.currentWorkspaceId = null;
                        this.showWorkspaceWelcome();
                    }
                }

                return true;
            },

            // Switch to a different workspace
            async switchWorkspace(workspaceId) {
                const workspace = this.workspaces.find(w => w.id === workspaceId);
                if (!workspace) {
                    console.error('❌ Workspace not found:', workspaceId);
                    return;
                }

                console.log('🔄 Switching to workspace:', workspace.name);

                // Save current workspace ID
                this.currentWorkspaceId = workspaceId;
                localStorage.setItem('currentWorkspaceId', workspaceId);

                // Load features for this workspace
                if (supabaseService.isConnected) {
                    const workspaceFeatures = await supabaseService.loadWorkspaceFeatures(workspaceId);
                    if (workspaceFeatures !== null) {
                        this.features = workspaceFeatures;
                    } else {
                        // Filter from cached features
                        this.features = this.features.filter(f => f.workspaceId === workspaceId);
                    }
                } else {
                    // Filter from localStorage
                    this.features = this.features.filter(f => f.workspaceId === workspaceId);
                }

                // Load workspace-specific AI settings
                this.customInstructions = workspace.customInstructions || '';
                this.memory = workspace.aiMemory || [];

                // Clear AI conversation when switching workspaces
                this.conversationHistory = [];
                this.messageCount = 0;
                this.lastAnalysisCount = 0;

                // Update UI
                this.renderTable();
                this.renderWorkspaceSelector();
                this.updateCounters();

                // Clear any selection
                this.selectedFeatureIds.clear();

                // Return to table view if in detail view
                if (this.currentView === 'detail') {
                    this.currentView = 'table';
                    window.location.hash = '';
                }

                console.log(`✅ Switched to workspace: ${workspace.name} (${this.features.length} features)`);
            },

            // Render workspace selector in header
            renderWorkspaceSelector() {
                const container = document.getElementById('workspaceSelector');
                if (!container) return;

                const currentWorkspace = this.getCurrentWorkspace();
                if (!currentWorkspace) {
                    container.innerHTML = '<button class="btn-workspace" onclick="app.showWorkspaceModal()">+ Create Workspace</button>';
                    return;
                }

                // Create dropdown button with current workspace
                container.innerHTML = `
                    <div class="workspace-dropdown">
                        <button class="btn-workspace" onclick="app.toggleWorkspaceDropdown()" id="workspaceDropdownBtn">
                            <span class="workspace-icon" style="color: ${currentWorkspace.color}">${currentWorkspace.icon}</span>
                            <span class="workspace-name">${this.escapeHtml(currentWorkspace.name)}</span>
                            <span class="workspace-arrow">▼</span>
                        </button>
                        <div class="workspace-dropdown-menu hidden" id="workspaceDropdownMenu">
                            ${this.workspaces.map(w => `
                                <button class="workspace-item ${w.id === this.currentWorkspaceId ? 'active' : ''}"
                                        onclick="app.selectWorkspaceFromDropdown('${w.id}')">
                                    <span class="workspace-icon" style="color: ${w.color}">${w.icon}</span>
                                    <span class="workspace-name">${this.escapeHtml(w.name)}</span>
                                    ${w.id === this.currentWorkspaceId ? '<span class="workspace-check">✓</span>' : ''}
                                </button>
                            `).join('')}
                            <div class="workspace-divider"></div>
                            <button class="workspace-item" onclick="app.showWorkspaceModal()">
                                <span class="workspace-icon">➕</span>
                                <span class="workspace-name">New Workspace</span>
                            </button>
                            <button class="workspace-item" onclick="app.showWorkspaceManageModal()">
                                <span class="workspace-icon">⚙️</span>
                                <span class="workspace-name">Manage Workspaces</span>
                            </button>
                        </div>
                    </div>
                `;
            },

            // Toggle workspace dropdown
            toggleWorkspaceDropdown() {
                const menu = document.getElementById('workspaceDropdownMenu');
                if (!menu) return;

                menu.classList.toggle('hidden');

                // Close dropdown when clicking outside
                if (!menu.classList.contains('hidden')) {
                    setTimeout(() => {
                        const closeDropdown = (e) => {
                            if (!e.target.closest('.workspace-dropdown')) {
                                menu.classList.add('hidden');
                                document.removeEventListener('click', closeDropdown);
                            }
                        };
                        document.addEventListener('click', closeDropdown);
                    }, 0);
                }
            },

            // Select workspace from dropdown
            async selectWorkspaceFromDropdown(workspaceId) {
                const menu = document.getElementById('workspaceDropdownMenu');
                if (menu) menu.classList.add('hidden');

                if (workspaceId !== this.currentWorkspaceId) {
                    await this.switchWorkspace(workspaceId);
                }
            },

            // Show workspace welcome screen (no workspaces exist)
            showWorkspaceWelcome() {
                const container = document.getElementById('tableContainer');
                if (!container) return;

                container.innerHTML = `
                    <div class="workspace-welcome">
                        <div class="workspace-welcome-icon">📊</div>
                        <h2>Welcome to Your Roadmap Manager</h2>
                        <p>Create your first workspace to start organizing your roadmaps and features.</p>
                        <p class="workspace-welcome-subtitle">Workspaces help you manage multiple projects independently.</p>
                        <button class="btn-primary btn-lg" onclick="app.showWorkspaceModal()">
                            ➕ Create Your First Workspace
                        </button>
                    </div>
                `;
            },

            // Show workspace creation/edit modal
            showWorkspaceModal(workspaceId = null) {
                const isEdit = workspaceId !== null;
                const workspace = isEdit ? this.workspaces.find(w => w.id === workspaceId) : null;

                const modal = document.createElement('div');
                modal.id = 'workspaceModalOverlay';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content workspace-modal">
                        <div class="modal-header">
                            <h3>${isEdit ? 'Edit Workspace' : 'Create New Workspace'}</h3>
                            <button class="modal-close" onclick="app.closeWorkspaceModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="workspaceName">Workspace Name *</label>
                                <input type="text" id="workspaceName" class="form-control"
                                       placeholder="e.g., Product Roadmap 2024"
                                       value="${isEdit ? this.escapeHtml(workspace.name) : ''}" required>
                            </div>
                            <div class="form-group">
                                <label for="workspaceDescription">Description</label>
                                <textarea id="workspaceDescription" class="form-control" rows="3"
                                          placeholder="Optional description for this workspace">${isEdit ? this.escapeHtml(workspace.description) : ''}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="workspaceColor">Color</label>
                                <div class="color-picker">
                                    <input type="color" id="workspaceColor" value="${isEdit ? workspace.color : '#3b82f6'}">
                                    <span class="color-preview" id="colorPreview"></span>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="workspaceIcon">Icon (Emoji)</label>
                                <input type="text" id="workspaceIcon" class="form-control"
                                       placeholder="📊" maxlength="2"
                                       value="${isEdit ? workspace.icon : '📊'}">
                                <small class="form-hint">Choose an emoji to represent this workspace</small>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" onclick="app.closeWorkspaceModal()">Cancel</button>
                            <button class="btn-primary" onclick="app.saveWorkspaceFromModal(${isEdit ? `'${workspaceId}'` : 'null'})">
                                ${isEdit ? 'Save Changes' : 'Create Workspace'}
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
                document.getElementById('workspaceName').focus();
            },

            // Save workspace from modal
            async saveWorkspaceFromModal(workspaceId) {
                const name = document.getElementById('workspaceName').value.trim();
                const description = document.getElementById('workspaceDescription').value.trim();
                const color = document.getElementById('workspaceColor').value;
                const icon = document.getElementById('workspaceIcon').value.trim() || '📊';

                if (!name) {
                    this.showAlert({ title: 'Validation Error', message: 'Workspace name is required', variant: 'warning' });
                    return;
                }

                if (workspaceId) {
                    // Update existing workspace
                    await this.updateWorkspace(workspaceId, { name, description, color, icon });
                    this.showAlert({ title: 'Success', message: 'Workspace updated successfully', variant: 'success' });
                } else {
                    // Create new workspace
                    const workspace = await this.createWorkspace(name, description, color, icon);

                    // Switch to the new workspace
                    await this.switchWorkspace(workspace.id);

                    this.showAlert({ title: 'Success', message: 'Workspace created successfully', variant: 'success' });
                }

                this.closeWorkspaceModal();
            },

            // Close workspace modal
            closeWorkspaceModal() {
                const modal = document.getElementById('workspaceModalOverlay');
                if (modal) modal.remove();
            },

            // Show workspace management modal
            showWorkspaceManageModal() {
                // Close dropdown first
                const dropdown = document.getElementById('workspaceDropdownMenu');
                if (dropdown) dropdown.classList.add('hidden');

                const modal = document.createElement('div');
                modal.id = 'workspaceManageOverlay';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content workspace-manage-modal">
                        <div class="modal-header">
                            <h3>Manage Workspaces</h3>
                            <button class="modal-close" onclick="app.closeWorkspaceManageModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="workspace-list">
                                ${this.workspaces.map(w => {
                                    const featureCount = this.features.filter(f => f.workspaceId === w.id).length;
                                    return `
                                        <div class="workspace-list-item ${w.id === this.currentWorkspaceId ? 'active' : ''}">
                                            <div class="workspace-info">
                                                <span class="workspace-icon-lg" style="color: ${w.color}">${w.icon}</span>
                                                <div class="workspace-details">
                                                    <div class="workspace-title">${this.escapeHtml(w.name)}</div>
                                                    <div class="workspace-meta">
                                                        ${w.description ? `<div>${this.escapeHtml(w.description)}</div>` : ''}
                                                        <div class="workspace-stats">${featureCount} feature${featureCount !== 1 ? 's' : ''}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="workspace-actions">
                                                ${w.id === this.currentWorkspaceId ? '<span class="workspace-badge-current">Current</span>' : `<button class="btn-sm btn-secondary" onclick="app.selectWorkspaceFromManage('${w.id}')">Switch</button>`}
                                                <button class="btn-sm btn-secondary" onclick="app.editWorkspaceFromManage('${w.id}')">Edit</button>
                                                <button class="btn-sm btn-danger" onclick="app.deleteWorkspaceFromManage('${w.id}')">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-primary" onclick="app.showWorkspaceModalFromManage()">+ New Workspace</button>
                            <button class="btn-secondary" onclick="app.closeWorkspaceManageModal()">Close</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            },

            // Select workspace from manage modal
            async selectWorkspaceFromManage(workspaceId) {
                await this.switchWorkspace(workspaceId);
                this.closeWorkspaceManageModal();
            },

            // Edit workspace from manage modal
            editWorkspaceFromManage(workspaceId) {
                this.closeWorkspaceManageModal();
                this.showWorkspaceModal(workspaceId);
            },

            // Delete workspace from manage modal
            async deleteWorkspaceFromManage(workspaceId) {
                const deleted = await this.deleteWorkspace(workspaceId);
                if (deleted) {
                    this.closeWorkspaceManageModal();
                    // Reopen if there are still workspaces
                    if (this.workspaces.length > 0) {
                        setTimeout(() => this.showWorkspaceManageModal(), 300);
                    }
                }
            },

            // Show workspace modal from manage modal
            showWorkspaceModalFromManage() {
                this.closeWorkspaceManageModal();
                this.showWorkspaceModal();
            },

            // Close workspace manage modal
            closeWorkspaceManageModal() {
                const modal = document.getElementById('workspaceManageOverlay');
                if (modal) modal.remove();
            },

            // ========== END WORKSPACE MANAGEMENT ==========

            loadApiKey() {
                const stored = localStorage.getItem('openrouterApiKey');
                if (stored) {
                    this.apiKey = stored;
                    document.getElementById('apiKeyInput').value = stored;
                    // Hide input, show status
                    document.getElementById('apiKeyInputSection').classList.add('hidden');
                    const headerStatus = document.getElementById('chatHeaderApiStatus');
                    if (headerStatus) headerStatus.classList.remove('hidden');
                } else {
                    // No API key stored, show input section
                    document.getElementById('apiKeyInputSection').classList.remove('hidden');
                    const headerStatus = document.getElementById('chatHeaderApiStatus');
                    if (headerStatus) headerStatus.classList.add('hidden');
                }
            },

            saveApiKey(key) {
                this.apiKey = key;
                localStorage.setItem('openrouterApiKey', key);
                // Hide input, show status
                if (key) {
                    document.getElementById('apiKeyInputSection').classList.add('hidden');
                    const headerStatus = document.getElementById('chatHeaderApiStatus');
                    if (headerStatus) headerStatus.classList.remove('hidden');
                }
            },

            loadTavilyApiKey() {
                const stored = localStorage.getItem('tavilyApiKey');
                if (stored) {
                    this.tavilyApiKey = stored;
                    const input = document.getElementById('tavilyApiKeyInput');
                    if (input) input.value = stored;
                }
            },

            saveTavilyApiKey(key) {
                this.tavilyApiKey = key;
                localStorage.setItem('tavilyApiKey', key);
            },

            toggleApiKeyInput() {
                const inputSection = document.getElementById('apiKeyInputSection');
                const headerStatus = document.getElementById('chatHeaderApiStatus');

                if (inputSection.classList.contains('hidden')) {
                    // Expanding settings
                    inputSection.classList.remove('hidden');
                    if (headerStatus) headerStatus.classList.add('hidden');
                } else {
                    // Minimizing settings - only if API key is set
                    if (this.apiKey) {
                        inputSection.classList.add('hidden');
                        if (headerStatus) headerStatus.classList.remove('hidden');
                    } else {
                        this.showAlert({ title: 'API key required', message: 'Please enter your API key first!' });
                    }
                }
            },

            autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
            },

            loadModel() {
                const stored = localStorage.getItem('selectedModel');
                if (stored) {
                    this.selectedModel = stored;
                    const modelSelect = document.getElementById('modelSelect');
                    if (modelSelect) modelSelect.value = stored;
                }
            },

            saveModel(model) {
                this.selectedModel = model;
                localStorage.setItem('selectedModel', model);
                const modelSelect = document.getElementById('modelSelect');
                if (modelSelect) modelSelect.value = model;
            },

            loadCustomInstructions() {
                const stored = localStorage.getItem('customInstructions');
                if (stored) {
                    this.customInstructions = stored;
                    const textarea = document.getElementById('customInstructionsInput');
                    if (textarea) {
                        textarea.value = stored;
                    }
                }
            },

            saveCustomInstructions(instructions) {
                this.customInstructions = instructions;
                localStorage.setItem('customInstructions', instructions);
            },

            loadMemory() {
                try {
                    const stored = localStorage.getItem('aiMemory');
                    if (stored) {
                        this.memory = JSON.parse(stored);
                        console.log(`✅ Loaded ${this.memory.length} memory items`);
                    }
                } catch (error) {
                    console.error('❌ Error loading memory:', error);
                    this.memory = [];
                }
            },

            saveMemory() {
                try {
                    localStorage.setItem('aiMemory', JSON.stringify(this.memory));
                    console.log(`✅ Saved ${this.memory.length} memory items`);
                } catch (error) {
                    console.error('❌ Error saving memory:', error);
                }
            },

            addToMemory(item) {
                this.memory.push({
                    content: item,
                    timestamp: new Date().toISOString()
                });
                this.saveMemory();
                this.renderMemoryList();
                this.updateCounters();
            },

            addMemoryFromInput() {
                const input = document.getElementById('addMemoryInput');
                const text = input?.value.trim();
                if (text) {
                    this.addToMemory(text);
                    input.value = '';
                }
            },

            removeFromMemory(index) {
                this.memory.splice(index, 1);
                this.saveMemory();
                this.renderMemoryList();
                this.updateCounters();
            },

            renderMemoryList() {
                const container = document.getElementById('memoryList');
                if (!container) return;

                if (this.memory.length === 0) {
                    container.innerHTML = '<div style="color:var(--text-muted); font-size:12px; padding:10px;">No memory items yet. The AI will suggest adding important information here.</div>';
                    return;
                }

                container.innerHTML = this.memory.map((item, index) => `
                    <div style="background:var(--surface-alt); padding:10px; border-radius:6px; margin-bottom:8px; font-size:12px;">
                        <div style="display:flex; justify-content:space-between; align-items:start;">
                            <div style="flex:1; color:var(--text-secondary);">${item.content}</div>
                            <button onclick="app.removeFromMemory(${index})" style="background:none; border:none; color:var(--danger); cursor:pointer; font-size:16px; padding:0 0 0 8px;">&times;</button>
                        </div>
                        <div style="color:var(--text-muted); font-size:10px; margin-top:4px;">${new Date(item.timestamp).toLocaleString()}</div>
                    </div>
                `).join('');
            },

            toggleMemoryPanel() {
                const panel = document.getElementById('memoryPanel');
                if (panel) {
                    panel.classList.toggle('hidden');
                    if (!panel.classList.contains('hidden')) {
                        this.renderMemoryList();
                    }
                }
            },

            async clearMemory() {
                const ok = await this.showConfirm({ title:'Clear all memory?', message:'This cannot be undone.', confirmText:'Clear', cancelText:'Cancel', variant:'danger' });
                if (!ok) return;
                this.memory = [];
                this.saveMemory();
                this.renderMemoryList();
                this.updateCounters();
            },

            async compactConversation() {
                const ok = await this.showConfirm({ title:'Start a new conversation?', message:'Current chat will be cleared but memory will be preserved.', confirmText:'Start new', cancelText:'Cancel' });
                if (!ok) return;
                this.conversationHistory = [];
                this.messageCount = 0;
                this.lastAnalysisCount = 0;
                document.getElementById('contextWarning')?.classList.add('hidden');
                const messagesContainer = document.getElementById('chatMessages');
                messagesContainer.innerHTML = `
                    <div class="chat-message ai">
                        👋 New conversation started! Your memory and custom instructions are preserved.
                    </div>
                `;
            },

            loadMemorySuggestions() {
                try {
                    const stored = localStorage.getItem('memorySuggestions');
                    if (stored) {
                        this.memorySuggestions = JSON.parse(stored);
                        console.log(`✅ Loaded ${this.memorySuggestions.length} memory suggestions`);
                    }
                } catch (error) {
                    console.error('❌ Error loading memory suggestions:', error);
                    this.memorySuggestions = [];
                }
            },

            saveMemorySuggestions() {
                try {
                    localStorage.setItem('memorySuggestions', JSON.stringify(this.memorySuggestions));
                    console.log(`✅ Saved ${this.memorySuggestions.length} memory suggestions`);
                } catch (error) {
                    console.error('❌ Error saving memory suggestions:', error);
                }
            },

            loadLinkSuggestions() {
                try {
                    const stored = localStorage.getItem('linkSuggestions');
                    if (stored) {
                        this.linkSuggestions = JSON.parse(stored);

                        // Clean up any same-feature suggestions that might have been stored
                        const originalCount = this.linkSuggestions.length;
                        this.linkSuggestions = this.linkSuggestions.filter(suggestion => {
                            return suggestion.sourceFeatureId !== suggestion.targetFeatureId;
                        });

                        if (this.linkSuggestions.length < originalCount) {
                            console.log(`🧹 Cleaned up ${originalCount - this.linkSuggestions.length} invalid same-feature suggestions`);
                            this.saveLinkSuggestions();
                        }

                        console.log(`✅ Loaded ${this.linkSuggestions.length} link suggestions`);
                    }
                } catch (error) {
                    console.error('❌ Error loading link suggestions:', error);
                    this.linkSuggestions = [];
                }
            },

            saveLinkSuggestions() {
                try {
                    localStorage.setItem('linkSuggestions', JSON.stringify(this.linkSuggestions));
                    console.log(`✅ Saved ${this.linkSuggestions.length} link suggestions`);
                } catch (error) {
                    console.error('❌ Error saving link suggestions:', error);
                }
            },

            loadRejectedLinks() {
                try {
                    const stored = localStorage.getItem('rejectedLinks');
                    if (stored) {
                        this.rejectedLinks = JSON.parse(stored);
                        console.log(`✅ Loaded ${this.rejectedLinks.length} rejected links`);
                    }
                } catch (error) {
                    console.error('❌ Error loading rejected links:', error);
                    this.rejectedLinks = [];
                }
            },

            saveRejectedLinks() {
                try {
                    localStorage.setItem('rejectedLinks', JSON.stringify(this.rejectedLinks));
                    console.log(`✅ Saved ${this.rejectedLinks.length} rejected links`);
                } catch (error) {
                    console.error('❌ Error saving rejected links:', error);
                }
            },

            addMemorySuggestion(content) {
                const suggestion = {
                    id: Date.now().toString(),
                    content: content,
                    timestamp: new Date().toISOString()
                };
                this.memorySuggestions.push(suggestion);
                this.saveMemorySuggestions();
                this.updateSuggestionNotification();
            },

            approveSuggestion(id) {
                const suggestion = this.memorySuggestions.find(s => s.id === id);
                if (suggestion) {
                    this.addToMemory(suggestion.content);
                    this.memorySuggestions = this.memorySuggestions.filter(s => s.id !== id);
                    this.saveMemorySuggestions();
                    this.renderMemorySuggestions();
                    this.updateSuggestionNotification();
                }
            },

            rejectSuggestion(id) {
                this.memorySuggestions = this.memorySuggestions.filter(s => s.id !== id);
                this.saveMemorySuggestions();
                this.renderMemorySuggestions();
                this.updateSuggestionNotification();
            },

            approveAllSuggestions() {
                this.memorySuggestions.forEach(suggestion => {
                    this.addToMemory(suggestion.content);
                });
                this.memorySuggestions = [];
                this.saveMemorySuggestions();
                this.renderMemorySuggestions();
                this.updateSuggestionNotification();
            },

            async rejectAllSuggestions() {
                const ok = await this.showConfirm({ title:'Reject all suggestions?', message:'This cannot be undone.', confirmText:'Reject all', cancelText:'Cancel', variant:'danger' });
                if (!ok) return;
                this.memorySuggestions = [];
                this.saveMemorySuggestions();
                this.renderMemorySuggestions();
                this.updateSuggestionNotification();
            },

            toggleMemorySuggestions() {
                const list = document.getElementById('memorySuggestionsList');
                if (list) {
                    const isExpanded = list.classList.contains('active');
                    if (!isExpanded) {
                        this.renderMemorySuggestions();
                    }
                    list.classList.toggle('active');
                }
            },

            toggleLinkSuggestions() {
                const list = document.getElementById('linkSuggestionsList');
                if (list) {
                    const isExpanded = list.classList.contains('active');
                    if (!isExpanded) {
                        this.renderLinkSuggestions();
                    }
                    list.classList.toggle('active');
                }
            },

            toggleLinkDetails(suggestionId) {
                const details = document.getElementById(`details-${suggestionId}`);
                const toggle = document.getElementById(`toggle-${suggestionId}`);
                if (details && toggle) {
                    const isVisible = details.style.display !== 'none';
                    details.style.display = isVisible ? 'none' : 'block';
                    toggle.textContent = isVisible ? '▼ Show Details' : '▲ Hide Details';
                }
            },

            // Manual Link Management Functions
            currentLinkSourceItemId: null,
            currentRejectionId: null,

            showAddLinkModal(itemId) {
                this.currentLinkSourceItemId = itemId;

                // Find the current feature (to exclude it from target options)
                const currentFeature = this.editingId ? this.features.find(f => f.id === this.editingId) : null;

                // Populate feature dropdown (exclude current feature)
                const featureSelect = document.getElementById('linkTargetFeature');
                featureSelect.innerHTML = '<option value="">Select feature...</option>';

                this.features.forEach(feature => {
                    if (currentFeature && feature.id === currentFeature.id) return; // Skip same feature
                    featureSelect.innerHTML += `<option value="${feature.id}">${feature.name}</option>`;
                });

                // Clear other fields
                document.getElementById('linkTargetItem').innerHTML = '<option value="">Select timeline item...</option>';
                document.getElementById('linkReason').value = '';
                document.querySelector('input[name="linkType"][value="dependency"]').checked = true;

                // Show modal
                const overlay = document.getElementById('linkPickerOverlay');
                const modal = document.getElementById('linkPickerModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                overlay.classList.remove('hidden');
                modal.classList.remove('hidden');
                this._linkPickerRelease = this.trapFocus(modal);
            },

            updateLinkTargetItems() {
                const featureId = document.getElementById('linkTargetFeature').value;
                const itemSelect = document.getElementById('linkTargetItem');

                itemSelect.innerHTML = '<option value="">Select timeline item...</option>';

                if (!featureId) return;

                const feature = this.features.find(f => f.id === featureId);
                if (feature && feature.timelineItems) {
                    feature.timelineItems.forEach(item => {
                        itemSelect.innerHTML += `<option value="${item.id}">${item.timeline} - ${item.difficulty}</option>`;
                    });
                }
            },

            async saveManualLink() {
                const targetFeatureId = document.getElementById('linkTargetFeature').value;
                const targetItemId = document.getElementById('linkTargetItem').value;
                const linkType = document.querySelector('input[name="linkType"]:checked').value;
                const reason = document.getElementById('linkReason').value.trim() || 'Manually linked';

                if (!targetFeatureId || !targetItemId) {
                    await this.showAlert({ title:'Missing selection', message:'Please select both target feature and timeline item.' });
                    return;
                }

                // Find source item in currentTimelineItems
                const sourceItem = this.currentTimelineItems.find(i => i.id === this.currentLinkSourceItemId);
                if (!sourceItem) {
                    await this.showAlert({ title:'Not found', message:'Error: Source item not found.' , variant:'danger'});
                    return;
                }

                // Initialize linkedItems if not exists
                if (!sourceItem.linkedItems) {
                    sourceItem.linkedItems = [];
                }

                // Check if link already exists
                const linkExists = sourceItem.linkedItems.some(l => l.linkedItemId === targetItemId);
                if (linkExists) {
                    await this.showAlert({ title:'Duplicate link', message:'This link already exists.' });
                    return;
                }

                // Add outgoing link to source
                sourceItem.linkedItems.push({
                    linkedItemId: targetItemId,
                    linkedFeatureId: targetFeatureId,
                    relationshipType: linkType,
                    reason: reason,
                    direction: 'outgoing'
                });

                // Add bidirectional link to target (in the actual feature, not currentTimelineItems)
                if (this.editingId) {
                    const targetFeature = this.features.find(f => f.id === targetFeatureId);
                    if (targetFeature) {
                        const targetItem = targetFeature.timelineItems.find(i => i.id === targetItemId);
                        if (targetItem) {
                            if (!targetItem.linkedItems) {
                                targetItem.linkedItems = [];
                            }
                            targetItem.linkedItems.push({
                                linkedItemId: this.currentLinkSourceItemId,
                                linkedFeatureId: this.editingId,
                                relationshipType: linkType,
                                reason: reason,
                                direction: 'incoming'
                            });
                        }
                    }
                }

                // Re-render timeline items to show new link
                this.renderTimelineItems();

                // Close modal
                this.closeLinkPicker();

                console.log('✅ Manual link created');
            },

            async removeLink(sourceItemId, linkedItemId) {
                const ok = await this.showConfirm({ title:'Remove link?', message:'This will unlink the items.', confirmText:'Remove', cancelText:'Cancel', variant:'danger' });
                if (!ok) return;

                // Find source item
                const sourceItem = this.currentTimelineItems.find(i => i.id === sourceItemId);
                if (!sourceItem || !sourceItem.linkedItems) return;

                // Find the link to get target feature ID
                const link = sourceItem.linkedItems.find(l => l.linkedItemId === linkedItemId);
                if (!link) return;

                // Remove from source
                sourceItem.linkedItems = sourceItem.linkedItems.filter(l => l.linkedItemId !== linkedItemId);

                // Remove bidirectional link from target
                if (this.editingId) {
                    const targetFeature = this.features.find(f => f.id === link.linkedFeatureId);
                    if (targetFeature) {
                        const targetItem = targetFeature.timelineItems.find(i => i.id === linkedItemId);
                        if (targetItem && targetItem.linkedItems) {
                            targetItem.linkedItems = targetItem.linkedItems.filter(l => l.linkedItemId !== sourceItemId);
                        }
                    }
                }

                // Re-render
                this.renderTimelineItems();

                console.log('✅ Link removed');
            },

            closeLinkPicker() {
                document.getElementById('linkPickerOverlay').classList.add('hidden');
                document.getElementById('linkPickerModal').classList.add('hidden');
                if (this._linkPickerRelease) { this._linkPickerRelease(); this._linkPickerRelease = null; }
                this.currentLinkSourceItemId = null;
            },

            buildNarrativeExplanation(sourceFeature, sourceItem, targetFeature, targetItem, relationshipType) {
                // Build a narrative explanation of how the features are linked
                const sourceName = sourceFeature.name;
                const targetName = targetFeature.name;
                const sourceCategories = (sourceItem.category || []).join(', ') || 'general functionality';
                const targetCategories = (targetItem.category || []).join(', ') || 'general functionality';
                const sourceIntegration = sourceItem.integrationType || 'standard implementation';
                const targetIntegration = targetItem.integrationType || 'standard implementation';
                const sourceUSP = sourceItem.usp || '';
                const targetUSP = targetItem.usp || '';
                
                let narrative = '';
                
                if (relationshipType === 'dependency') {
                    // Dependency narrative
                    narrative += `<strong>${sourceName}</strong> depends on <strong>${targetName}</strong> because `;
                    
                    // Add context about categories
                    if (sourceCategories !== 'general functionality' || targetCategories !== 'general functionality') {
                        narrative += `${sourceName}'s ${sourceCategories} functionality requires ${targetName}'s ${targetCategories} capabilities to be in place first. `;
                    } else {
                        narrative += `it requires the foundational capabilities provided by ${targetName}. `;
                    }
                    
                    // Add integration context if meaningful
                    if (sourceIntegration !== 'standard implementation' || targetIntegration !== 'standard implementation') {
                        narrative += `The ${sourceIntegration} used by ${sourceName} relies on ${targetName}'s ${targetIntegration} being operational. `;
                    }
                    
                    // Add USP context if available
                    if (sourceUSP && targetUSP) {
                        narrative += `While ${sourceName} ${sourceUSP}, this value proposition can only be delivered once ${targetName} ${targetUSP}. `;
                    } else if (sourceUSP) {
                        narrative += `This dependency ensures ${sourceName} can deliver its promise to ${sourceUSP}. `;
                    }
                    
                    // Add timeline context
                    narrative += `Timeline: ${targetName} (${targetItem.timeline}, ${targetItem.difficulty} difficulty) should be completed before ${sourceName} (${sourceItem.timeline}, ${sourceItem.difficulty} difficulty).`;
                    
                } else {
                    // Complements narrative
                    narrative += `<strong>${sourceName}</strong> and <strong>${targetName}</strong> complement each other because `;
                    
                    // Add synergy context
                    if (sourceCategories !== 'general functionality' && targetCategories !== 'general functionality') {
                        narrative += `${sourceName}'s ${sourceCategories} capabilities work synergistically with ${targetName}'s ${targetCategories} features to create a more comprehensive solution. `;
                    } else {
                        narrative += `together they create a more complete and valuable user experience. `;
                    }
                    
                    // Add integration synergy if meaningful
                    if (sourceIntegration !== 'standard implementation' && targetIntegration !== 'standard implementation') {
                        narrative += `The ${sourceIntegration} in ${sourceName} pairs naturally with ${targetName}'s ${targetIntegration}, enabling cross-feature workflows. `;
                    }
                    
                    // Add USP synergy if available
                    if (sourceUSP && targetUSP) {
                        narrative += `When ${sourceName} ${sourceUSP} alongside ${targetName} which ${targetUSP}, users gain enhanced value from both features working together. `;
                    } else if (sourceUSP) {
                        narrative += `${sourceName}'s ability to ${sourceUSP} is amplified when used in conjunction with ${targetName}. `;
                    } else if (targetUSP) {
                        narrative += `${targetName}'s ability to ${targetUSP} is enhanced when paired with ${sourceName}. `;
                    }
                    
                    // Add timeline context
                    narrative += `Timeline: Both features are planned for ${sourceItem.timeline === targetItem.timeline ? 'the same phase (' + sourceItem.timeline + ')' : 'nearby phases (' + sourceName + ': ' + sourceItem.timeline + ', ' + targetName + ': ' + targetItem.timeline + ')'}, making them natural complements.`;
                }
                
                return narrative;
            },

            renderLinkSuggestions() {
                const container = document.getElementById('linkSuggestionsList');
                if (!container) return;

                if (this.linkSuggestions.length === 0) {
                    container.innerHTML = '<div style="color:rgba(255,255,255,0.8); font-size:12px; padding:10px; text-align:center;">No link suggestions</div>';
                    return;
                }

                let html = '';
                this.linkSuggestions.forEach(suggestion => {
                    const sourceFeature = this.features.find(f => f.id === suggestion.sourceFeatureId);
                    const targetFeature = this.features.find(f => f.id === suggestion.targetFeatureId);
                    const sourceItem = sourceFeature?.timelineItems.find(i => i.id === suggestion.sourceItemId);
                    const targetItem = targetFeature?.timelineItems.find(i => i.id === suggestion.targetItemId);

                    if (!sourceFeature || !targetFeature || !sourceItem || !targetItem) return;

                    // CRITICAL: Skip same-feature suggestions (safety check during rendering)
                    if (sourceFeature.id === targetFeature.id) {
                        console.warn(`Blocked same-feature suggestion from rendering: ${sourceFeature.name}`);
                        return;
                    }

                    const typeClass = suggestion.type === 'dependency' ? 'link-type-dependency' : 'link-type-complements';
                    const typeLabel = suggestion.type === 'dependency' ? 'Dependency' : 'Complements';
                    const confidenceClass = suggestion.confidence === 'high' ? 'confidence-high' : 'confidence-medium';
                    const confidenceLabel = suggestion.confidence === 'high' ? 'High Confidence' : 'Medium Confidence';

                    // Build narrative explanation
                    const narrativeExplanation = this.buildNarrativeExplanation(
                        sourceFeature, sourceItem, targetFeature, targetItem, suggestion.type
                    );

                    html += `
                        <div class="link-suggestion-item">
                            <div class="link-suggestion-header">
                                <div class="link-suggestion-features">
                                    <strong>${sourceFeature.name}</strong> (${sourceItem.timeline})
                                    <span class="link-suggestion-arrow">${suggestion.type === 'dependency' ? '→' : '↔'}</span>
                                    <strong>${targetFeature.name}</strong> (${targetItem.timeline})
                                    <span class="link-suggestion-type ${typeClass}">${typeLabel}</span>
                                    <span class="link-suggestion-confidence ${confidenceClass}">${confidenceLabel}</span>
                                </div>
                            </div>
                            <div class="link-suggestion-reason"><strong>AI Insight:</strong> ${suggestion.reason}</div>
                            <div class="link-suggestion-details" id="details-${suggestion.id}" style="display:none; margin-top:8px; padding:8px; background:rgba(255,255,255,0.1); border-radius:4px; font-size:12px; line-height:1.6;">
                                <div style="color:rgba(255,255,255,0.95);">
                                    ${narrativeExplanation}
                                </div>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
                                <button onclick="app.toggleLinkDetails('${suggestion.id}')" style="padding:4px 8px; font-size:11px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); color:white; border-radius:4px; cursor:pointer;">
                                    <span id="toggle-${suggestion.id}">▼ Show Details</span>
                                </button>
                                <div class="link-suggestion-actions">
                                    <button onclick="app.approveLinkSuggestion('${suggestion.id}')">✓ Approve</button>
                                    <button onclick="app.rejectLinkSuggestion('${suggestion.id}')">✗ Reject</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `
                    <div class="link-notification-bulk-actions">
                        <button onclick="app.approveAllLinkSuggestions()">✓ Approve All</button>
                        <button onclick="app.rejectAllLinkSuggestions()">✗ Reject All</button>
                    </div>
                `;

                container.innerHTML = html;
            },

            updateLinkNotification() {
                const notification = document.getElementById('linkNotification');
                const count = document.getElementById('linkSuggestionCount');

                if (count) {
                    count.textContent = this.linkSuggestions.length;
                }

                if (notification) {
                    if (this.linkSuggestions.length > 0) {
                        notification.classList.remove('hidden');
                    } else {
                        notification.classList.add('hidden');
                        document.getElementById('linkSuggestionsList')?.classList.remove('active');
                    }
                }
            },

            async approveLinkSuggestion(id) {
                const suggestion = this.linkSuggestions.find(s => s.id === id);
                if (suggestion) {
                    // CRITICAL: Final check - reject same-feature links
                    if (suggestion.sourceFeatureId === suggestion.targetFeatureId) {
                        console.error('❌ Blocked approval of same-feature link');
                        await this.showAlert({ title:'Cannot approve', message:'This link is between timeline items of the same feature, which is not allowed.', variant:'warning' });
                        // Remove the invalid suggestion
                        this.linkSuggestions = this.linkSuggestions.filter(s => s.id !== id);
                        this.saveLinkSuggestions();
                        this.renderLinkSuggestions();
                        this.updateLinkNotification();
                        return;
                    }

                    // Add the link to both timeline items
                    const sourceFeature = this.features.find(f => f.id === suggestion.sourceFeatureId);
                    const targetFeature = this.features.find(f => f.id === suggestion.targetFeatureId);
                    const sourceItem = sourceFeature?.timelineItems.find(i => i.id === suggestion.sourceItemId);
                    const targetItem = targetFeature?.timelineItems.find(i => i.id === suggestion.targetItemId);

                    if (sourceItem && targetItem) {
                        // Initialize linkedItems array if it doesn't exist
                        if (!sourceItem.linkedItems) sourceItem.linkedItems = [];
                        if (!targetItem.linkedItems) targetItem.linkedItems = [];

                        // Add bidirectional link
                        sourceItem.linkedItems.push({
                            linkedItemId: suggestion.targetItemId,
                            linkedFeatureId: suggestion.targetFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'outgoing'
                        });

                        targetItem.linkedItems.push({
                            linkedItemId: suggestion.sourceItemId,
                            linkedFeatureId: suggestion.sourceFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'incoming'
                        });

                        // Save features
                        this.saveData();
                    }

                    // Remove from suggestions
                    this.linkSuggestions = this.linkSuggestions.filter(s => s.id !== id);
                    this.saveLinkSuggestions();
                    this.renderLinkSuggestions();
                    this.updateLinkNotification();
                    this.renderTable(); // Refresh table to show new links
                }
            },

            rejectLinkSuggestion(id) {
                // Store the ID and show rejection reason modal
                this.currentRejectionId = id;

                // Clear previous values
                document.getElementById('rejectionCategory').value = '';
                document.getElementById('rejectionNotes').value = '';

                // Show modal
                const overlay = document.getElementById('rejectionReasonOverlay');
                const modal = document.getElementById('rejectionReasonModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                overlay.classList.remove('hidden');
                modal.classList.remove('hidden');
                this._rejectionRelease = this.trapFocus(modal);
            },

            closeRejectionReason() {
                document.getElementById('rejectionReasonOverlay').classList.add('hidden');
                document.getElementById('rejectionReasonModal').classList.add('hidden');
                if (this._rejectionRelease) { this._rejectionRelease(); this._rejectionRelease = null; }
                this.currentRejectionId = null;
            },

            async confirmRejection() {
                const category = document.getElementById('rejectionCategory').value;
                const notes = document.getElementById('rejectionNotes').value.trim();

                if (!category) {
                    await this.showAlert({ title:'Missing reason', message:'Please select a rejection reason.' });
                    return;
                }

                const suggestion = this.linkSuggestions.find(s => s.id === this.currentRejectionId);
                if (suggestion) {
                    // Add to rejected links with enhanced data (store both directions)
                    this.rejectedLinks.push({
                        sourceItemId: suggestion.sourceItemId,
                        targetItemId: suggestion.targetItemId,
                        rejectionReason: category,
                        rejectionNotes: notes,
                        originalType: suggestion.type,
                        originalConfidence: suggestion.confidence,
                        timestamp: new Date().toISOString()
                    });
                    this.rejectedLinks.push({
                        sourceItemId: suggestion.targetItemId,
                        targetItemId: suggestion.sourceItemId,
                        rejectionReason: category,
                        rejectionNotes: notes,
                        originalType: suggestion.type,
                        originalConfidence: suggestion.confidence,
                        timestamp: new Date().toISOString()
                    });
                    this.saveRejectedLinks();

                    console.log(`📝 Rejection logged: ${category} - ${notes || 'No notes'}`);
                }

                // Remove from suggestions
                this.linkSuggestions = this.linkSuggestions.filter(s => s.id !== this.currentRejectionId);
                this.saveLinkSuggestions();
                this.renderLinkSuggestions();
                this.updateLinkNotification();

                // Close modal
                this.closeRejectionReason();
            },

            // AI Action Approval Functions
            showAIActionApproval(actionType, actionData, reason) {
                if (!this.aiEditingEnabled) {
                    console.log('AI editing is disabled');
                    return;
                }

                const totalActions = this.pendingAIActions.length;

                // Update title and summary
                const title = document.getElementById('aiActionTitle');
                const summary = document.getElementById('aiActionSummary');
                const queueContainer = document.getElementById('aiActionsQueue');

                title.textContent = totalActions === 1 ? 'AI Suggested Action' : 'AI Suggested Actions';
                summary.innerHTML = totalActions === 1
                    ? '1 action pending your approval'
                    : `${totalActions} actions pending your approval`;

                // Build queue of all actions
                queueContainer.innerHTML = '';
                this.pendingAIActions.forEach((action, index) => {
                    const actionItem = document.createElement('div');
                    actionItem.className = 'ai-action-queue-item';
                    actionItem.id = `action-item-${index}`;

                    const header = `
                        <div class="ai-action-header">
                            <span class="ai-action-type">${this.getActionTypeLabel(action.actionType)}</span>
                            <span class="ai-action-number">Action ${index + 1} of ${totalActions}</span>
                        </div>
                    `;

                    const reasonHtml = `<div class="ai-action-reason">"${action.reason}"</div>`;

                    const preview = `<div class="ai-action-preview">${this.buildActionPreview(action.actionType, action.actionData, action.reason)}</div>`;

                    const buttons = `
                        <div class="ai-action-buttons">
                            <button class="reject-btn" onclick="app.rejectSingleAction(${index})">✕ Reject</button>
                            <button class="approve-btn" onclick="app.approveSingleAction(${index})">✓ Approve</button>
                        </div>
                    `;

                    actionItem.innerHTML = header + reasonHtml + preview + buttons;
                    queueContainer.appendChild(actionItem);
                });

                // Show modal
                const overlay = document.getElementById('aiActionOverlay');
                const modal = document.getElementById('aiActionModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                overlay.classList.remove('hidden');
                modal.classList.remove('hidden');
                this._aiActionRelease = this.trapFocus(modal);
            },

            getActionTypeLabel(actionType) {
                const labels = {
                    'update_feature': 'Update Feature',
                    'update_timeline_item': 'Update Timeline Item',
                    'create_feature': 'Create New Feature',
                    'create_link_suggestion': 'Create Link',
                    'add_timeline_item': 'Add Timeline Item',
                    'delete_timeline_item': 'Delete Timeline Item'
                };
                return labels[actionType] || actionType;
            },

            buildActionPreview(actionType, actionData, reason) {
                let html = `<div style="margin-bottom: 10px;"><strong>Reason:</strong> ${reason}</div>`;
                
                switch (actionType) {
                    case 'update_feature':
                        const feature = this.features.find(f => f.id === actionData.featureId);
                        if (feature) {
                            html += '<div style="margin-top: 10px;"><strong>Changes:</strong></div>';
                            if (actionData.updates.name) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Name:</strong><br>
                                    <span style="color: var(--danger);">- ${feature.name}</span><br>
                                    <span style="color: var(--success);">+ ${actionData.updates.name}</span>
                                </div>`;
                            }
                            if (actionData.updates.type) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Type:</strong><br>
                                    <span style="color: var(--danger);">- ${feature.type}</span><br>
                                    <span style="color: var(--success);">+ ${actionData.updates.type}</span>
                                </div>`;
                            }
                            if (actionData.updates.purpose) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Purpose:</strong><br>
                                    <span style="color: var(--danger);">- ${feature.purpose}</span><br>
                                    <span style="color: var(--success);">+ ${actionData.updates.purpose}</span>
                                </div>`;
                            }
                        }
                        break;
                        
                    case 'update_timeline_item':
                        const featureForItem = this.features.find(f => f.id === actionData.featureId);
                        const item = featureForItem?.timelineItems.find(i => i.id === actionData.itemId);
                        if (item) {
                            html += `<div style="margin-top: 10px;"><strong>Feature:</strong> ${featureForItem.name}</div>`;
                            html += `<div><strong>Timeline Item:</strong> ${item.timeline} - ${item.difficulty}</div>`;
                            html += '<div style="margin-top: 10px;"><strong>Changes:</strong></div>';
                            if (actionData.updates.difficulty) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Difficulty:</strong> ${item.difficulty} → ${actionData.updates.difficulty}
                                </div>`;
                            }
                            if (actionData.updates.category) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Categories:</strong> ${(item.category || []).join(', ') || 'None'} → ${actionData.updates.category.join(', ')}
                                </div>`;
                            }
                            if (actionData.updates.integrationType) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Integration:</strong> ${item.integrationType || 'None'} → ${actionData.updates.integrationType}
                                </div>`;
                            }
                            if (actionData.updates.usp) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>USP:</strong> ${item.usp || 'None'} → ${actionData.updates.usp}
                                </div>`;
                            }
                        }
                        break;
                        
                    case 'create_feature':
                        html += `<div style="margin-top: 10px;"><strong>New Feature:</strong></div>`;
                        html += `<div style="padding: 8px; background: rgba(16, 185, 129, 0.1); margin: 5px 0; border-radius: 4px;">
                            <div><strong>Name:</strong> ${actionData.name}</div>
                            <div><strong>Type:</strong> ${actionData.type}</div>
                            <div><strong>Purpose:</strong> ${actionData.purpose}</div>
                            <div style="margin-top: 8px;"><strong>Timeline Items:</strong> ${actionData.timelineItems.length}</div>
                            ${actionData.timelineItems.map(ti => `
                                <div style="padding: 5px; margin: 3px 0; background: rgba(255,255,255,0.1); border-radius: 3px;">
                                    ${ti.timeline} - ${ti.difficulty} ${ti.category ? '(' + ti.category.join(', ') + ')' : ''}
                                </div>
                            `).join('')}
                        </div>`;
                        break;
                        
                    case 'create_link_suggestion':
                        const srcFeature = this.features.find(f => f.id === actionData.sourceFeatureId);
                        const tgtFeature = this.features.find(f => f.id === actionData.targetFeatureId);
                        const srcItem = srcFeature?.timelineItems.find(i => i.id === actionData.sourceItemId);
                        const tgtItem = tgtFeature?.timelineItems.find(i => i.id === actionData.targetItemId);
                        html += `<div style="margin-top: 10px;"><strong>Link:</strong></div>`;
                        html += `<div style="padding: 8px; background: rgba(59, 130, 246, 0.1); margin: 5px 0; border-radius: 4px;">
                            <div><strong>${srcFeature?.name}</strong> (${srcItem?.timeline})</div>
                            <div style="text-align: center; margin: 5px 0;">${actionData.relationshipType === 'dependency' ? '→ depends on' : '↔ complements'}</div>
                            <div><strong>${tgtFeature?.name}</strong> (${tgtItem?.timeline})</div>
                        </div>`;
                        break;
                        
                    case 'add_timeline_item':
                        const featureForAdd = this.features.find(f => f.id === actionData.featureId);
                        html += `<div style="margin-top: 10px;"><strong>Add to Feature:</strong> ${featureForAdd?.name}</div>`;
                        html += `<div style="padding: 8px; background: rgba(16, 185, 129, 0.1); margin: 5px 0; border-radius: 4px;">
                            <div><strong>Timeline:</strong> ${actionData.timelineItem.timeline}</div>
                            <div><strong>Difficulty:</strong> ${actionData.timelineItem.difficulty}</div>
                            ${actionData.timelineItem.category ? `<div><strong>Categories:</strong> ${actionData.timelineItem.category.join(', ')}</div>` : ''}
                            ${actionData.timelineItem.integrationType ? `<div><strong>Integration:</strong> ${actionData.timelineItem.integrationType}</div>` : ''}
                            ${actionData.timelineItem.usp ? `<div><strong>USP:</strong> ${actionData.timelineItem.usp}</div>` : ''}
                        </div>`;
                        break;
                        
                    case 'delete_timeline_item':
                        const featureForDel = this.features.find(f => f.id === actionData.featureId);
                        const itemToDel = featureForDel?.timelineItems.find(i => i.id === actionData.itemId);
                        html += `<div style="margin-top: 10px;"><strong>Delete from Feature:</strong> ${featureForDel?.name}</div>`;
                        html += `<div style="padding: 8px; background: var(--danger-light); margin: 5px 0; border-radius: 4px; color: var(--danger-text);">
                            <div><strong>Timeline Item:</strong> ${itemToDel?.timeline} - ${itemToDel?.difficulty}</div>
                            <div style="margin-top: 5px; font-size: 12px;">⚠️ This action cannot be undone easily!</div>
                        </div>`;
                        break;
                }
                
                return html;
            },

            closeAIActionApproval(clearQueue = true) {
                document.getElementById('aiActionOverlay').classList.add('hidden');
                document.getElementById('aiActionModal').classList.add('hidden');
                if (this._aiActionRelease) { this._aiActionRelease(); this._aiActionRelease = null; }
                // Only clear queue when explicitly closing (not when auto-advancing to next action)
                if (clearQueue) {
                    this.pendingAIActions = [];
                }
            },

            async approveAIAction() {
                if (this.pendingAIActions.length === 0) return;
                
                const action = this.pendingAIActions[0];
                
                try {
                    let result = null;
                    
                    switch (action.actionType) {
                        case 'update_feature':
                            result = await this.executeUpdateFeature(action.actionData);
                            break;
                        case 'update_timeline_item':
                            result = await this.executeUpdateTimelineItem(action.actionData);
                            break;
                        case 'create_feature':
                            result = await this.executeCreateFeature(action.actionData);
                            break;
                        case 'create_feature_with_research':
                            result = await this.executeCreateFeatureWithResearch(action.actionData);
                            break;
                        case 'enhance_feature_with_research':
                            result = await this.executeEnhanceFeatureWithResearch(action.actionData);
                            break;
                        case 'create_link_suggestion':
                            result = await this.executeCreateLink(action.actionData);
                            break;
                        case 'add_timeline_item':
                            result = await this.executeAddTimelineItem(action.actionData);
                            break;
                        case 'delete_timeline_item':
                            result = await this.executeDeleteTimelineItem(action.actionData);
                            break;
                    }
                    
                    // Log the action
                    this.aiActionLog.push({
                        ...action,
                        approved: true,
                        result: result,
                        approvedAt: new Date().toISOString()
                    });
                    
                    this.saveAIActionLog();
                    this.updateActionLogCounter();
                    
                    // Remove the processed action from queue
                    this.pendingAIActions.shift();
                    
                    // Show toast for this action
                    this.showToast(`✓ AI action approved: ${this.getActionTypeLabel(action.actionType)}`, 'success');
                    
                    // Add a message to chat
                    this.addChatMessage(`✅ I've successfully ${this.getActionTypeLabel(action.actionType).toLowerCase()}. The changes are now live in your roadmap.`, 'ai');
                    
                    // Check if there are more actions to process
                    if (this.pendingAIActions.length > 0) {
                        // Show next action in queue
                        const nextAction = this.pendingAIActions[0];
                        this.showAIActionApproval(nextAction.actionType, nextAction.actionData, nextAction.reason);
                    } else {
                        // No more actions, close the modal
                        this.closeAIActionApproval(true);
                    }
                    
                } catch (error) {
                    console.error('Error executing AI action:', error);
                    this.showToast(`❌ Error: ${error.message}`, 'error');
                    // On error, still remove the action and show next or close
                    this.pendingAIActions.shift();
                    if (this.pendingAIActions.length > 0) {
                        const nextAction = this.pendingAIActions[0];
                        this.showAIActionApproval(nextAction.actionType, nextAction.actionData, nextAction.reason);
                    } else {
                        this.closeAIActionApproval(true);
                    }
                }
            },

            rejectAIAction() {
                if (this.pendingAIActions.length === 0) return;

                const action = this.pendingAIActions[0];

                // Log the rejection
                this.aiActionLog.push({
                    ...action,
                    approved: false,
                    rejectedAt: new Date().toISOString()
                });

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Remove the rejected action from queue
                this.pendingAIActions.shift();

                this.showToast('AI action rejected', 'info');

                // Add a message to chat
                this.addChatMessage('I understand. I won\'t make that change. Feel free to let me know if you\'d like me to suggest something different.', 'ai');

                // Check if there are more actions to process
                if (this.pendingAIActions.length > 0) {
                    // Show next action in queue
                    const nextAction = this.pendingAIActions[0];
                    this.showAIActionApproval(nextAction.actionType, nextAction.actionData, nextAction.reason);
                } else {
                    // No more actions, close the modal
                    this.closeAIActionApproval(true);
                }
            },

            // Approve a single action from the queue
            async approveSingleAction(index) {
                if (index < 0 || index >= this.pendingAIActions.length) return;

                const action = this.pendingAIActions[index];

                // Mark as processing
                const actionItem = document.getElementById(`action-item-${index}`);
                if (actionItem) {
                    actionItem.classList.add('approved');
                    const buttons = actionItem.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = true);
                }

                try {
                    let result = null;

                    switch (action.actionType) {
                        case 'update_feature':
                            result = await this.executeUpdateFeature(action.actionData);
                            break;
                        case 'update_timeline_item':
                            result = await this.executeUpdateTimelineItem(action.actionData);
                            break;
                        case 'create_feature':
                            result = await this.executeCreateFeature(action.actionData);
                            break;
                        case 'create_feature_with_research':
                            result = await this.executeCreateFeatureWithResearch(action.actionData);
                            break;
                        case 'enhance_feature_with_research':
                            result = await this.executeEnhanceFeatureWithResearch(action.actionData);
                            break;
                        case 'create_link_suggestion':
                            result = await this.executeCreateLink(action.actionData);
                            break;
                        case 'add_timeline_item':
                            result = await this.executeAddTimelineItem(action.actionData);
                            break;
                        case 'delete_timeline_item':
                            result = await this.executeDeleteTimelineItem(action.actionData);
                            break;
                    }

                    // Log the action
                    this.aiActionLog.push({
                        ...action,
                        approved: true,
                        result: result,
                        approvedAt: new Date().toISOString()
                    });

                    this.saveAIActionLog();
                    this.updateActionLogCounter();

                    // Remove from pending queue
                    this.pendingAIActions.splice(index, 1);

                    this.showToast(`✓ ${this.getActionTypeLabel(action.actionType)} approved`, 'success');

                    // Refresh the queue display
                    if (this.pendingAIActions.length > 0) {
                        const firstAction = this.pendingAIActions[0];
                        this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                    } else {
                        this.closeAIActionApproval(true);
                        this.addChatMessage(`✅ All actions completed successfully!`, 'ai');
                    }

                } catch (error) {
                    console.error('Error executing action:', error);
                    this.showToast(`❌ Error: ${error.message}`, 'error');

                    // Remove failed action
                    this.pendingAIActions.splice(index, 1);

                    // Refresh display
                    if (this.pendingAIActions.length > 0) {
                        const firstAction = this.pendingAIActions[0];
                        this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                    } else {
                        this.closeAIActionApproval(true);
                    }
                }
            },

            // Reject a single action from the queue
            rejectSingleAction(index) {
                if (index < 0 || index >= this.pendingAIActions.length) return;

                const action = this.pendingAIActions[index];

                // Mark as rejected
                const actionItem = document.getElementById(`action-item-${index}`);
                if (actionItem) {
                    actionItem.classList.add('rejected');
                    const buttons = actionItem.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = true);
                }

                // Log the rejection
                this.aiActionLog.push({
                    ...action,
                    approved: false,
                    rejectedAt: new Date().toISOString()
                });

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Remove from pending queue
                this.pendingAIActions.splice(index, 1);

                this.showToast('Action rejected', 'info');

                // Refresh the queue display
                if (this.pendingAIActions.length > 0) {
                    const firstAction = this.pendingAIActions[0];
                    this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                } else {
                    this.closeAIActionApproval(true);
                    this.addChatMessage('I understand. I won\'t make those changes.', 'ai');
                }
            },

            // Approve all pending actions
            async approveAllAIActions() {
                if (this.pendingAIActions.length === 0) return;

                const totalActions = this.pendingAIActions.length;
                this.showToast(`Approving ${totalActions} actions...`, 'info');

                let successCount = 0;
                let errorCount = 0;

                // Process all actions
                while (this.pendingAIActions.length > 0) {
                    const action = this.pendingAIActions[0];

                    try {
                        let result = null;

                        switch (action.actionType) {
                            case 'update_feature':
                                result = await this.executeUpdateFeature(action.actionData);
                                break;
                            case 'update_timeline_item':
                                result = await this.executeUpdateTimelineItem(action.actionData);
                                break;
                            case 'create_feature':
                                result = await this.executeCreateFeature(action.actionData);
                                break;
                            case 'create_feature_with_research':
                                result = await this.executeCreateFeatureWithResearch(action.actionData);
                                break;
                            case 'enhance_feature_with_research':
                                result = await this.executeEnhanceFeatureWithResearch(action.actionData);
                                break;
                            case 'create_link_suggestion':
                                result = await this.executeCreateLink(action.actionData);
                                break;
                            case 'add_timeline_item':
                                result = await this.executeAddTimelineItem(action.actionData);
                                break;
                            case 'delete_timeline_item':
                                result = await this.executeDeleteTimelineItem(action.actionData);
                                break;
                        }

                        // Log the action
                        this.aiActionLog.push({
                            ...action,
                            approved: true,
                            result: result,
                            approvedAt: new Date().toISOString()
                        });

                        successCount++;

                    } catch (error) {
                        console.error('Error executing action:', error);
                        errorCount++;

                        // Log the failed action
                        this.aiActionLog.push({
                            ...action,
                            approved: false,
                            error: error.message,
                            failedAt: new Date().toISOString()
                        });
                    }

                    // Remove from queue
                    this.pendingAIActions.shift();
                }

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Close modal and show results
                this.closeAIActionApproval(true);

                if (errorCount === 0) {
                    this.showToast(`✓ All ${successCount} actions approved successfully!`, 'success');
                    this.addChatMessage(`✅ I've successfully completed all ${successCount} actions! Your roadmap has been updated.`, 'ai');
                } else {
                    this.showToast(`✓ ${successCount} succeeded, ${errorCount} failed`, 'warning');
                    this.addChatMessage(`I've completed ${successCount} actions successfully, but ${errorCount} failed. Please check the action log for details.`, 'ai');
                }
            },

            // Reject all pending actions
            rejectAllAIActions() {
                if (this.pendingAIActions.length === 0) return;

                const totalActions = this.pendingAIActions.length;

                // Log all rejections
                this.pendingAIActions.forEach(action => {
                    this.aiActionLog.push({
                        ...action,
                        approved: false,
                        rejectedAt: new Date().toISOString()
                    });
                });

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Clear the queue
                this.pendingAIActions = [];

                // Close modal
                this.closeAIActionApproval(true);

                this.showToast(`Rejected ${totalActions} actions`, 'info');
                this.addChatMessage(`I understand. I won't make any of those ${totalActions} changes. Let me know if you'd like me to suggest something different.`, 'ai');
            },

            // AI Tool Executor Functions
            async executeUpdateFeature(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                if (actionData.updates.name) feature.name = actionData.updates.name;
                if (actionData.updates.type) feature.type = actionData.updates.type;
                if (actionData.updates.purpose) feature.purpose = actionData.updates.purpose;
                
                feature.updatedAt = new Date().toISOString();
                feature.aiModified = true;
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id };
            },

            async executeUpdateTimelineItem(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                const item = feature.timelineItems.find(i => i.id === actionData.itemId);
                if (!item) throw new Error('Timeline item not found');
                
                if (actionData.updates.difficulty) item.difficulty = actionData.updates.difficulty;
                if (actionData.updates.category) item.category = actionData.updates.category;
                if (actionData.updates.integrationType) item.integrationType = actionData.updates.integrationType;
                if (actionData.updates.usp) item.usp = actionData.updates.usp;
                
                item.aiModified = true;
                feature.updatedAt = new Date().toISOString();
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id, itemId: item.id };
            },

            async executeCreateFeature(actionData) {
                // Generate summaries for timeline items
                const summaries = await this.summarizeTimelineItems(actionData.timelineItems);
                
                const newFeature = {
                    id: Date.now().toString(),
                    name: actionData.name,
                    type: actionData.type,
                    purpose: actionData.purpose,
                    timelineItems: actionData.timelineItems.map((item, index) => ({
                        id: Date.now().toString() + '_' + index,
                        timeline: item.timeline,
                        difficulty: item.difficulty,
                        category: item.category || [],
                        integrationType: item.integrationType || '',
                        usp: item.usp || '',
                        linkedItems: []
                    })),
                    summary: summaries,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    aiCreated: true
                };
                
                this.features.push(newFeature);
                
                // Add categories to allTags
                newFeature.timelineItems.forEach(item => {
                    item.category.forEach(c => this.allTags.add(c));
                });
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: newFeature.id };
            },

            async executeCreateLink(actionData) {
                const sourceFeature = this.features.find(f => f.id === actionData.sourceFeatureId);
                const targetFeature = this.features.find(f => f.id === actionData.targetFeatureId);
                
                if (!sourceFeature || !targetFeature) throw new Error('Feature not found');
                
                const sourceItem = sourceFeature.timelineItems.find(i => i.id === actionData.sourceItemId);
                const targetItem = targetFeature.timelineItems.find(i => i.id === actionData.targetItemId);
                
                if (!sourceItem || !targetItem) throw new Error('Timeline item not found');
                
                // Check if link already exists
                const linkExists = sourceItem.linkedItems?.some(l => 
                    l.linkedItemId === actionData.targetItemId && l.linkedFeatureId === actionData.targetFeatureId
                );
                
                if (linkExists) throw new Error('Link already exists');
                
                // Initialize linkedItems if needed
                if (!sourceItem.linkedItems) sourceItem.linkedItems = [];
                if (!targetItem.linkedItems) targetItem.linkedItems = [];
                
                // Add bidirectional link
                sourceItem.linkedItems.push({
                    linkedItemId: actionData.targetItemId,
                    linkedFeatureId: actionData.targetFeatureId,
                    relationshipType: actionData.relationshipType,
                    reason: actionData.reason,
                    direction: 'outgoing',
                    aiCreated: true
                });
                
                targetItem.linkedItems.push({
                    linkedItemId: actionData.sourceItemId,
                    linkedFeatureId: actionData.sourceFeatureId,
                    relationshipType: actionData.relationshipType,
                    reason: actionData.reason,
                    direction: 'incoming',
                    aiCreated: true
                });
                
                this.saveData();
                this.renderTable();
                
                return { success: true, sourceItemId: sourceItem.id, targetItemId: targetItem.id };
            },

            async executeAddTimelineItem(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                const newItem = {
                    id: Date.now().toString(),
                    timeline: actionData.timelineItem.timeline,
                    difficulty: actionData.timelineItem.difficulty,
                    category: actionData.timelineItem.category || [],
                    integrationType: actionData.timelineItem.integrationType || '',
                    usp: actionData.timelineItem.usp || '',
                    linkedItems: [],
                    aiCreated: true
                };
                
                feature.timelineItems.push(newItem);
                
                // Add categories to allTags
                newItem.category.forEach(c => this.allTags.add(c));
                
                // Regenerate summaries
                feature.summary = await this.summarizeTimelineItems(feature.timelineItems);
                feature.updatedAt = new Date().toISOString();
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id, itemId: newItem.id };
            },

            async executeDeleteTimelineItem(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                const itemIndex = feature.timelineItems.findIndex(i => i.id === actionData.itemId);
                if (itemIndex === -1) throw new Error('Timeline item not found');
                
                // Remove the item
                feature.timelineItems.splice(itemIndex, 1);
                
                // Regenerate summaries
                if (feature.timelineItems.length > 0) {
                    feature.summary = await this.summarizeTimelineItems(feature.timelineItems);
                }
                feature.updatedAt = new Date().toISOString();
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id, deletedItemId: actionData.itemId };
            },

            async executeSearchInternet(actionData) {
                if (!this.tavilyApiKey) {
                    throw new Error('Tavily API key not configured. Please add your Tavily API key in settings.');
                }

                if (!this.apiKey) {
                    throw new Error('OpenRouter API key required for synthesizing search results.');
                }

                try {
                    // Step 1: Execute search
                    const response = await fetch('https://api.tavily.com/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: this.tavilyApiKey,
                            query: actionData.query,
                            search_depth: 'advanced',
                            max_results: 10,
                            include_answer: true,
                            include_raw_content: true
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Tavily API error: ${response.statusText}`);
                    }

                    const searchData = await response.json();
                    
                    if (!searchData.results || searchData.results.length === 0) {
                        this.addChatMessage('🔍 No search results found for your query.', 'ai');
                        return { 
                            success: true, 
                            query: actionData.query,
                            resultsCount: 0
                        };
                    }

                    // Step 2: Synthesize answer using AI
                    // Add feature context if in enhancement mode
                    let contextualInfo = '';
                    if (this.aiFeatureEnhancementMode && this.currentFeatureId) {
                        const feature = this.features.find(f => f.id === this.currentFeatureId);
                        if (feature) {
                            contextualInfo = `\n\nIMPORTANT CONTEXT - Answer specifically in relation to this feature:
Feature Name: ${feature.name}
Feature Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}
Current Status: ${feature.executionSteps ? 'Has execution steps' : 'Needs execution steps'}, ${feature.resources ? 'Has resources' : 'Needs resources'}, ${feature.planning ? 'Has planning' : 'Needs planning'}

Your answer should be tailored to help enhance THIS specific feature with relevant, actionable information.\n`;
                        }
                    }

                    const synthesisPrompt = `Based on the following search results, provide a comprehensive and well-structured answer to the user's question: "${actionData.query}"${contextualInfo}

Search Results:
${searchData.results.map((result, index) => `
[${index + 1}] ${result.title}
URL: ${result.url}
Content: ${result.content || 'No content available'}
`).join('\n\n')}

Please synthesize this information into a clear, informative answer that directly addresses the user's question. Be thorough but concise.`;

                    const synthesisResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { 
                                    role: 'system', 
                                    content: 'You are a helpful assistant that synthesizes search results into clear, comprehensive answers. Focus on providing accurate, well-structured information based on the search results provided.' 
                                },
                                { role: 'user', content: synthesisPrompt }
                            ],
                            temperature: 0.7
                        })
                    });

                    if (!synthesisResponse.ok) {
                        throw new Error(`Failed to synthesize answer: ${synthesisResponse.statusText}`);
                    }

                    const synthesisData = await synthesisResponse.json();
                    const synthesizedAnswer = synthesisData.choices[0].message.content;

                    // Step 3: Format and display with collapsible sources
                    const sourcesCount = searchData.results.length;
                    
                    // Escape HTML in source data
                    const escapeHtml = (text) => {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };
                    
                    const sourcesHtml = searchData.results.map((result, index) => {
                        const title = escapeHtml(result.title || 'Untitled');
                        const url = escapeHtml(result.url);
                        // URL for href should be properly encoded
                        const urlHref = result.url.replace(/"/g, '&quot;');
                        return `
                            <div class="source-item">
                                <div class="source-title">${title}</div>
                                <a href="${urlHref}" target="_blank" rel="noopener noreferrer" class="source-url">${url}</a>
                            </div>
                        `;
                    }).join('');

                    const formattedAnswer = this.formatMessage(synthesizedAnswer);
                    const searchResultsHtml = `
                        <div class="search-synthesis">
                            <div class="ai-answer">${formattedAnswer}</div>
                            <div class="search-sources">
                                <button class="sources-toggle" onclick="app.toggleSources(this)">
                                    View ${sourcesCount} source${sourcesCount !== 1 ? 's' : ''}
                                </button>
                                <div class="sources-list">
                                    ${sourcesHtml}
                                </div>
                            </div>
                        </div>
                    `;

                    // Add to chat with HTML (we control the HTML structure, so safe to set directly)
                    const messagesContainer = document.getElementById('chatMessages');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'chat-message ai';
                    // Set innerHTML directly since we're generating safe HTML ourselves
                    messageDiv.innerHTML = searchResultsHtml;
                    messagesContainer.appendChild(messageDiv);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    return { 
                        success: true, 
                        query: actionData.query,
                        resultsCount: sourcesCount,
                        synthesizedAnswer: synthesizedAnswer
                    };
                } catch (error) {
                    console.error('Search error:', error);
                    throw error;
                }
            },

            // Silent version of search for batching multiple searches
            async executeSearchInternetSilent(actionData) {
                if (!this.tavilyApiKey) {
                    throw new Error('Tavily API key not configured.');
                }

                if (!this.apiKey) {
                    throw new Error('OpenRouter API key required for synthesizing search results.');
                }

                try {
                    // Step 1: Execute search
                    const response = await fetch('https://api.tavily.com/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: this.tavilyApiKey,
                            query: actionData.query,
                            search_depth: 'advanced',
                            max_results: 10,
                            include_answer: true,
                            include_raw_content: true
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Tavily API error: ${response.statusText}`);
                    }

                    const searchData = await response.json();

                    if (!searchData.results || searchData.results.length === 0) {
                        return {
                            success: true,
                            query: actionData.query,
                            resultsCount: 0,
                            results: [],
                            synthesizedAnswer: 'No search results found for your query.'
                        };
                    }

                    // Step 2: Synthesize answer using AI
                    // Add feature context if in enhancement mode
                    let contextualInfo = '';
                    if (this.aiFeatureEnhancementMode && this.currentFeatureId) {
                        const feature = this.features.find(f => f.id === this.currentFeatureId);
                        if (feature) {
                            contextualInfo = `\n\nIMPORTANT CONTEXT - Answer specifically in relation to this feature:
Feature Name: ${feature.name}
Feature Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}
Current Status: ${feature.executionSteps ? 'Has execution steps' : 'Needs execution steps'}, ${feature.resources ? 'Has resources' : 'Needs resources'}, ${feature.planning ? 'Has planning' : 'Needs planning'}

Your answer should be tailored to help enhance THIS specific feature with relevant, actionable information.\n`;
                        }
                    }

                    const synthesisPrompt = `Based on the following search results, provide a comprehensive and well-structured answer to the user's question: "${actionData.query}"${contextualInfo}

Search Results:
${searchData.results.map((result, index) => `
[${index + 1}] ${result.title}
URL: ${result.url}
Content: ${result.content || 'No content available'}
`).join('\n\n')}

Please synthesize this information into a clear, informative answer that directly addresses the user's question. Be thorough but concise.`;

                    const synthesisResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are a helpful assistant that synthesizes search results into clear, comprehensive answers. Focus on providing accurate, well-structured information based on the search results provided.'
                                },
                                { role: 'user', content: synthesisPrompt }
                            ],
                            temperature: 0.7
                        })
                    });

                    if (!synthesisResponse.ok) {
                        throw new Error(`Failed to synthesize answer: ${synthesisResponse.statusText}`);
                    }

                    const synthesisData = await synthesisResponse.json();
                    const synthesizedAnswer = synthesisData.choices[0].message.content;

                    // Return data without displaying
                    return {
                        success: true,
                        query: actionData.query,
                        resultsCount: searchData.results.length,
                        results: searchData.results,
                        synthesizedAnswer: synthesizedAnswer
                    };
                } catch (error) {
                    console.error('Silent search error:', error);
                    return {
                        success: false,
                        query: actionData.query,
                        error: error.message,
                        resultsCount: 0,
                        results: [],
                        synthesizedAnswer: `Error: ${error.message}`
                    };
                }
            },

            // Display multiple search results in one combined message
            displayBatchedSearchResults(searchResults) {
                if (!searchResults || searchResults.length === 0) {
                    return;
                }

                const messagesContainer = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message ai';

                // Escape HTML helper
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };

                // Build combined display
                let combinedHtml = '<div class="batched-search-results">';

                // Header showing number of searches
                const successfulSearches = searchResults.filter(r => r.success && r.resultsCount > 0);
                if (successfulSearches.length > 1) {
                    combinedHtml += `<div class="batch-search-header">🔍 Searched ${successfulSearches.length} queries and found ${successfulSearches.reduce((sum, r) => sum + r.resultsCount, 0)} total results</div>`;
                }

                // Display each search result
                successfulSearches.forEach((result, index) => {
                    const queryLabel = successfulSearches.length > 1 ? `<div class="search-query-label">Query ${index + 1}: "${escapeHtml(result.query)}"</div>` : '';

                    // Format the synthesized answer
                    const formattedAnswer = this.formatMessage(result.synthesizedAnswer);

                    // Build sources HTML
                    const sourcesHtml = result.results.map((source, idx) => {
                        const title = escapeHtml(source.title || 'Untitled');
                        const url = escapeHtml(source.url);
                        const urlHref = source.url.replace(/"/g, '&quot;');
                        return `
                            <div class="source-item">
                                <div class="source-title">${title}</div>
                                <a href="${urlHref}" target="_blank" rel="noopener noreferrer" class="source-url">${url}</a>
                            </div>
                        `;
                    }).join('');

                    combinedHtml += `
                        <div class="search-result-section">
                            ${queryLabel}
                            <div class="search-synthesis">
                                <div class="ai-answer">${formattedAnswer}</div>
                                <div class="search-sources">
                                    <button class="sources-toggle" onclick="app.toggleSources(this)">
                                        View ${result.resultsCount} source${result.resultsCount !== 1 ? 's' : ''}
                                    </button>
                                    <div class="sources-list">
                                        ${sourcesHtml}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                // Show errors if any
                const failedSearches = searchResults.filter(r => !r.success || r.resultsCount === 0);
                if (failedSearches.length > 0) {
                    combinedHtml += '<div class="failed-searches">';
                    failedSearches.forEach(result => {
                        combinedHtml += `<div class="search-error">⚠️ No results for: "${escapeHtml(result.query)}"</div>`;
                    });
                    combinedHtml += '</div>';
                }

                combinedHtml += '</div>';

                messageDiv.innerHTML = combinedHtml;
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            },

            addChatMessage(text, sender, id = null) {
                const messagesContainer = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}`;
                if (id) messageDiv.id = id;

                // Format AI messages, keep user messages as-is
                if (sender === 'ai' && !text.includes('<span class="loading">')) {
                    const formatted = this.formatMessage(text);
                    const safe = this.sanitizeHtml(formatted) || '';
                    if (safe) messageDiv.innerHTML = safe; else messageDiv.textContent = text;
                } else {
                    messageDiv.innerHTML = text;
                }

                messagesContainer.appendChild(messageDiv);
                
                // Wrap any tables in scrollable wrapper if not already wrapped
                if (sender === 'ai') {
                    const tables = messageDiv.querySelectorAll('table:not(.table-wrapper table)');
                    tables.forEach(table => {
                        if (!table.parentElement.classList.contains('table-wrapper')) {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'table-wrapper';
                            table.parentNode.insertBefore(wrapper, table);
                            wrapper.appendChild(table);
                        }
                    });
                    
                    // Check if message is long or contains tables - add expand functionality
                    const hasTable = messageDiv.querySelector('table');
                    const isLongContent = messageDiv.scrollHeight > 400;
                    
                    if (hasTable || isLongContent) {
                        messageDiv.classList.add('expandable', 'collapsed');
                        
                        const expandBtn = document.createElement('button');
                        expandBtn.className = 'message-expand-btn';
                        expandBtn.textContent = 'Expand';
                        expandBtn.onclick = () => this.toggleMessageExpand(messageDiv, expandBtn);
                        messageDiv.appendChild(expandBtn);
                    }
                }
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            },

            toggleMessageExpand(messageDiv, button) {
                const isCollapsed = messageDiv.classList.contains('collapsed');
                
                if (isCollapsed) {
                    messageDiv.classList.remove('collapsed');
                    button.textContent = 'Collapse';
                    button.classList.add('expanded');
                } else {
                    messageDiv.classList.add('collapsed');
                    button.textContent = 'Expand';
                    button.classList.remove('expanded');
                    // Scroll to top of message when collapsing
                    messageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            },

            toggleSources(button) {
                const sourcesList = button.nextElementSibling;
                const isExpanded = sourcesList.classList.contains('expanded');
                
                if (isExpanded) {
                    sourcesList.classList.remove('expanded');
                    button.classList.remove('expanded');
                } else {
                    sourcesList.classList.add('expanded');
                    button.classList.add('expanded');
                }
            },

            showToast(message, type = 'info') {
                // Create a simple toast notification
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 6px;
                    color: white;
                    font-size: 14px;
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                    max-width: 400px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                `;
                
                const colors = {
                    success: '#10b981',
                    error: '#ef4444',
                    info: '#3b82f6',
                    warning: '#f59e0b'
                };
                
                toast.style.background = colors[type] || colors.info;
                toast.textContent = message;
                
                document.body.appendChild(toast);
                // Announce via live region
                const sr = document.getElementById('srLive');
                if (sr) sr.textContent = message;
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            },

            saveAIActionLog() {
                try {
                    localStorage.setItem('aiActionLog', JSON.stringify(this.aiActionLog));
                } catch (error) {
                    console.error('Error saving AI action log:', error);
                }
            },

            loadAIActionLog() {
                try {
                    const stored = localStorage.getItem('aiActionLog');
                    if (stored) {
                        this.aiActionLog = JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Error loading AI action log:', error);
                    this.aiActionLog = [];
                }
            },

            // Action log UI helpers
            toggleAIActionPanel() {
                const panel = document.getElementById('actionLogPanel');
                if (!panel) return;
                const isHidden = panel.classList.contains('hidden');
                if (isHidden) this.renderActionLogList();
                panel.classList.toggle('hidden');
            },

            renderActionLogList() {
                const list = document.getElementById('actionLogList');
                if (!list) return;
                if (!this.aiActionLog || this.aiActionLog.length === 0) {
                    list.innerHTML = '<div style="color:var(--text-muted); font-size:12px;">No AI actions yet.</div>';
                } else {
                    list.innerHTML = this.aiActionLog.slice().reverse().map((entry, idx) => {
                        const approvedLabel = entry.approved ? '<span style="color:var(--success); font-weight:600;">Approved</span>' : '<span style="color:var(--danger); font-weight:600;">Rejected</span>';
                        const when = new Date(entry.approvedAt || entry.rejectedAt || entry.timestamp).toLocaleString();
                        return `
                        <div style="background:var(--surface-alt); padding:10px; border-radius:6px; margin-bottom:8px; font-size:12px;">
                            <div style="display:flex; justify-content:space-between; align-items:start; gap:8px;">
                                <div style="flex:1; color:var(--text-secondary);">
                                    <div style="font-weight:600;">${this.getActionTypeLabel(entry.actionType)}</div>
                                    <div style="margin-top:4px; color:var(--text-muted);">Reason: ${entry.reason || '—'}</div>
                                </div>
                                <div>${approvedLabel}</div>
                            </div>
                            <div style="color:var(--text-muted); font-size:10px; margin-top:6px;">${when}</div>
                        </div>`;
                    }).join('');
                }
                const total = document.getElementById('aiActionTotal');
                if (total) total.textContent = String(this.aiActionLog.length);
            },

            updateActionLogCounter() {
                const badge = document.getElementById('aiActionCount');
                if (badge) badge.textContent = String(this.aiActionLog?.length || 0);
            },

            async clearAIActionLog() {
                const ok = await this.showConfirm({ title: 'Clear AI action logs?', message: 'This will remove all entries from the action log.', confirmText: 'Clear', cancelText: 'Cancel', variant: 'danger' });
                if (!ok) return;
                this.aiActionLog = [];
                this.saveAIActionLog();
                this.renderActionLogList();
                this.updateActionLogCounter();
            },

            exportAIActionLog() {
                const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(this.aiActionLog, null, 2));
                const a = document.createElement('a');
                a.setAttribute('href', dataStr);
                a.setAttribute('download', 'ai_action_log.json');
                document.body.appendChild(a);
                a.click();
                a.remove();
            },

            // AI Learning Functions
            analyzeLearningPatterns() {
                const patterns = {
                    approvalCount: 0,
                    rejectionCount: this.rejectedLinks.length / 2, // Divide by 2 because we store bidirectional
                    commonApprovedCategories: new Map(),
                    commonRejectionReasons: new Map(),
                    commonApprovedTypes: { dependency: 0, complements: 0 },
                    commonTimelinePairs: new Map()
                };

                // Analyze approved links
                this.features.forEach(feature => {
                    (feature.timelineItems || []).forEach(item => {
                        if (item.linkedItems && item.linkedItems.length > 0) {
                            item.linkedItems.forEach(link => {
                                if (link.direction === 'outgoing') { // Count only outgoing to avoid double-counting
                                    patterns.approvalCount++;

                                    // Track relationship types
                                    if (link.relationshipType === 'dependency') {
                                        patterns.commonApprovedTypes.dependency++;
                                    } else {
                                        patterns.commonApprovedTypes.complements++;
                                    }

                                    // Track timeline pairs (e.g., MVP→SHORT)
                                    const targetFeature = this.features.find(f => f.id === link.linkedFeatureId);
                                    const targetItem = targetFeature?.timelineItems.find(i => i.id === link.linkedItemId);
                                    if (targetItem) {
                                        const pairKey = `${item.timeline}→${targetItem.timeline}`;
                                        patterns.commonTimelinePairs.set(pairKey, (patterns.commonTimelinePairs.get(pairKey) || 0) + 1);
                                    }

                                    // Track categories
                                    (item.category || []).forEach(cat => {
                                        patterns.commonApprovedCategories.set(cat, (patterns.commonApprovedCategories.get(cat) || 0) + 1);
                                    });
                                }
                            });
                        }
                    });
                });

                // Analyze rejection reasons
                this.rejectedLinks.forEach(rejection => {
                    if (rejection.rejectionReason) {
                        patterns.commonRejectionReasons.set(
                            rejection.rejectionReason,
                            (patterns.commonRejectionReasons.get(rejection.rejectionReason) || 0) + 1
                        );
                    }
                });

                return patterns;
            },

            buildLearningContext() {
                const patterns = this.analyzeLearningPatterns();

                if (patterns.approvalCount === 0 && patterns.rejectionCount === 0) {
                    return ''; // No learning data yet
                }

                let context = '\n\n## LEARNING FROM PAST DECISIONS\n\n';

                context += `You have learned from ${patterns.approvalCount} approved and ${patterns.rejectionCount} rejected link suggestions.\n\n`;

                // Approved patterns
                if (patterns.approvalCount > 0) {
                    context += '**Approved Patterns (prioritize similar):**\n';

                    // Most common relationship type
                    const preferredType = patterns.commonApprovedTypes.dependency > patterns.commonApprovedTypes.complements
                        ? `dependency links (${patterns.commonApprovedTypes.dependency} approved)`
                        : `complements links (${patterns.commonApprovedTypes.complements} approved)`;
                    context += `- User prefers ${preferredType}\n`;

                    // Most common timeline pairs
                    if (patterns.commonTimelinePairs.size > 0) {
                        const topPairs = Array.from(patterns.commonTimelinePairs.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3);
                        context += '- Common timeline connections:\n';
                        topPairs.forEach(([pair, count]) => {
                            context += `  • ${pair} (${count} links)\n`;
                        });
                    }

                    // Most common categories
                    if (patterns.commonApprovedCategories.size > 0) {
                        const topCategories = Array.from(patterns.commonApprovedCategories.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5);
                        context += '- Frequently linked categories: ' + topCategories.map(([cat]) => cat).join(', ') + '\n';
                    }

                    context += '\n';
                }

                // Rejection patterns
                if (patterns.rejectionCount > 0 && patterns.commonRejectionReasons.size > 0) {
                    context += '**Rejection Patterns (avoid similar):**\n';
                    const topReasons = Array.from(patterns.commonRejectionReasons.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);

                    topReasons.forEach(([reason, count]) => {
                        const reasonLabel = {
                            'not-related': 'Items not related to each other',
                            'wrong-type': 'Wrong relationship type selected',
                            'timeline-mismatch': 'Timeline phases don\'t align',
                            'already-covered': 'Link already covered elsewhere',
                            'other': 'Other miscellaneous reasons'
                        }[reason] || reason;
                        context += `- ${reasonLabel} (${count} rejections)\n`;
                    });
                }

                return context;
            },

            async approveAllLinkSuggestions() {
                let skippedCount = 0;

                this.linkSuggestions.forEach(suggestion => {
                    // Skip same-feature links
                    if (suggestion.sourceFeatureId === suggestion.targetFeatureId) {
                        console.warn(`Skipping same-feature link during bulk approve`);
                        skippedCount++;
                        return;
                    }

                    const sourceFeature = this.features.find(f => f.id === suggestion.sourceFeatureId);
                    const targetFeature = this.features.find(f => f.id === suggestion.targetFeatureId);
                    const sourceItem = sourceFeature?.timelineItems.find(i => i.id === suggestion.sourceItemId);
                    const targetItem = targetFeature?.timelineItems.find(i => i.id === suggestion.targetItemId);

                    if (sourceItem && targetItem) {
                        if (!sourceItem.linkedItems) sourceItem.linkedItems = [];
                        if (!targetItem.linkedItems) targetItem.linkedItems = [];

                        sourceItem.linkedItems.push({
                            linkedItemId: suggestion.targetItemId,
                            linkedFeatureId: suggestion.targetFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'outgoing'
                        });

                        targetItem.linkedItems.push({
                            linkedItemId: suggestion.sourceItemId,
                            linkedFeatureId: suggestion.sourceFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'incoming'
                        });
                    }
                });

                this.saveData();
                this.linkSuggestions = [];
                this.saveLinkSuggestions();
                this.renderLinkSuggestions();
                this.updateLinkNotification();
                this.renderTable();

                if (skippedCount > 0) {
                    await this.showAlert({ title:'Links approved', message:`Skipped ${skippedCount} invalid same-feature link(s).` , variant:'warning'});
                } else {
                    this.showToast('Links approved', 'success');
                }
            },

            async rejectAllLinkSuggestions() {
                const ok = await this.showConfirm({ title:'Reject all link suggestions?', message:'This cannot be undone.', confirmText:'Reject all', cancelText:'Cancel', variant:'danger' });
                if (ok) {
                    // Add all suggestions to rejected links before clearing
                    this.linkSuggestions.forEach(suggestion => {
                        this.rejectedLinks.push({
                            sourceItemId: suggestion.sourceItemId,
                            targetItemId: suggestion.targetItemId,
                            rejectionReason: 'bulk-reject',
                            rejectionNotes: 'Rejected via bulk action',
                            originalType: suggestion.type,
                            originalConfidence: suggestion.confidence,
                            timestamp: new Date().toISOString()
                        });
                        this.rejectedLinks.push({
                            sourceItemId: suggestion.targetItemId,
                            targetItemId: suggestion.sourceItemId,
                            rejectionReason: 'bulk-reject',
                            rejectionNotes: 'Rejected via bulk action',
                            originalType: suggestion.type,
                            originalConfidence: suggestion.confidence,
                            timestamp: new Date().toISOString()
                        });
                    });
                    this.saveRejectedLinks();

                    this.linkSuggestions = [];
                    this.saveLinkSuggestions();
                    this.renderLinkSuggestions();
                    this.updateLinkNotification();
                }
            },

            renderMemorySuggestions() {
                const container = document.getElementById('memorySuggestionsList');
                if (!container) return;

                if (this.memorySuggestions.length === 0) {
                    container.innerHTML = '<div style="color:rgba(255,255,255,0.8); font-size:12px; padding:10px; text-align:center;">No suggestions</div>';
                    return;
                }

                let html = `
                    <div style="padding:12px; background:rgba(255,255,255,0.1); border-radius:6px; margin-bottom:12px; font-size:11px; color:rgba(255,255,255,0.9); line-height:1.5;">
                        <strong>💡 How Memory Suggestions Work:</strong><br>
                        • Generated automatically every 5 messages<br>
                        • AI analyzes your conversation for valuable knowledge points<br>
                        • When you approve, items are added to permanent memory<br>
                        • Memory is included in every AI conversation to provide context<br>
                        • Memory persists across conversations (even after starting new chats)
                    </div>
                `;

                this.memorySuggestions.forEach(suggestion => {
                    html += `
                        <div class="memory-suggestion-item">
                            <div class="memory-suggestion-content">${suggestion.content}</div>
                            <div class="memory-suggestion-actions">
                                <button class="memory-suggestion-btn approve" onclick="app.approveSuggestion('${suggestion.id}')" title="Approve">✓</button>
                                <button class="memory-suggestion-btn reject" onclick="app.rejectSuggestion('${suggestion.id}')" title="Reject">✗</button>
                            </div>
                        </div>
                    `;
                });

                html += `
                    <div class="memory-notification-bulk-actions">
                        <button onclick="app.approveAllSuggestions()">✓ Approve All</button>
                        <button onclick="app.rejectAllSuggestions()">✗ Reject All</button>
                    </div>
                `;

                container.innerHTML = html;
            },

            updateSuggestionNotification() {
                const notification = document.getElementById('memoryNotification');
                const count = document.getElementById('suggestionCount');

                if (count) {
                    count.textContent = this.memorySuggestions.length;
                }

                if (notification) {
                    if (this.memorySuggestions.length > 0) {
                        notification.classList.remove('hidden');
                    } else {
                        notification.classList.add('hidden');
                        document.getElementById('memorySuggestionsList')?.classList.remove('active');
                    }
                }
            },

            showMemoryAnalysisToast(message, duration = 3000) {
                // Remove any existing toast
                const existingToast = document.querySelector('.memory-analysis-toast');
                if (existingToast) {
                    existingToast.classList.add('fade-out');
                    setTimeout(() => existingToast.remove(), 300);
                }

                // Create new toast
                const toast = document.createElement('div');
                toast.className = 'memory-analysis-toast';
                toast.innerHTML = `<span>${message}</span>`;
                document.body.appendChild(toast);

                // Remove after duration
                setTimeout(() => {
                    toast.classList.add('fade-out');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            },

            async analyzeConversationForMemory() {
                if (!this.apiKey || this.conversationHistory.length < 5) return;

                // Show toast when analysis starts
                this.showMemoryAnalysisToast('🔍 Analyzing conversation for memory suggestions...', 2000);

                try {
                    // Get last 5 messages for analysis
                    const recentMessages = this.conversationHistory.slice(-5);

                    const analysisPrompt = `Analyze this conversation and identify 2-3 valuable knowledge points that should be remembered for future conversations.

CONTEXT: The user is building a comprehensive trade platform that integrates sourcing, payments, research, customs, chat, logistics, and last mile delivery into a single unified platform.

Focus on:
- Platform vision details and scope
- User preferences and requirements
- Project-specific details (integrations, features, tech stack)
- Architectural or design decisions
- Important constraints or requirements
- Specific use cases or workflows
- Competitive insights and market positioning
- Feature priorities and roadmap decisions

Return ONLY a numbered list of knowledge points, one per line. Each point should be concise (1 sentence max).
Example format:
1. User prefers microservices architecture for scalability
2. Project uses Stripe for payment processing
3. Authentication requires OAuth2 with Google provider
4. Platform focuses on SME market segment

Recent conversation:
${recentMessages.map(m => `${m.role}: ${m.content}`).join('\n\n')}`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'user', content: analysisPrompt }
                            ],
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) return;

                    const data = await response.json();
                    const analysisResult = data.choices[0].message.content;

                    // Parse numbered list
                    let suggestionsFound = 0;
                    const lines = analysisResult.split('\n').filter(line => line.trim());
                    lines.forEach(line => {
                        // Remove numbering and extract content
                        const match = line.match(/^\d+\.\s*(.+)$/);
                        if (match && match[1]) {
                            const content = match[1].trim();
                            // Check if not already in suggestions or memory
                            const isDuplicate =
                                this.memorySuggestions.some(s => s.content === content) ||
                                this.memory.some(m => m.content === content);

                            if (!isDuplicate && content.length > 10) {
                                this.addMemorySuggestion(content);
                                suggestionsFound++;
                            }
                        }
                    });

                    // Show completion toast
                    if (suggestionsFound > 0) {
                        this.showMemoryAnalysisToast(`✅ Found ${suggestionsFound} new memory suggestion${suggestionsFound !== 1 ? 's' : ''}`, 3000);
                    } else {
                        this.showMemoryAnalysisToast('✅ Analysis complete - no new suggestions', 2000);
                    }

                } catch (error) {
                    console.error('Memory analysis error:', error);
                    this.showMemoryAnalysisToast('❌ Analysis failed', 2000);
                }
            },

            formatFeaturesForContext() {
                if (!this.features || this.features.length === 0) {
                    return 'No features have been added to the roadmap yet.';
                }

                let formatted = `CURRENT ROADMAP FEATURES (${this.features.length} feature${this.features.length !== 1 ? 's' : ''}):\n\n`;
                
                this.features.forEach((feature, index) => {
                    formatted += `FEATURE ${index + 1}: "${feature.name}" (${feature.type || 'Feature'})\n`;
                    formatted += `  Purpose: ${feature.purpose || 'Not specified'}\n`;
                    
                    if (feature.timelineItems && feature.timelineItems.length > 0) {
                        formatted += `  Timeline Breakdown:\n`;
                        feature.timelineItems.forEach((item, itemIndex) => {
                            formatted += `    ${itemIndex + 1}. ${item.timeline || 'N/A'} Phase - ${item.difficulty || 'N/A'} Difficulty\n`;
                            if (item.usp) formatted += `       USP: ${item.usp}\n`;
                            if (item.integrationType) formatted += `       Integration Type: ${item.integrationType}\n`;
                            if (item.category && item.category.length > 0) {
                                formatted += `       Categories: ${item.category.join(', ')}\n`;
                            }
                        });
                    }
                    
                    if (feature.summary) {
                        formatted += `  AI Summary:\n`;
                        if (feature.summary.usp) formatted += `    USP: ${feature.summary.usp}\n`;
                        if (feature.summary.integrationType) formatted += `    Integration: ${feature.summary.integrationType}\n`;
                    }
                    
                    formatted += '\n';
                });
                
                return formatted;
            },

            showAddModal() {
                this.editingId = null;
                this.currentTimelineItems = [{
                    id: Date.now().toString(),
                    timeline: '',
                    difficulty: '',
                    usp: '',
                    integrationType: '',
                    category: []
                }];
                document.getElementById('modalTitle').textContent = 'Add Feature';
                document.getElementById('featureForm').reset();
                this.renderTimelineItems();
                // Setup category inputs after DOM is ready
                setTimeout(() => this.setupAllCategoryInputs(), 0);
                const modal = document.getElementById('featureModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                modal.classList.add('active');
                this._featureModalRelease = this.trapFocus(modal.querySelector('.modal-content') || modal);
            },

            showEditModal(id) {
                const feature = this.features.find(f => f.id === id);
                if (!feature) return;

                this.editingId = id;
                this.currentTimelineItems = feature.timelineItems ? JSON.parse(JSON.stringify(feature.timelineItems)) : [{
                    id: Date.now().toString(),
                    timeline: '',
                    difficulty: '',
                    usp: '',
                    integrationType: '',
                    category: []
                }];

                document.getElementById('modalTitle').textContent = 'Edit Feature';
                document.getElementById('featureName').value = feature.name;
                document.getElementById('featureType').value = feature.type || 'Feature';
                document.getElementById('featurePurpose').value = feature.purpose || '';

                this.renderTimelineItems();
                // Setup category inputs after DOM is ready
                setTimeout(() => this.setupAllCategoryInputs(), 0);
                const modal = document.getElementById('featureModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                modal.classList.add('active');
                this._featureModalRelease = this.trapFocus(modal.querySelector('.modal-content') || modal);
            },

            closeModal() {
                document.getElementById('featureModal').classList.remove('active');
                if (this._featureModalRelease) { this._featureModalRelease(); this._featureModalRelease = null; }
                // Reset saving flag if modal is closed
                this.isSavingFeature = false;
                // Reset save button state
                const saveButton = document.querySelector('#featureModal button[type="submit"]');
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = 'Save Feature';
                    saveButton.style.opacity = '';
                    saveButton.style.cursor = '';
                }
            },

            async summarizeTimelineItems(timelineItems) {
                // If only one item or no API key, return simple concatenation
                if (timelineItems.length === 1 || !this.apiKey) {
                    return {
                        usp: timelineItems.map(item => item.usp).filter(u => u).join('; ') || '-',
                        integrationType: timelineItems.map(item => item.integrationType).filter(i => i).join('; ') || '-'
                    };
                }

                try {
                    const usps = timelineItems.map((item, idx) =>
                        `${item.timeline}: ${item.usp || 'N/A'}`
                    ).join('\n');

                    const integrations = timelineItems.map((item, idx) =>
                        `${item.timeline}: ${item.integrationType || 'N/A'}`
                    ).join('\n');

                    const prompt = `Summarize the following feature roadmap data into concise single-line summaries (max 100 characters each):

USPs by timeline:
${usps}

Integration types by timeline:
${integrations}

Provide ONLY two lines in your response:
1. USP: [combined summary of all USPs showing progression]
2. Integration: [combined summary of all integration approaches]`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        throw new Error('API call failed');
                    }

                    const data = await response.json();
                    const result = data.choices[0].message.content;

                    // Parse the response
                    const lines = result.split('\n');
                    let usp = '-';
                    let integrationType = '-';

                    lines.forEach(line => {
                        if (line.toLowerCase().startsWith('1. usp:') || line.toLowerCase().startsWith('usp:')) {
                            usp = line.replace(/^(\d+\.\s*)?usp:\s*/i, '').trim();
                        } else if (line.toLowerCase().startsWith('2. integration:') || line.toLowerCase().startsWith('integration:')) {
                            integrationType = line.replace(/^(\d+\.\s*)?integration:\s*/i, '').trim();
                        }
                    });

                    return { usp, integrationType };

                } catch (error) {
                    console.error('Summarization error:', error);
                    // Fallback to simple concatenation
                    return {
                        usp: timelineItems.map(item => item.usp).filter(u => u).join('; ') || '-',
                        integrationType: timelineItems.map(item => item.integrationType).filter(i => i).join('; ') || '-'
                    };
                }
            },

            async analyzeBatchLinks(evt) {
                if (!this.apiKey) {
                    await this.showAlert({ title:'API key required', message:'Please set your OpenRouter API key first (Chat panel → Settings).', variant:'warning' });
                    return;
                }

                if (this.features.length < 2) {
                    await this.showAlert({ title:'Not enough features', message:'You need at least 2 features to analyze links.' });
                    return;
                }

                // Show loading state
                const button = (evt && evt.currentTarget) ? evt.currentTarget : (typeof event !== 'undefined' ? event.target : null);
                const originalText = button.textContent;
                button.textContent = '🔄 Analyzing...';
                button.disabled = true;

                try {
                    // Collect all timeline items from all features
                    const allItems = [];
                    this.features.forEach(feature => {
                        feature.timelineItems.forEach(item => {
                            allItems.push({
                                featureId: feature.id,
                                featureName: feature.name,
                                featureType: feature.type,
                                featurePurpose: feature.purpose,
                                itemId: item.id,
                                timeline: item.timeline,
                                difficulty: item.difficulty,
                                usp: item.usp,
                                integrationType: item.integrationType,
                                categories: item.category.join(', ')
                            });
                        });
                    });

                    // Build the analysis prompt - group by feature to make it clearer
                    const featureGroups = {};
                    allItems.forEach(item => {
                        if (!featureGroups[item.featureId]) {
                            featureGroups[item.featureId] = {
                                name: item.featureName,
                                type: item.featureType,
                                purpose: item.featurePurpose,
                                id: item.featureId,
                                items: []
                            };
                        }
                        featureGroups[item.featureId].items.push(item);
                    });

                    const itemsDescription = Object.values(featureGroups).map((feature, idx) => {
                        const items = feature.items.map(item =>
                            `     - Timeline: ${item.timeline}, Difficulty: ${item.difficulty}, ItemID: ${item.itemId}\n       USP: ${item.usp}\n       Integration: ${item.integrationType}\n       Categories: ${item.categories}`
                        ).join('\n');

                        return `
FEATURE ${idx + 1}: "${feature.name}" (${feature.type})
FeatureID: ${feature.id}
Purpose: ${feature.purpose}
Timeline Items (DO NOT LINK THESE TOGETHER):
${items}`;
                    }).join('\n\n');

                    const prompt = `Analyze the following roadmap timeline items and identify potential relationships BETWEEN DIFFERENT FEATURES ONLY.

IMPORTANT: Do NOT suggest links between timeline items of the same feature. Timeline items within a feature are already connected by design.

Focus on cross-feature relationships:
- Dependencies: Items from different features where one must be completed before another (e.g., Feature A's SHORT depends on Feature B's MVP)
- Complements: Items from different features that work well together or enhance each other

For each relationship, provide:
1. Source item ID (depends on or complements from)
2. Target item ID (the item being depended on or complemented)
3. Relationship type: "dependency" or "complements"
4. Brief reason (1 sentence max)
5. Confidence: "high", "medium", or "low"

Only suggest relationships with medium or high confidence.
CRITICAL: Source and target must be from DIFFERENT features.

TIMELINE ITEMS:
${itemsDescription}${this.buildLearningContext()}

Return ONLY a valid JSON array with this exact format:
[
  {
    "sourceItemId": "12345",
    "targetItemId": "67890",
    "type": "dependency",
    "reason": "Authentication required before user profiles",
    "confidence": "high"
  }
]

If no relationships found, return: []`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        throw new Error('API call failed');
                    }

                    const data = await response.json();
                    let result = data.choices[0].message.content.trim();

                    // Clean up the response - remove markdown code blocks if present
                    result = result.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                    // Parse the JSON
                    const suggestions = JSON.parse(result);

                    if (!Array.isArray(suggestions)) {
                        throw new Error('Invalid response format');
                    }

                    // Filter out low confidence suggestions, same-feature links, and duplicates
                    const validSuggestions = suggestions.filter(s => {
                        if (s.confidence === 'low') return false;

                        // Extra safety: ensure source and target are from different features
                        const sourceInfo = allItems.find(i => i.itemId === s.sourceItemId);
                        const targetInfo = allItems.find(i => i.itemId === s.targetItemId);

                        if (!sourceInfo || !targetInfo) return false;

                        // Skip if same feature
                        if (sourceInfo.featureId === targetInfo.featureId) {
                            console.log(`Skipping same-feature link: ${sourceInfo.featureName} - ${sourceInfo.timeline} → ${targetInfo.timeline}`);
                            return false;
                        }

                        // Check if already rejected (both directions)
                        const isRejected = this.rejectedLinks.some(rl =>
                            (rl.sourceItemId === s.sourceItemId && rl.targetItemId === s.targetItemId) ||
                            (rl.sourceItemId === s.targetItemId && rl.targetItemId === s.sourceItemId)
                        );
                        if (isRejected) {
                            console.log(`Skipping previously rejected link: ${sourceInfo.featureName} (${sourceInfo.timeline}) ↔ ${targetInfo.featureName} (${targetInfo.timeline})`);
                            return false;
                        }

                        // Check if already approved (exists in linkedItems)
                        const sourceFeature = this.features.find(f => f.id === sourceInfo.featureId);
                        const sourceItem = sourceFeature?.timelineItems.find(i => i.id === s.sourceItemId);

                        if (sourceItem?.linkedItems) {
                            const alreadyLinked = sourceItem.linkedItems.some(link =>
                                link.linkedItemId === s.targetItemId
                            );
                            if (alreadyLinked) {
                                console.log(`Skipping already approved link: ${sourceInfo.featureName} (${sourceInfo.timeline}) → ${targetInfo.featureName} (${targetInfo.timeline})`);
                                return false;
                            }
                        }

                        return true;
                    });

                    if (validSuggestions.length === 0) {
                        await this.showAlert({ title:'Analysis complete', message:'No new cross-feature relationships found.' });
                        button.textContent = originalText;
                        button.disabled = false;
                        return;
                    }

                    // Add to link suggestions
                    validSuggestions.forEach(suggestion => {
                        // Find the items to get feature IDs
                        const sourceInfo = allItems.find(i => i.itemId === suggestion.sourceItemId);
                        const targetInfo = allItems.find(i => i.itemId === suggestion.targetItemId);

                        if (sourceInfo && targetInfo) {
                            this.linkSuggestions.push({
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                sourceFeatureId: sourceInfo.featureId,
                                targetFeatureId: targetInfo.featureId,
                                sourceItemId: suggestion.sourceItemId,
                                targetItemId: suggestion.targetItemId,
                                type: suggestion.type,
                                reason: suggestion.reason,
                                confidence: suggestion.confidence,
                                timestamp: new Date().toISOString()
                            });
                        }
                    });

                    this.saveLinkSuggestions();
                    this.updateLinkNotification();

                    await this.showAlert({ title:'Analysis complete', message:`Found ${validSuggestions.length} potential link(s). Check the notification bar to review and approve them.` });

                } catch (error) {
                    console.error('Link analysis error:', error);
                    await this.showAlert({ title:'Analysis error', message: error.message, variant:'danger' });
                } finally {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            },

            async saveFeature(event) {
                event.preventDefault();

                // Prevent double-clicks
                if (this.isSavingFeature) {
                    return;
                }

                // Validate timeline items
                if (this.currentTimelineItems.length === 0) {
                    await this.showAlert({ title:'Add timeline item', message:'Please add at least one timeline item!' });
                    return;
                }

                // Validate each timeline item has required fields
                for (let item of this.currentTimelineItems) {
                    if (!item.timeline || !item.difficulty) {
                        await this.showAlert({ title:'Missing fields', message:'Please fill in Timeline and Difficulty for all timeline items!' });
                        return;
                    }
                }

                // Set saving flag and disable button
                this.isSavingFeature = true;
                const saveButton = event.target.closest('form')?.querySelector('button[type="submit"]');
                const originalText = saveButton?.textContent || 'Save Feature';
                if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = 'Saving...';
                    saveButton.style.opacity = '0.6';
                    saveButton.style.cursor = 'not-allowed';
                }

                try {
                    // Generate AI summaries
                    const summaries = await this.summarizeTimelineItems(this.currentTimelineItems);

                    const feature = {
                        id: this.editingId || Date.now().toString(),
                        name: document.getElementById('featureName').value,
                        type: document.getElementById('featureType').value,
                        purpose: document.getElementById('featurePurpose').value,
                        workspaceId: this.currentWorkspaceId,
                        timelineItems: JSON.parse(JSON.stringify(this.currentTimelineItems)),
                        summary: summaries,
                        createdAt: this.editingId ?
                            this.features.find(f => f.id === this.editingId).createdAt :
                            new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    if (this.editingId) {
                        const index = this.features.findIndex(f => f.id === this.editingId);
                        if (index !== -1) {
                            this.features[index] = feature;
                        }
                    } else {
                        // Check if feature already exists (prevent duplicates)
                        const existingFeature = this.features.find(f => 
                            f.name === feature.name && 
                            f.type === feature.type &&
                            Math.abs(new Date(f.createdAt).getTime() - new Date(feature.createdAt).getTime()) < 2000
                        );
                        if (!existingFeature) {
                            this.features.push(feature);
                        }
                    }

                    // Add all categories from timeline items to allTags
                    feature.timelineItems.forEach(item => {
                        item.category.forEach(c => this.allTags.add(c));
                    });

                    this.saveData();
                    this.closeModal();
                    this.renderTable();
                } catch (error) {
                    console.error('Save feature error:', error);
                    await this.showAlert({ title:'Save error', message:'Failed to save feature. Please try again.', variant:'danger' });
                } finally {
                    // Reset saving flag and re-enable button
                    this.isSavingFeature = false;
                    if (saveButton) {
                        saveButton.disabled = false;
                        saveButton.textContent = originalText;
                        saveButton.style.opacity = '';
                        saveButton.style.cursor = '';
                    }
                }
            },

            async deleteFeature(id) {
                const f = this.features.find(x => x.id === id);
                const ok = await this.showConfirm({ title: 'Delete feature?', message: `Delete "${f?.name || 'this feature'}". This cannot be undone.`, confirmText: 'Delete', cancelText: 'Cancel', variant: 'danger' });
                if (!ok) return;
                this.features = this.features.filter(f => f.id !== id);
                this.saveData();
                this.renderTable();
            },

            setupTagInput() {
                const input = document.getElementById('tagInput');
                const suggestions = document.getElementById('tagSuggestions');

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const tag = input.value.trim();
                        if (tag && !this.currentTags.includes(tag)) {
                            this.currentTags.push(tag);
                            this.allTags.add(tag);
                            input.value = '';
                            this.renderTags();
                            suggestions.classList.remove('active');
                        }
                    }
                });

                input.addEventListener('input', (e) => {
                    const value = e.target.value.toLowerCase();
                    if (value.length > 0) {
                        const matching = Array.from(this.allTags)
                            .filter(t => t.toLowerCase().includes(value) && !this.currentTags.includes(t));

                        if (matching.length > 0) {
                            suggestions.innerHTML = matching
                                .map(t => `<div class="tag-suggestion-item" onclick="app.addTag('${t}')">${t}</div>`)
                                .join('');
                            suggestions.classList.add('active');
                        } else {
                            suggestions.classList.remove('active');
                        }
                    } else {
                        suggestions.classList.remove('active');
                    }
                });
            },

            getAllExistingCategories() {
                // Collect all categories from all features' timeline items with frequency
                const categoryCount = {};

                this.features.forEach(feature => {
                    if (feature.timelineItems) {
                        feature.timelineItems.forEach(item => {
                            if (item.category) {
                                item.category.forEach(cat => {
                                    categoryCount[cat] = (categoryCount[cat] || 0) + 1;
                                });
                            }
                        });
                    }
                });

                // Convert to array and sort by frequency (most frequent first)
                return Object.entries(categoryCount)
                    .sort((a, b) => b[1] - a[1])
                    .map(([category]) => category);
            },

            setupCategoryInput(itemId) {
                const input = document.getElementById(`timelineCategoryInput-${itemId}`);
                const suggestions = document.getElementById(`timelineCategorySuggestions-${itemId}`);

                if (!input || !suggestions) return;

                // Get current timeline item
                const currentItem = this.currentTimelineItems.find(i => i.id === itemId);
                if (!currentItem) return;

                input.addEventListener('input', (e) => {
                    const value = e.target.value.toLowerCase();
                    if (value.length > 0) {
                        const allCategories = this.getAllExistingCategories();
                        const matching = allCategories
                            .filter(cat =>
                                cat.toLowerCase().includes(value) &&
                                !currentItem.category.includes(cat)
                            );

                        if (matching.length > 0) {
                            suggestions.innerHTML = matching
                                .map(cat => `<div class="tag-suggestion-item" onclick="app.addCategoryFromSuggestion('${itemId}', '${cat}')">${cat}</div>`)
                                .join('');
                            suggestions.classList.add('active');
                        } else {
                            suggestions.classList.remove('active');
                        }
                    } else {
                        suggestions.classList.remove('active');
                    }
                });

                // Close suggestions on blur
                input.addEventListener('blur', () => {
                    // Delay to allow click on suggestion to register
                    setTimeout(() => suggestions.classList.remove('active'), 200);
                });
            },

            setupAllCategoryInputs() {
                // Setup autocomplete for all timeline item category inputs
                this.currentTimelineItems.forEach(item => {
                    this.setupCategoryInput(item.id);
                });
            },

            addCategoryFromSuggestion(itemId, category) {
                const input = document.getElementById(`timelineCategoryInput-${itemId}`);
                const suggestions = document.getElementById(`timelineCategorySuggestions-${itemId}`);

                this.addCategoryToTimelineItem(itemId, category);

                if (input) input.value = '';
                if (suggestions) suggestions.classList.remove('active');
            },

            addTag(tag) {
                if (!this.currentTags.includes(tag)) {
                    this.currentTags.push(tag);
                    document.getElementById('tagInput').value = '';
                    document.getElementById('tagSuggestions').classList.remove('active');
                    this.renderTags();
                }
            },

            removeTag(tag) {
                this.currentTags = this.currentTags.filter(t => t !== tag);
                this.renderTags();
            },

            renderTags() {
                const container = document.getElementById('tagInputContainer');
                const input = document.getElementById('tagInput');

                container.innerHTML = '';
                this.currentTags.forEach(tag => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'tag';
                    tagEl.innerHTML = `${tag} <span style="cursor:pointer; margin-left:5px;" onclick="app.removeTag('${tag}')">&times;</span>`;
                    container.appendChild(tagEl);
                });
                container.appendChild(input);
            },

            populateCategoryDropdown() {
                const select = document.getElementById('existingCategorySelect');
                if (!select) return;

                // Get all unique categories from existing features
                const existingCategories = new Set();
                this.features.forEach(f => {
                    if (f.tags && Array.isArray(f.tags)) {
                        f.tags.forEach(tag => existingCategories.add(tag));
                    }
                });

                // Also include tags from allTags
                this.allTags.forEach(tag => existingCategories.add(tag));

                // Clear and populate dropdown
                select.innerHTML = '<option value="">Select existing category...</option>';
                Array.from(existingCategories).sort().forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    select.appendChild(option);
                });
            },

            addCategoryFromSelect(value) {
                if (value) {
                    this.addTag(value);
                    document.getElementById('existingCategorySelect').value = '';
                }
            },

            // Timeline Items Management
            addTimelineItem() {
                const item = {
                    id: Date.now().toString(),
                    timeline: '',
                    difficulty: '',
                    usp: '',
                    integrationType: '',
                    category: []
                };
                this.currentTimelineItems.push(item);
                this.renderTimelineItems();
            },

            async removeTimelineItem(id) {
                if (this.currentTimelineItems.length <= 1) {
                    await this.showAlert({ title:'Cannot remove', message:'At least one timeline item is required!' });
                    return;
                }
                this.currentTimelineItems = this.currentTimelineItems.filter(i => i.id !== id);
                this.renderTimelineItems();
            },

            updateTimelineItem(id, field, value) {
                const item = this.currentTimelineItems.find(i => i.id === id);
                if (item) {
                    item[field] = value;
                }
            },

            addCategoryToTimelineItem(itemId, category) {
                const item = this.currentTimelineItems.find(i => i.id === itemId);
                if (item && !item.category.includes(category)) {
                    item.category.push(category);
                    this.renderTimelineItems();
                }
            },

            removeCategoryFromTimelineItem(itemId, category) {
                const item = this.currentTimelineItems.find(i => i.id === itemId);
                if (item) {
                    item.category = item.category.filter(c => c !== category);
                    this.renderTimelineItems();
                }
            },

            renderTimelineItems() {
                const container = document.getElementById('timelineItemsContainer');
                if (!container) return;

                container.innerHTML = this.currentTimelineItems.map((item, index) => `
                    <div style="background:var(--surface-alt); padding:15px; border-radius:8px; margin-bottom:15px; border:2px solid var(--border);">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                            <span style="font-weight:600; color:var(--text-secondary);">Timeline Item ${index + 1}</span>
                            ${this.currentTimelineItems.length > 1 ? `<button type="button" onclick="app.removeTimelineItem('${item.id}')" style="background:var(--danger); color:var(--text-inverse); border:none; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:12px;">Remove</button>` : ''}
                        </div>

                        <div style="display:grid; gap:10px;">
                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Timeline *</label>
                                <select onchange="app.updateTimelineItem('${item.id}', 'timeline', this.value)" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);" required>
                                    <option value="">Select timeline</option>
                                    <option value="MVP" ${item.timeline === 'MVP' ? 'selected' : ''}>MVP</option>
                                    <option value="SHORT" ${item.timeline === 'SHORT' ? 'selected' : ''}>SHORT</option>
                                    <option value="LONG" ${item.timeline === 'LONG' ? 'selected' : ''}>LONG</option>
                                </select>
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Difficulty *</label>
                                <select onchange="app.updateTimelineItem('${item.id}', 'difficulty', this.value)" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);" required>
                                    <option value="">Select difficulty</option>
                                    <option value="Easy" ${item.difficulty === 'Easy' ? 'selected' : ''}>Easy</option>
                                    <option value="Medium" ${item.difficulty === 'Medium' ? 'selected' : ''}>Medium</option>
                                    <option value="Hard" ${item.difficulty === 'Hard' ? 'selected' : ''}>Hard</option>
                                </select>
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">USP</label>
                                <textarea onchange="app.updateTimelineItem('${item.id}', 'usp', this.value)" placeholder="What makes this unique?" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; font-family:inherit; resize:vertical; min-height:60px; background:var(--surface); color:var(--text-primary);">${item.usp || ''}</textarea>
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Integration Type</label>
                                <input type="text" onchange="app.updateTimelineItem('${item.id}', 'integrationType', this.value)" value="${item.integrationType || ''}" placeholder="How will this be executed?" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);">
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Category</label>
                                <div style="display:flex; flex-wrap:wrap; gap:5px; margin-bottom:5px; min-height:32px; align-items:center;">
                                    ${item.category.map(cat => `<span class="tag">${cat} <span style="cursor:pointer; margin-left:5px;" onclick="app.removeCategoryFromTimelineItem('${item.id}', '${cat}')">&times;</span></span>`).join('')}
                                </div>
                                <div class="tag-suggestions" style="position:relative;">
                                    <input type="text" id="timelineCategoryInput-${item.id}" placeholder="Type and press Enter"
                                        onkeypress="if(event.key==='Enter'){event.preventDefault(); const val=this.value.trim(); if(val){app.addCategoryToTimelineItem('${item.id}', val); this.value='';}}"
                                        style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);">
                                    <div id="timelineCategorySuggestions-${item.id}" class="tag-suggestions-list"></div>
                                </div>
                            </div>

                            <!-- Link Management Section -->
                            <div class="timeline-item-links">
                                <div class="timeline-item-links-header">
                                    <h4>Linked Items</h4>
                                    <button type="button" class="add-link-btn" onclick="app.showAddLinkModal('${item.id}')">+ Add Link</button>
                                </div>
                                <div id="links-${item.id}">
                                    ${(item.linkedItems || []).map(link => {
                                        const linkedFeature = this.features.find(f => f.id === link.linkedFeatureId);
                                        const linkedItem = linkedFeature?.timelineItems.find(i => i.id === link.linkedItemId);
                                        if (!linkedFeature || !linkedItem) return '';
                                        const typeLabel = link.relationshipType === 'dependency' ? 'Dependency' : 'Complements';
                                        const typeClass = link.relationshipType === 'dependency' ? 'dependency' : 'complements';
                                        return `
                                            <div class="link-item">
                                                <div class="link-item-info">
                                                    <span class="link-item-type ${typeClass}">${typeLabel}</span>
                                                    <strong>${linkedFeature.name}</strong> (${linkedItem.timeline})
                                                    <div style="font-size:11px; color:var(--text-muted); margin-top:2px;">${link.reason || 'No description'}</div>
                                                </div>
                                                <button type="button" class="remove-link-btn" onclick="app.removeLink('${item.id}', '${link.linkedItemId}')">✗</button>
                                            </div>
                                        `;
                                    }).join('') || '<div style="color:var(--text-muted); font-size:12px; padding:8px;">No links yet</div>'}
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

                // Setup category inputs after DOM is updated
                setTimeout(() => this.setupAllCategoryInputs(), 0);
            },

            renderTable() {
                const tbody = document.getElementById('tableBody');
                const filtered = this.getFilteredFeatures();

                if (filtered.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="11" style="text-align:center; padding:40px; color:var(--text-muted);">No features found. Click "Add Feature" to get started!</td></tr>';
                    return;
                }

                // Get filter values
                const timelineFilter = document.getElementById('timelineFilter')?.value || '';
                const difficultyFilter = document.getElementById('difficultyFilter')?.value || '';

                tbody.innerHTML = filtered.map(feature => {
                    let timelineItems = feature.timelineItems || [];

                    // Filter timeline items based on active filters
                    if (timelineFilter) {
                        timelineItems = timelineItems.filter(item => item.timeline === timelineFilter);
                    }
                    if (difficultyFilter) {
                        timelineItems = timelineItems.filter(item => item.difficulty === difficultyFilter);
                    }

                    // Create vertical timeline badges
                    const timelineBadges = timelineItems.map(item =>
                        `<span class="badge badge-${item.timeline.toLowerCase()}" style="display:block; margin-bottom:4px;">${item.timeline}</span>`
                    ).join('');

                    // Create vertical difficulty badges (matching timeline order)
                    const difficultyBadges = timelineItems.map(item =>
                        `<span class="badge badge-${item.difficulty.toLowerCase()}" style="display:block; margin-bottom:4px;">${item.difficulty}</span>`
                    ).join('');

                    // Get all unique categories from filtered timeline items only
                    const allCategories = [...new Set(timelineItems.flatMap(item => item.category || []))];
                    const categoryTags = allCategories.map(c => `<span class="tag">${c}</span>`).join(' ');

                    // Get summaries or create fallback based on filtered timeline items
                    const summary = feature.summary || {
                        usp: timelineItems.map(item => item.usp).filter(u => u).join('; ') || '-',
                        integrationType: timelineItems.map(item => item.integrationType).filter(i => i).join('; ') || '-'
                    };

                    // Get linked items only from filtered timeline items
                    const allLinks = [];
                    timelineItems.forEach(item => {
                        if (item.linkedItems && item.linkedItems.length > 0) {
                            item.linkedItems.forEach(link => {
                                const linkedFeature = this.features.find(f => f.id === link.linkedFeatureId);
                                const linkedItem = linkedFeature?.timelineItems.find(i => i.id === link.linkedItemId);
                                if (linkedFeature && linkedItem) {
                                    allLinks.push({
                                        featureName: linkedFeature.name,
                                        timeline: linkedItem.timeline,
                                        type: link.relationshipType,
                                        direction: link.direction,
                                        reason: link.reason || 'No description provided'
                                    });
                                }
                            });
                        }
                    });

                    const linkedItemsBadges = allLinks.length > 0
                        ? allLinks.map(link => {
                            const typeClass = link.type === 'dependency' ? 'badge-mvp' : 'badge-short';
                            const arrow = link.direction === 'outgoing' ? '→' : '←';
                            const typeLabel = link.type === 'dependency' ? 'Dependency' : 'Complements';
                            const directionLabel = link.direction === 'outgoing' ? 'depends on' : 'is depended on by';
                            const tooltipText = `${typeLabel}: ${link.reason}`;
                            return `<span class="badge ${typeClass} linked-item-badge" style="display:block; margin-bottom:4px; font-size:11px; cursor:help;" title="${tooltipText}">${arrow} ${link.featureName} (${link.timeline})</span>`;
                        }).join('')
                        : '<span style="color:var(--text-muted);">-</span>';

                    // AI modification badges
                    const aiCreatedBadge = feature.aiCreated ? '<span class="badge" style="background:var(--primary); font-size:10px; margin-left:5px; color:var(--text-inverse);">AI Created</span>' : '';
                    const aiModifiedBadge = feature.aiModified ? '<span class="badge" style="background:var(--info); font-size:10px; margin-left:5px; color:var(--text-inverse);">AI Modified</span>' : '';
                    const isSelected = this.selectedFeatureIds.has(feature.id);
                    const safeName = (feature.name || '').replace(/"/g,'&quot;');
                    const nameCell = `
                        <div>
                            <span class="focus-ring" style="cursor:pointer; color: var(--primary);" onclick="app.showDetailView('${feature.id}')" ondblclick="app.startInlineEdit('${feature.id}','name','${safeName}')"><strong>${feature.name}</strong></span>
                            ${aiCreatedBadge}${aiModifiedBadge}
                        </div>`;
                    const typeCell = `
                        <select class="focus-ring" onchange="app.inlineUpdateType('${feature.id}', this.value)">
                            <option value="Feature" ${ (feature.type || 'Feature')==='Feature' ? 'selected' : ''}>Feature</option>
                            <option value="Service" ${ (feature.type || 'Feature')==='Service' ? 'selected' : ''}>Service</option>
                        </select>`;
                    const purposeCell = `<div class="clamp-2" title="${(feature.purpose || '').replace(/"/g,'&quot;')}">${feature.purpose || '-'}</div>`;
                    const uspCell = `<div class="clamp-2" title="${(summary.usp || '').replace(/"/g,'&quot;')}">${summary.usp}</div>`;
                    const integCell = `<div class="clamp-2" title="${(summary.integrationType || '').replace(/"/g,'&quot;')}">${summary.integrationType}</div>`;

                    return `
                        <tr>
                            <td><input type="checkbox" ${isSelected ? 'checked' : ''} onchange="app.toggleSelectOne('${feature.id}', this.checked)" aria-label="Select ${safeName}" class="focus-ring"></td>
                            <td>${nameCell}</td>
                            <td>${typeCell}</td>
                            <td style="padding:8px;">${timelineBadges || '-'}</td>
                            <td style="padding:8px;">${difficultyBadges || '-'}</td>
                            <td>${purposeCell}</td>
                            <td>${uspCell}</td>
                            <td>${integCell}</td>
                            <td>${categoryTags || '-'}</td>
                            <td style="padding:8px;">${linkedItemsBadges}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-secondary btn-icon" onclick="app.showDetailView('${feature.id}')" title="View details">👁️</button>
                                    <button class="btn-primary btn-icon" onclick="app.showEditModal('${feature.id}')">Edit</button>
                                    <button class="btn-danger btn-icon" onclick="app.deleteFeature('${feature.id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');

                // Update category filter dropdown with current categories
                this.populateCategoryFilter();
                this.updateBulkActionsBar();
            },

            // ==================== Detail View Navigation ====================

            showDetailView(featureId) {
                this.currentView = 'detail';
                // Reset enhancement mode if switching to a different feature
                if (this.currentFeatureId !== featureId) {
                    this.aiFeatureEnhancementMode = false;
                }
                this.currentFeatureId = featureId;
                this.currentTab = 'overview';

                // Update URL hash for shareable links and browser history
                window.location.hash = `feature/${featureId}`;

                // Toggle views
                document.getElementById('tableView').classList.add('hidden');
                document.getElementById('detailView').classList.remove('hidden');

                // Render the detail content
                this.renderFeatureDetail(featureId);
            },

            showTableView() {
                this.currentView = 'table';
                this.currentFeatureId = null;
                this.aiFeatureEnhancementMode = false; // Reset enhancement mode when leaving detail view

                // Clear URL hash
                window.location.hash = '';

                // Toggle views
                document.getElementById('detailView').classList.add('hidden');
                document.getElementById('tableView').classList.remove('hidden');

                // Refresh table
                this.renderTable();
            },

            switchDetailTab(tabName) {
                this.currentTab = tabName;

                // Update tab buttons
                document.querySelectorAll('.detail-tab').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');

                // Update tab content
                document.querySelectorAll('.detail-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tabName}Tab`).classList.add('active');
            },

            editFeatureFromDetail() {
                if (this.currentFeatureId) {
                    this.showTableView();
                    // Small delay to let the view transition complete
                    setTimeout(() => {
                        this.showEditModal(this.currentFeatureId);
                    }, 100);
                }
            },

            // ==================== Detail View Rendering ====================

            renderFeatureDetail(featureId) {
                const feature = this.features.find(f => f.id === featureId);
                if (!feature) {
                    this.showTableView();
                    return;
                }

                // Render header
                document.getElementById('detailFeatureName').textContent = feature.name;

                // Render badges
                const badgesHTML = `
                    <span class="badge badge-${feature.type.toLowerCase()}">${feature.type}</span>
                    ${feature.aiCreated ? '<span class="ai-badge">AI Created</span>' : ''}
                    ${feature.aiModified ? '<span class="ai-badge ai-modified">AI Modified</span>' : ''}
                `;
                document.getElementById('detailBadges').innerHTML = badgesHTML;

                // Render all tabs
                this.renderOverviewTab(feature);
                this.renderExecutionTab(feature);
                this.renderResourcesTab(feature);
                this.renderPlanningTab(feature);
                this.renderInspirationTab(feature);
            },

            renderOverviewTab(feature) {
                // Purpose
                document.getElementById('detailPurpose').textContent = feature.purpose || 'No purpose specified';

                // USP
                const usp = feature.summary?.usp || feature.timelineItems?.[0]?.usp || 'No USP specified';
                document.getElementById('detailUSP').textContent = usp;

                // Integration
                const integration = feature.summary?.integrationType || feature.timelineItems?.[0]?.integrationType || 'No integration type specified';
                document.getElementById('detailIntegration').textContent = integration;

                // Timeline Items
                const timelineContainer = document.getElementById('detailTimelineItems');
                if (feature.timelineItems && feature.timelineItems.length > 0) {
                    timelineContainer.innerHTML = feature.timelineItems.map(item => `
                        <div class="timeline-item-card">
                            <div class="timeline-item-header">
                                <div class="timeline-item-badges">
                                    <span class="badge badge-${item.timeline.toLowerCase()}">${item.timeline}</span>
                                    <span class="badge badge-${item.difficulty.toLowerCase()}">${item.difficulty}</span>
                                </div>
                            </div>
                            <div class="timeline-item-body">
                                <h4>USP</h4>
                                <p>${item.usp || 'N/A'}</p>
                                <h4>Integration Type</h4>
                                <p>${item.integrationType || 'N/A'}</p>
                                ${item.category && item.category.length > 0 ? `
                                    <div class="timeline-item-categories">
                                        ${item.category.map(cat => `<span class="tag">${cat}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `).join('');
                } else {
                    timelineContainer.innerHTML = '<p class="detail-text">No timeline items defined</p>';
                }

                // Linked Items
                const linkedContainer = document.getElementById('detailLinkedItems');
                const allLinkedItems = this.getAllLinkedItems(feature.id);

                if (allLinkedItems.length > 0) {
                    linkedContainer.innerHTML = allLinkedItems.map(link => {
                        const linkedFeature = this.features.find(f => f.id === link.linkedFeatureId);
                        if (!linkedFeature) return '';

                        const relationshipText = link.direction === 'outgoing'
                            ? `${link.relationshipType === 'dependency' ? 'Depends on' : 'Complements'}: ${link.reason}`
                            : `${link.relationshipType === 'dependency' ? 'Required by' : 'Complemented by'}: ${link.reason}`;

                        return `
                            <div class="linked-item" onclick="app.showDetailView('${linkedFeature.id}')">
                                <div class="linked-item-icon">${linkedFeature.name.substring(0, 2).toUpperCase()}</div>
                                <div class="linked-item-content">
                                    <h4>${linkedFeature.name}</h4>
                                    <p class="linked-item-relationship">${relationshipText}</p>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    linkedContainer.innerHTML = '<p class="detail-text">No linked features</p>';
                }
            },

            getAllLinkedItems(featureId) {
                const feature = this.features.find(f => f.id === featureId);
                if (!feature) return [];

                const links = [];

                // Get outgoing links from timeline items
                if (feature.timelineItems) {
                    feature.timelineItems.forEach(item => {
                        if (item.linkedItems) {
                            item.linkedItems.forEach(link => {
                                if (link.direction === 'outgoing') {
                                    links.push(link);
                                }
                            });
                        }
                    });
                }

                // Get incoming links from other features
                this.features.forEach(otherFeature => {
                    if (otherFeature.id === featureId) return;

                    if (otherFeature.timelineItems) {
                        otherFeature.timelineItems.forEach(item => {
                            if (item.linkedItems) {
                                item.linkedItems.forEach(link => {
                                    if (link.linkedFeatureId === featureId && link.direction === 'outgoing') {
                                        links.push({
                                            ...link,
                                            linkedFeatureId: otherFeature.id,
                                            direction: 'incoming'
                                        });
                                    }
                                });
                            }
                        });
                    }
                });

                return links;
            },

            renderExecutionTab(feature) {
                const container = document.getElementById('executionStepsList');
                const executionSteps = feature.executionSteps || [];

                if (executionSteps.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">📋</div>
                            <h3>No Execution Steps Yet</h3>
                            <p>Add steps manually or use AI to generate an execution plan</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = executionSteps
                    .sort((a, b) => (a.order || 0) - (b.order || 0))
                    .map((step, index) => `
                        <div class="execution-step">
                            <div class="step-number">${index + 1}</div>
                            <div class="step-content">
                                <h4>${step.title}</h4>
                                <p>${step.description}</p>
                                <div class="step-meta">
                                    ${step.estimatedHours ? `<span>⏱️ ${step.estimatedHours}h estimated</span>` : ''}
                                    ${step.completed ? '<span style="color: var(--success);">✓ Completed</span>' : ''}
                                </div>
                            </div>
                            <div class="step-actions">
                                <button onclick="app.toggleStepComplete('${feature.id}', '${step.id}')" title="${step.completed ? 'Mark incomplete' : 'Mark complete'}">
                                    ${step.completed ? '↩️' : '✓'}
                                </button>
                                <button onclick="app.deleteExecutionStep('${feature.id}', '${step.id}')" title="Delete step">🗑️</button>
                            </div>
                        </div>
                    `).join('');
            },

            renderResourcesTab(feature) {
                const container = document.getElementById('resourcesContent');
                const resources = feature.resources || {};

                if (!resources.teamRoles && !resources.technologies && !resources.estimatedBudget && !resources.estimatedHours) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">🛠️</div>
                            <h3>No Resources Defined</h3>
                            <p>Define required resources or let AI suggest them</p>
                        </div>
                    `;
                    return;
                }

                let html = '';

                // Team composition
                if (resources.teamRoles && resources.teamRoles.length > 0) {
                    html += `
                        <div class="resource-section">
                            <h3>👥 Team Composition</h3>
                            <div class="resource-list">
                                ${resources.teamRoles.map(role => `
                                    <div class="resource-item">
                                        <span class="resource-label">${role.role}</span>
                                        <span class="resource-value">${role.count} × ${role.skillLevel || 'Any'}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // Technologies
                if (resources.technologies && resources.technologies.length > 0) {
                    html += `
                        <div class="resource-section">
                            <h3>💻 Technologies</h3>
                            <div class="tech-tags">
                                ${resources.technologies.map(tech => `<span class="tech-tag">${tech}</span>`).join('')}
                            </div>
                        </div>
                    `;
                }

                // Budget & Time
                if (resources.estimatedBudget || resources.estimatedHours) {
                    html += `
                        <div class="resource-section">
                            <h3>💰 Budget & Time</h3>
                            <div class="resource-list">
                                ${resources.estimatedBudget ? `
                                    <div class="resource-item">
                                        <span class="resource-label">Estimated Budget</span>
                                        <span class="resource-value">${resources.estimatedBudget}</span>
                                    </div>
                                ` : ''}
                                ${resources.estimatedHours ? `
                                    <div class="resource-item">
                                        <span class="resource-label">Estimated Hours</span>
                                        <span class="resource-value">${resources.estimatedHours}h</span>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html;
            },

            renderPlanningTab(feature) {
                const planning = feature.planning || {};

                // Milestones
                const milestonesContainer = document.getElementById('milestonesList');
                if (planning.milestones && planning.milestones.length > 0) {
                    milestonesContainer.innerHTML = planning.milestones.map(milestone => `
                        <div class="milestone">
                            <div class="milestone-status ${milestone.status || 'pending'}"></div>
                            <div class="milestone-content">
                                <h4>${milestone.name}</h4>
                                <p class="milestone-date">${milestone.targetDate ? `Target: ${milestone.targetDate}` : 'No date set'}</p>
                                ${milestone.dependencies ? `<p style="font-size: 12px; color: var(--text-muted); margin-top: 4px;">Dependencies: ${milestone.dependencies.join(', ')}</p>` : ''}
                            </div>
                        </div>
                    `).join('');
                } else {
                    milestonesContainer.innerHTML = '<p class="detail-text">No milestones defined</p>';
                }

                // Risks
                const risksContainer = document.getElementById('risksList');
                if (planning.risks && planning.risks.length > 0) {
                    risksContainer.innerHTML = planning.risks.map(risk => `
                        <div class="risk ${risk.severity || 'medium'}">
                            <div class="risk-header">
                                <h4>Risk</h4>
                                <span class="risk-severity ${risk.severity || 'medium'}">${risk.severity || 'medium'}</span>
                            </div>
                            <div class="risk-body">
                                <p>${risk.description}</p>
                            </div>
                            ${risk.mitigation ? `
                                <div class="risk-mitigation">
                                    <strong>Mitigation Strategy:</strong>
                                    <p>${risk.mitigation}</p>
                                </div>
                            ` : ''}
                        </div>
                    `).join('');
                } else {
                    risksContainer.innerHTML = '<p class="detail-text">No risks identified</p>';
                }

                // Prerequisites
                const prerequisitesContainer = document.getElementById('prerequisitesList');
                if (planning.prerequisites && planning.prerequisites.length > 0) {
                    prerequisitesContainer.innerHTML = planning.prerequisites.map(prereq => `
                        <div class="prerequisite">
                            <div class="prerequisite-checkbox"></div>
                            <span class="prerequisite-text">${prereq}</span>
                        </div>
                    `).join('');
                } else {
                    prerequisitesContainer.innerHTML = '<p class="detail-text">No prerequisites defined</p>';
                }
            },

            renderInspirationTab(feature) {
                const container = document.getElementById('inspirationList');
                const inspiration = feature.inspiration || [];

                if (inspiration.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">💡</div>
                            <h3>No Inspiration Yet</h3>
                            <p>Add references manually or let AI find inspiration</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = inspiration.map(item => `
                    <div class="inspiration-card" onclick="window.open('${item.url}', '_blank')">
                        <button class="delete-inspiration-btn" onclick="event.stopPropagation(); app.deleteInspiration('${feature.id}', '${item.id}');" title="Delete inspiration">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                            </svg>
                        </button>
                        <div class="inspiration-image">
                            ${item.imageUrl ? `<img src="${item.imageUrl}" alt="${item.title}" style="width:100%;height:100%;object-fit:cover;">` : '🔗'}
                        </div>
                        <div class="inspiration-content">
                            <span class="inspiration-type">${item.type || 'reference'}</span>
                            <h4>${item.title}</h4>
                            <p>${item.description || 'No description'}</p>
                            <a href="${item.url}" class="inspiration-link" onclick="event.stopPropagation()">${item.url}</a>
                        </div>
                    </div>
                `).join('');
            },

            // ==================== Detail View Helper Functions ====================

            addExecutionStep() {
                if (!this.currentFeatureId) return;

                const title = prompt('Step title:');
                if (!title) return;

                const description = prompt('Step description:');
                const estimatedHours = prompt('Estimated hours (optional):');

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!feature.executionSteps) feature.executionSteps = [];

                const newStep = {
                    id: Date.now().toString(),
                    order: feature.executionSteps.length,
                    title,
                    description: description || '',
                    estimatedHours: estimatedHours ? parseInt(estimatedHours) : null,
                    completed: false
                };

                feature.executionSteps.push(newStep);
                this.saveData();
                this.renderExecutionTab(feature);
            },

            toggleStepComplete(featureId, stepId) {
                const feature = this.features.find(f => f.id === featureId);
                if (!feature || !feature.executionSteps) return;

                const step = feature.executionSteps.find(s => s.id === stepId);
                if (step) {
                    step.completed = !step.completed;
                    this.saveData();
                    this.renderExecutionTab(feature);
                }
            },

            async deleteExecutionStep(featureId, stepId) {
                const feature = this.features.find(f => f.id === featureId);
                if (!feature || !feature.executionSteps) return;

                const confirmed = await this.showConfirm({
                    title: 'Delete Execution Step',
                    message: 'Are you sure you want to delete this execution step?',
                    confirmText: 'Delete',
                    cancelText: 'Cancel',
                    variant: 'danger',
                    dontAskAgainKey: 'hideExecutionStepDeleteConfirm'
                });

                if (!confirmed) return;

                feature.executionSteps = feature.executionSteps.filter(s => s.id !== stepId);
                this.saveData();
                this.renderExecutionTab(feature);
            },

            addMilestone() {
                if (!this.currentFeatureId) return;

                const name = prompt('Milestone name:');
                if (!name) return;

                const targetDate = prompt('Target date (YYYY-MM-DD):');

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!feature.planning) feature.planning = {};
                if (!feature.planning.milestones) feature.planning.milestones = [];

                feature.planning.milestones.push({
                    id: Date.now().toString(),
                    name,
                    targetDate: targetDate || null,
                    status: 'pending',
                    dependencies: []
                });

                this.saveData();
                this.renderPlanningTab(feature);
            },

            addRisk() {
                if (!this.currentFeatureId) return;

                const description = prompt('Risk description:');
                if (!description) return;

                const severity = prompt('Severity (low/medium/high):') || 'medium';
                const mitigation = prompt('Mitigation strategy (optional):');

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!feature.planning) feature.planning = {};
                if (!feature.planning.risks) feature.planning.risks = [];

                feature.planning.risks.push({
                    id: Date.now().toString(),
                    description,
                    severity: severity.toLowerCase(),
                    mitigation: mitigation || ''
                });

                this.saveData();
                this.renderPlanningTab(feature);
            },

            addPrerequisite() {
                if (!this.currentFeatureId) return;

                const prereq = prompt('Prerequisite:');
                if (!prereq) return;

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!feature.planning) feature.planning = {};
                if (!feature.planning.prerequisites) feature.planning.prerequisites = [];

                feature.planning.prerequisites.push(prereq);
                this.saveData();
                this.renderPlanningTab(feature);
            },

            addInspiration() {
                if (!this.currentFeatureId) return;

                const title = prompt('Reference title:');
                if (!title) return;

                const url = prompt('URL:');
                if (!url) return;

                const description = prompt('Description (optional):');
                const type = prompt('Type (reference/competitor/example):') || 'reference';

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!feature.inspiration) feature.inspiration = [];

                feature.inspiration.push({
                    id: Date.now().toString(),
                    title,
                    url,
                    description: description || '',
                    type: type.toLowerCase(),
                    imageUrl: null
                });

                this.saveData();
                this.renderInspirationTab(feature);
            },

            deleteInspiration(featureId, inspirationId) {
                const feature = this.features.find(f => f.id === featureId);
                if (!feature || !feature.inspiration) return;

                if (!confirm('Delete this inspiration source?')) return;

                feature.inspiration = feature.inspiration.filter(i => i.id !== inspirationId);
                this.saveData();
                this.renderInspirationTab(feature);
            },

            // ==================== AI Integration for Detail View ====================

            async generateExecutionPlan() {
                if (!this.currentFeatureId) return;

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!this.apiKey) {
                    this.showAlert({ title: 'API Key Required', message: 'Please set your OpenRouter API key in settings first.', variant: 'warning' });
                    return;
                }

                const userMessage = `Generate a detailed execution plan for this feature:

Feature Name: ${feature.name}
Type: ${feature.type}
Purpose: ${feature.purpose}
Timeline: ${feature.timelineItems?.map(t => t.timeline).join(', ') || 'Not specified'}
Difficulty: ${feature.timelineItems?.map(t => t.difficulty).join(', ') || 'Not specified'}

Please generate 5-8 concrete, actionable execution steps with:
1. Clear title for each step
2. Detailed description of what needs to be done
3. Estimated hours for each step

Return as JSON array:
[{"title": "...", "description": "...", "estimatedHours": number}]`;

                try {
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [{ role: 'user', content: userMessage }]
                        })
                    });

                    if (!response.ok) throw new Error('AI request failed');

                    const data = await response.json();
                    const content = data.choices[0].message.content;

                    // Try to extract JSON from the response
                    const jsonMatch = content.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        const steps = JSON.parse(jsonMatch[0]);

                        if (!feature.executionSteps) feature.executionSteps = [];

                        steps.forEach((step, index) => {
                            feature.executionSteps.push({
                                id: Date.now().toString() + index,
                                order: feature.executionSteps.length + index,
                                title: step.title,
                                description: step.description,
                                estimatedHours: step.estimatedHours || null,
                                completed: false
                            });
                        });

                        this.saveData();
                        this.renderExecutionTab(feature);
                        this.showAlert({ title: 'Success', message: 'Execution plan generated!', variant: 'success' });
                    } else {
                        throw new Error('Could not parse AI response');
                    }
                } catch (error) {
                    console.error('Error generating execution plan:', error);
                    this.showAlert({ title: 'Error', message: 'Failed to generate execution plan. Please try again.', variant: 'error' });
                }
            },

            async suggestResources() {
                if (!this.currentFeatureId) return;

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!this.apiKey) {
                    this.showAlert({ title: 'API Key Required', message: 'Please set your OpenRouter API key in settings first.', variant: 'warning' });
                    return;
                }

                const userMessage = `Suggest required resources for this feature:

Feature Name: ${feature.name}
Type: ${feature.type}
Purpose: ${feature.purpose}
Difficulty: ${feature.timelineItems?.map(t => t.difficulty).join(', ') || 'Not specified'}

Please suggest:
1. Team roles needed (with count and skill level)
2. Technologies required
3. Estimated budget range
4. Estimated total hours

Return as JSON:
{
  "teamRoles": [{"role": "...", "count": 1, "skillLevel": "..."}],
  "technologies": ["..."],
  "estimatedBudget": "...",
  "estimatedHours": number
}`;

                try {
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [{ role: 'user', content: userMessage }]
                        })
                    });

                    if (!response.ok) throw new Error('AI request failed');

                    const data = await response.json();
                    const content = data.choices[0].message.content;

                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const resources = JSON.parse(jsonMatch[0]);
                        feature.resources = resources;
                        this.saveData();
                        this.renderResourcesTab(feature);
                        this.showAlert({ title: 'Success', message: 'Resources suggested!', variant: 'success' });
                    } else {
                        throw new Error('Could not parse AI response');
                    }
                } catch (error) {
                    console.error('Error suggesting resources:', error);
                    this.showAlert({ title: 'Error', message: 'Failed to suggest resources. Please try again.', variant: 'error' });
                }
            },

            async identifyRisks() {
                if (!this.currentFeatureId) return;

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!this.apiKey) {
                    this.showAlert({ title: 'API Key Required', message: 'Please set your OpenRouter API key in settings first.', variant: 'warning' });
                    return;
                }

                const userMessage = `Identify potential risks for this feature:

Feature Name: ${feature.name}
Type: ${feature.type}
Purpose: ${feature.purpose}
Difficulty: ${feature.timelineItems?.map(t => t.difficulty).join(', ') || 'Not specified'}

Please identify 3-5 risks with:
1. Description of the risk
2. Severity (low/medium/high)
3. Mitigation strategy

Return as JSON array:
[{"description": "...", "severity": "...", "mitigation": "..."}]`;

                try {
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [{ role: 'user', content: userMessage }]
                        })
                    });

                    if (!response.ok) throw new Error('AI request failed');

                    const data = await response.json();
                    const content = data.choices[0].message.content;

                    const jsonMatch = content.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        const risks = JSON.parse(jsonMatch[0]);

                        if (!feature.planning) feature.planning = {};
                        if (!feature.planning.risks) feature.planning.risks = [];

                        risks.forEach(risk => {
                            feature.planning.risks.push({
                                id: Date.now().toString() + Math.random(),
                                description: risk.description,
                                severity: risk.severity.toLowerCase(),
                                mitigation: risk.mitigation
                            });
                        });

                        this.saveData();
                        this.renderPlanningTab(feature);
                        this.showAlert({ title: 'Success', message: 'Risks identified!', variant: 'success' });
                    } else {
                        throw new Error('Could not parse AI response');
                    }
                } catch (error) {
                    console.error('Error identifying risks:', error);
                    this.showAlert({ title: 'Error', message: 'Failed to identify risks. Please try again.', variant: 'error' });
                }
            },

            async findInspiration() {
                if (!this.currentFeatureId) return;

                const feature = this.features.find(f => f.id === this.currentFeatureId);
                if (!feature) return;

                if (!this.tavilyApiKey) {
                    this.showAlert({ title: 'Tavily API Key Required', message: 'Please set your Tavily API key in settings to search for inspiration.', variant: 'warning' });
                    return;
                }

                if (!this.apiKey) {
                    this.showAlert({ title: 'API Key Required', message: 'Please set your OpenRouter API key for AI-enhanced search.', variant: 'warning' });
                    return;
                }

                try {
                    // Show loading state
                    await this.showAlert({ title: 'Searching...', message: 'Running intelligent multi-query search...', variant: 'info' });

                    // Step 1: AI analyzes feature and generates search context
                    const searchContext = await this.analyzeFeatureForSearch(feature);

                    // Step 2: Generate 4 targeted queries based on feature type
                    const queries = this.generateSmartQueries(feature, searchContext);

                    // Step 3: Execute all searches in parallel
                    const searchPromises = queries.map(q => this.executeTavilySearch(q));
                    const rawResults = await Promise.all(searchPromises);

                    // Step 4: Flatten and deduplicate
                    const allResults = rawResults.flat();
                    const uniqueResults = this.deduplicateResults(allResults);

                    // Step 5: Score and rank results
                    const scoredResults = uniqueResults.map(r => ({
                        ...r,
                        score: this.scoreResult(r, feature)
                    }));

                    scoredResults.sort((a, b) => b.score - a.score);

                    // Step 6: Take top 10 results
                    const topResults = scoredResults.slice(0, 10);

                    // Step 7: Save to feature
                    if (!feature.inspiration) feature.inspiration = [];

                    topResults.forEach(result => {
                        feature.inspiration.push({
                            id: Date.now().toString() + Math.random(),
                            title: result.title,
                            url: result.url,
                            description: result.content?.substring(0, 200) || '',
                            type: this.categorizeResult(result),
                            imageUrl: null,
                            score: result.score
                        });
                    });

                    this.saveData();
                    this.renderInspirationTab(feature);

                    await this.showAlert({ title: 'Success', message: `Found ${topResults.length} high-quality inspiration sources!`, variant: 'success' });

                } catch (error) {
                    console.error('Error finding inspiration:', error);
                    await this.showAlert({ title: 'Error', message: 'Failed to find inspiration. Please try again.', variant: 'error' });
                }
            },

            async analyzeFeatureForSearch(feature) {
                const prompt = `Analyze this feature for intelligent web search:

Feature: ${feature.name}
Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}

Extract JSON:
{
    "coreKeywords": ["keyword1", "keyword2", ...],
    "industryDomain": "fintech|social|analytics|ecommerce|general",
    "technicalComplexity": "simple|medium|complex",
    "searchFocus": ["implementation", "competitors", "tools", "providers"],
    "recommendedDomains": ["domain1.com", ...]
}`;

                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Platform Roadmap Manager'
                    },
                    body: JSON.stringify({
                        model: this.selectedModel,
                        messages: [
                            { role: 'system', content: 'You are a search query optimization expert. Return only valid JSON.' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.3
                    })
                });

                const data = await response.json();
                const content = data.choices[0].message.content;

                // Extract JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                return jsonMatch ? JSON.parse(jsonMatch[0]) : {
                    coreKeywords: [feature.name],
                    industryDomain: 'general',
                    technicalComplexity: 'medium',
                    searchFocus: ['implementation', 'tools'],
                    recommendedDomains: []
                };
            },

            generateSmartQueries(feature, context) {
                const queries = [];
                const keywords = context.coreKeywords.join(' ');
                const complexity = context.technicalComplexity;

                // Query 1: Implementation/Tutorial
                queries.push({
                    query: complexity === 'complex'
                        ? `${keywords} system architecture implementation guide`
                        : `how to implement ${keywords} step by step tutorial`,
                    search_depth: complexity === 'complex' ? 'advanced' : 'basic',
                    max_results: 7,
                    include_domains: ['github.com', 'medium.com', 'dev.to', 'stackoverflow.com'],
                    topic: 'general'
                });

                // Query 2: Tools/Libraries
                if (context.searchFocus.includes('tools')) {
                    queries.push({
                        query: `best ${keywords} libraries frameworks tools 2024`,
                        search_depth: 'basic',
                        max_results: 7,
                        include_domains: ['github.com', 'npmjs.com', 'pypi.org'],
                        topic: 'general'
                    });
                }

                // Query 3: Competitors/Examples
                if (context.searchFocus.includes('competitors')) {
                    queries.push({
                        query: `platforms with ${feature.name} feature examples`,
                        search_depth: 'basic',
                        max_results: 7,
                        include_domains: ['producthunt.com', 'g2.com', 'capterra.com'],
                        topic: 'general'
                    });
                }

                // Query 4: API/Service Providers
                if (context.searchFocus.includes('providers')) {
                    queries.push({
                        query: `${keywords} API service providers comparison`,
                        search_depth: 'basic',
                        max_results: 7,
                        include_domains: ['rapidapi.com', 'programmableweb.com', ...context.recommendedDomains],
                        topic: 'general'
                    });
                }

                // Query 5: Best Practices (for complex features)
                if (complexity === 'complex') {
                    queries.push({
                        query: `${keywords} security scalability best practices`,
                        search_depth: 'advanced',
                        max_results: 5,
                        include_domains: ['docs.microsoft.com', 'aws.amazon.com', 'github.com'],
                        topic: 'general'
                    });
                }

                return queries;
            },

            async executeTavilySearch(queryConfig) {
                const response = await fetch('https://api.tavily.com/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        api_key: this.tavilyApiKey,
                        ...queryConfig
                    })
                });

                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                return data.results || [];
            },

            deduplicateResults(results) {
                const seen = new Map();
                return results.filter(r => {
                    try {
                        const urlKey = new URL(r.url).hostname + new URL(r.url).pathname;
                        if (seen.has(urlKey)) return false;
                        seen.set(urlKey, true);
                        return true;
                    } catch {
                        return true; // Keep if URL parsing fails
                    }
                });
            },

            scoreResult(result, feature) {
                let score = 0;

                // Domain authority (0-30)
                const authorityScores = {
                    'github.com': 30, 'stackoverflow.com': 28, 'docs.microsoft.com': 30,
                    'aws.amazon.com': 30, 'cloud.google.com': 30, 'firebase.google.com': 28,
                    'stripe.com': 28, 'auth0.com': 28, 'medium.com': 22, 'dev.to': 20,
                    'smashingmagazine.com': 25, 'css-tricks.com': 25, 'freecodecamp.org': 24
                };
                try {
                    const domain = new URL(result.url).hostname.replace('www.', '');
                    score += authorityScores[domain] || 12;
                } catch {
                    score += 10;
                }

                // Keyword relevance (0-35)
                const searchText = (result.title + ' ' + (result.content || '')).toLowerCase();
                const featureText = (feature.name + ' ' + (feature.purpose || '')).toLowerCase();
                const words = featureText.split(/\s+/).filter(w => w.length > 3);
                const matches = words.filter(w => searchText.includes(w)).length;
                score += Math.min(matches * 7, 35);

                // Content type bonus (0-20)
                if (result.url.includes('github.com') && result.url.includes('/tree/')) score += 20;
                else if (result.title.match(/documentation|official docs/i)) score += 18;
                else if (result.title.match(/tutorial|guide|how.?to/i)) score += 15;
                else if (result.title.match(/best practices|patterns/i)) score += 16;

                // Recency (0-15)
                if (result.title.match(/2024/)) score += 15;
                else if (result.title.match(/2023/)) score += 12;
                else if (result.title.match(/202[0-2]/)) score += 8;

                return score;
            },

            categorizeResult(result) {
                const url = result.url.toLowerCase();
                const title = result.title.toLowerCase();

                if (url.includes('github.com')) return 'code';
                if (url.includes('stackoverflow.com')) return 'qa';
                if (title.match(/tutorial|guide|how.?to/)) return 'tutorial';
                if (url.match(/docs?\.|documentation/)) return 'documentation';
                if (title.match(/comparison|vs|alternative/)) return 'comparison';
                if (url.includes('medium.com') || url.includes('dev.to')) return 'article';

                return 'reference';
            },

            // ==================== AI-Assisted Feature Creation Workflow ====================

            showAIAssistedFeatureCreation() {
                // Open chat panel if not open
                const chatPanel = document.getElementById('chatPanel');
                if (!chatPanel.classList.contains('active')) {
                    this.toggleChat();
                }

                // Set flag for AI to know we're in feature creation mode
                this.aiFeatureCreationMode = true;

                // Start AI conversation
                const initialPrompt = `I want to create a new feature for my platform roadmap. Please help me by:

1. Asking me clarifying questions to understand what I want to build
2. After gathering the requirements, automatically research and generate:
   - Execution steps with time estimates
   - Required resources (team, technologies, budget)
   - Planning milestones and risk assessment
   - Inspiration sources and reference links

Let's start! Ask me questions about the feature I want to add.`;

                // Add user message to chat
                this.addMessageToChat('user', initialPrompt);

                // Send to AI
                this.sendMessage();
            },

            // ==================== AI Feature Enhancement Workflow ====================

            // Enhancement Panel Functions
            showEnhancementPanel(featureId) {
                const feature = this.features.find(f => f.id === featureId);
                if (!feature) {
                    this.showAlert({ title: 'Error', message: 'Feature not found', variant: 'error' });
                    return;
                }

                // Set flags
                this.aiFeatureEnhancementMode = true;
                this.currentFeatureId = featureId;
                this.enhancementQuestions = [];
                this.enhancementAnswers = {};

                // Show panel
                const panel = document.getElementById('enhancementPanel');
                panel.classList.remove('hidden');

                // Populate understanding section
                document.getElementById('understandingName').textContent = feature.name;
                document.getElementById('understandingType').textContent = feature.type;
                document.getElementById('understandingPurpose').textContent = feature.purpose || 'Not specified';

                // Identify gaps
                const gaps = [];
                if (!feature.executionSteps || feature.executionSteps.length === 0) gaps.push('Execution Steps');
                if (!feature.resources) gaps.push('Resources');
                if (!feature.planning) gaps.push('Planning');
                if (!feature.inspiration || feature.inspiration.length === 0) gaps.push('Inspiration');

                const gapsContainer = document.getElementById('enhancementGaps');
                if (gaps.length > 0) {
                    gapsContainer.innerHTML = gaps.map(gap =>
                        `<span class="gap-badge">${gap}</span>`
                    ).join('');
                } else {
                    gapsContainer.innerHTML = '<p style="font-size:13px; color:var(--text-muted); font-style:italic;">No gaps found - feature looks complete!</p>';
                }

                // Generate questions via AI
                this.generateEnhancementQuestions(feature);
            },

            async generateEnhancementQuestions(feature) {
                const questionsContainer = document.getElementById('enhancementQuestions');
                questionsContainer.innerHTML = '<p class="enhancement-loading">Generating questions...</p>';

                try {
                    const featureContext = `Feature Name: ${feature.name}
Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}
Current State: ${feature.executionSteps ? 'Has execution steps' : 'Missing execution steps'}, ${feature.resources ? 'Has resources' : 'Missing resources'}, ${feature.planning ? 'Has planning' : 'Missing planning'}`;

                    const prompt = `Based on this feature, generate 3-5 targeted clarifying questions to gather information needed to enhance it:

${featureContext}

Return ONLY a JSON array of questions, like: ["Question 1?", "Question 2?", "Question 3?"]
Make questions specific, actionable, and focused on missing information.`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'system', content: 'You are a helpful assistant that generates clarifying questions. Return only valid JSON.' },
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.7
                        })
                    });

                    const data = await response.json();
                    const content = data.choices[0].message.content;

                    // Extract JSON array
                    const jsonMatch = content.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        this.enhancementQuestions = JSON.parse(jsonMatch[0]);

                        // Display questions
                        questionsContainer.innerHTML = this.enhancementQuestions.map((q, i) => `
                            <div class="question-item">
                                <label class="question-label">${i + 1}. ${q}</label>
                                <input type="text" class="question-input" id="question-${i}" placeholder="Your answer..." oninput="app.checkEnhancementAnswers()">
                            </div>
                        `).join('');

                        // Enable submit button when all answered
                        document.getElementById('enhancementSubmitBtn').disabled = true;
                    } else {
                        throw new Error('Failed to parse questions');
                    }
                } catch (error) {
                    console.error('Error generating questions:', error);
                    questionsContainer.innerHTML = '<p style="color:var(--danger); font-size:13px;">Error generating questions. Please try again or use chat instead.</p>';
                }
            },

            checkEnhancementAnswers() {
                const allAnswered = this.enhancementQuestions.every((_, i) => {
                    const input = document.getElementById(`question-${i}`);
                    return input && input.value.trim().length > 0;
                });

                document.getElementById('enhancementSubmitBtn').disabled = !allAnswered;
            },

            closeEnhancementPanel() {
                const panel = document.getElementById('enhancementPanel');
                panel.classList.add('hidden');

                // Reset state
                this.aiFeatureEnhancementMode = false;
                this.currentFeatureId = null;
                this.enhancementQuestions = [];
                this.enhancementAnswers = {};
            },

            async submitEnhancementAnswers() {
                // Collect answers
                this.enhancementQuestions.forEach((q, i) => {
                    const input = document.getElementById(`question-${i}`);
                    if (input) {
                        this.enhancementAnswers[q] = input.value.trim();
                    }
                });

                // Validate that all questions have answers
                const unansweredQuestions = this.enhancementQuestions.filter((q, i) => {
                    const input = document.getElementById(`question-${i}`);
                    return !input || !input.value.trim();
                });

                if (unansweredQuestions.length > 0) {
                    await this.showAlert({
                        title: 'Missing Answers',
                        message: 'Please answer all questions before proceeding. This ensures I have enough context to enhance your feature properly.',
                        variant: 'warning'
                    });
                    return;
                }

                // Hide questions, show progress
                document.getElementById('enhancementQuestions').classList.add('hidden');
                const progressSection = document.getElementById('enhancementProgress');
                progressSection.classList.remove('hidden');

                // Disable submit button
                document.getElementById('enhancementSubmitBtn').disabled = true;

                // Get feature
                const feature = this.features.find(f => f.id === this.currentFeatureId);

                // Build research prompt
                const answersText = Object.entries(this.enhancementAnswers)
                    .map(([q, a]) => `Q: ${q}\nA: ${a}`)
                    .join('\n\n');

                // Update progress
                this.updateEnhancementProgress(20, 'Conducting research...');

                try {
                    // Conduct research
                    const enhancedData = {
                        name: feature.name,
                        type: feature.type,
                        purpose: feature.purpose,
                        timelineItems: feature.timelineItems || [],
                        additionalInfo: answersText
                    };

                    this.updateEnhancementProgress(40, 'Searching for relevant information...');

                    const researchResults = await this.conductFeatureResearch(enhancedData);

                    this.updateEnhancementProgress(60, 'Generating execution steps...');

                    const executionSteps = await this.generateExecutionStepsFromResearch(enhancedData, researchResults);

                    this.updateEnhancementProgress(70, 'Suggesting resources...');

                    const resources = await this.suggestResourcesFromResearch(enhancedData, researchResults);

                    this.updateEnhancementProgress(80, 'Creating planning details...');

                    const planning = await this.generatePlanningFromResearch(enhancedData, researchResults);

                    this.updateEnhancementProgress(90, 'Finding inspiration sources...');

                    const inspiration = this.selectBestInspirationSources(researchResults);

                    // Update feature
                    feature.executionSteps = executionSteps;
                    feature.resources = resources;
                    feature.planning = planning;
                    feature.inspiration = inspiration;
                    feature.aiModified = true;

                    this.saveData();
                    this.renderFeatureDetail(this.currentFeatureId);
                    this.renderTable();

                    this.updateEnhancementProgress(100, 'Complete!');

                    // Close panel after delay
                    setTimeout(() => {
                        this.closeEnhancementPanel();
                        this.showToast('✓ Feature enhanced successfully!', 'success');
                    }, 1000);

                } catch (error) {
                    console.error('Enhancement error:', error);
                    document.getElementById('enhancementProgressText').textContent = `Error: ${error.message}`;
                    document.getElementById('enhancementProgressText').style.color = 'var(--danger)';
                }
            },

            updateEnhancementProgress(percent, message) {
                const fill = document.getElementById('enhancementProgressFill');
                const text = document.getElementById('enhancementProgressText');

                if (fill) fill.style.width = `${percent}%`;
                if (text) text.textContent = message;
            },

            startAIEnhancementWorkflow(featureId) {
                // Use the new enhancement panel instead of chat
                this.showEnhancementPanel(featureId);
            },

            // This will be called by AI when ready to enhance the feature
            async executeEnhanceFeatureWithResearch(actionData) {
                try {
                    const featureId = actionData.featureId || this.currentFeatureId;
                    const feature = this.features.find(f => f.id === featureId);

                    if (!feature) {
                        return { success: false, error: 'Feature not found' };
                    }

                    // IMPORTANT: Enforce that enhancement can ONLY happen through the enhancement panel
                    // This ensures we always ask relevant questions and gather context first
                    if (!this.aiFeatureEnhancementMode || Object.keys(this.enhancementAnswers || {}).length === 0) {
                        this.addChatMessage('⚠️ To enhance a feature, I need to ask you some questions first. Please click the "AI Enhance" button on the feature to start the guided enhancement process.', 'ai');
                        return {
                            success: false,
                            error: 'Enhancement must be initiated through the enhancement panel to ensure proper context gathering'
                        };
                    }

                    await this.showAlert({ title: 'Enhancing Feature...', message: 'AI is researching and generating comprehensive feature details...', variant: 'info' });

                    // Merge existing data with new data from actionData
                    const enhancedData = {
                        name: actionData.name || feature.name,
                        type: actionData.type || feature.type,
                        purpose: actionData.purpose || feature.purpose,
                        timelineItems: feature.timelineItems || [],
                        additionalInfo: actionData.additionalInfo || ''
                    };

                    // Step 1: Conduct Tavily research
                    const researchResults = await this.conductFeatureResearch(enhancedData);

                    // Step 2: AI generates execution steps from research (replace existing if exists)
                    const executionSteps = await this.generateExecutionStepsFromResearch(enhancedData, researchResults);

                    // Step 3: AI suggests resources
                    const resources = await this.suggestResourcesFromResearch(enhancedData, researchResults);

                    // Step 4: AI creates planning (milestones, risks)
                    const planning = await this.generatePlanningFromResearch(enhancedData, researchResults);

                    // Step 5: Select best inspiration sources from research
                    const inspiration = this.selectBestInspirationSources(researchResults);

                    // Step 6: Update the existing feature
                    feature.executionSteps = executionSteps;
                    feature.resources = resources;
                    feature.planning = planning;
                    feature.inspiration = inspiration;
                    feature.aiModified = true;
                    feature.updatedAt = new Date().toISOString();

                    // Update name/purpose if provided
                    if (actionData.name) feature.name = actionData.name;
                    if (actionData.purpose) feature.purpose = actionData.purpose;
                    if (actionData.type) feature.type = actionData.type;

                    // Save changes
                    this.saveData();
                    
                    // Refresh detail view
                    this.renderFeatureDetail(featureId);
                    
                    // Refresh table view to show updated badge
                    this.renderTable();

                    // Reset enhancement mode
                    this.aiFeatureEnhancementMode = false;

                    await this.showAlert({
                        title: 'Feature Enhanced!',
                        message: 'AI has researched and populated all detail sections. Review and edit as needed.',
                        variant: 'success'
                    });

                    return {
                        success: true,
                        featureId: featureId,
                        message: 'Feature enhanced successfully with AI research! All sections have been updated.'
                    };

                } catch (error) {
                    console.error('Error enhancing feature with research:', error);
                    await this.showAlert({ title: 'Error', message: 'Failed to enhance feature. Please try again.', variant: 'error' });
                    this.aiFeatureEnhancementMode = false;
                    return { success: false, error: error.message };
                }
            },

            // This will be called by AI when ready to create the feature
            async executeCreateFeatureWithResearch(actionData) {
                try {
                    await this.showAlert({ title: 'Creating Feature...', message: 'AI is researching and generating comprehensive feature details...', variant: 'info' });

                    // Step 1: Conduct Tavily research
                    const researchResults = await this.conductFeatureResearch(actionData);

                    // Step 2: AI generates execution steps from research
                    const executionSteps = await this.generateExecutionStepsFromResearch(actionData, researchResults);

                    // Step 3: AI suggests resources
                    const resources = await this.suggestResourcesFromResearch(actionData, researchResults);

                    // Step 4: AI creates planning (milestones, risks)
                    const planning = await this.generatePlanningFromResearch(actionData, researchResults);

                    // Step 5: Select best inspiration sources from research
                    const inspiration = this.selectBestInspirationSources(researchResults);

                    // Step 6: Create the feature
                    const newFeature = {
                        id: Date.now().toString(),
                        name: actionData.name,
                        type: actionData.type || 'Feature',
                        purpose: actionData.purpose,
                        timelineItems: actionData.timelineItems || [],
                        executionSteps: executionSteps,
                        resources: resources,
                        planning: planning,
                        inspiration: inspiration,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        aiCreated: true
                    };

                    // Add to features array
                    this.features.push(newFeature);
                    this.saveData();
                    this.renderTable();

                    // Reset AI creation mode
                    this.aiFeatureCreationMode = false;

                    // Show detail view for review
                    this.showDetailView(newFeature.id);

                    await this.showAlert({
                        title: 'Feature Created!',
                        message: 'AI has created a comprehensive feature plan. Review and edit as needed.',
                        variant: 'success'
                    });

                    return {
                        success: true,
                        featureId: newFeature.id,
                        message: 'Feature created successfully with AI research! Opening detail view for your review.'
                    };

                } catch (error) {
                    console.error('Error creating feature with research:', error);
                    await this.showAlert({ title: 'Error', message: 'Failed to create feature. Please try again.', variant: 'error' });
                    return { success: false, error: error.message };
                }
            },

            async conductFeatureResearch(actionData) {
                // Create a temporary feature object for research
                const tempFeature = {
                    id: 'temp',
                    name: actionData.name,
                    type: actionData.type || 'Feature',
                    purpose: actionData.purpose
                };

                // Use the same AI-enhanced search we built for inspiration
                const searchContext = await this.analyzeFeatureForSearch(tempFeature);
                const queries = this.generateSmartQueries(tempFeature, searchContext);

                // Execute searches in parallel
                const searchPromises = queries.map(q => this.executeTavilySearch(q));
                const rawResults = await Promise.all(searchPromises);

                // Flatten and deduplicate
                const allResults = rawResults.flat();
                const uniqueResults = this.deduplicateResults(allResults);

                // Score and rank
                const scoredResults = uniqueResults.map(r => ({
                    ...r,
                    score: this.scoreResult(r, tempFeature),
                    category: this.categorizeResult(r)
                }));

                scoredResults.sort((a, b) => b.score - a.score);

                return scoredResults.slice(0, 15); // Top 15 results for comprehensive research
            },

            async generateExecutionStepsFromResearch(actionData, researchResults) {
                const researchSummary = researchResults.slice(0, 5).map((r, i) =>
                    `[${i + 1}] ${r.title}\n${r.content?.substring(0, 150) || 'No description'}`
                ).join('\n\n');

                const prompt = `Based on this feature and research, generate 5-8 detailed execution steps:

Feature: ${actionData.name}
Purpose: ${actionData.purpose}
Type: ${actionData.type}

Research findings:
${researchSummary}

Generate execution steps as JSON array:
[{
    "title": "Step title",
    "description": "Detailed description of what to do",
    "estimatedHours": number
}]

Make steps actionable, specific, and based on the research findings.`;

                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Platform Roadmap Manager'
                    },
                    body: JSON.stringify({
                        model: this.selectedModel,
                        messages: [
                            { role: 'system', content: 'You are a technical project planner. Return only valid JSON.' },
                            { role: 'user', content: prompt }
                        ]
                    })
                });

                const data = await response.json();
                const content = data.choices[0].message.content;

                const jsonMatch = content.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    const steps = JSON.parse(jsonMatch[0]);
                    return steps.map((step, index) => ({
                        id: Date.now().toString() + index,
                        order: index,
                        title: step.title,
                        description: step.description,
                        estimatedHours: step.estimatedHours || null,
                        completed: false
                    }));
                }

                return [];
            },

            async suggestResourcesFromResearch(actionData, researchResults) {
                const researchSummary = researchResults.slice(0, 5).map((r, i) =>
                    `[${i + 1}] ${r.title}`
                ).join('\n');

                const prompt = `Based on this feature and research, suggest required resources:

Feature: ${actionData.name}
Purpose: ${actionData.purpose}

Research sources:
${researchSummary}

Generate resources as JSON:
{
    "teamRoles": [{"role": "Developer", "count": 2, "skillLevel": "Senior"}],
    "technologies": ["React", "Node.js", "PostgreSQL"],
    "estimatedBudget": "$15k-25k",
    "estimatedHours": 120
}`;

                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Platform Roadmap Manager'
                    },
                    body: JSON.stringify({
                        model: this.selectedModel,
                        messages: [
                            { role: 'system', content: 'You are a resource planning expert. Return only valid JSON.' },
                            { role: 'user', content: prompt }
                        ]
                    })
                });

                const data = await response.json();
                const content = data.choices[0].message.content;

                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }

                return {};
            },

            async generatePlanningFromResearch(actionData, researchResults) {
                const prompt = `Based on this feature, generate planning details:

Feature: ${actionData.name}
Purpose: ${actionData.purpose}

Generate planning as JSON:
{
    "milestones": [{"id": "1", "name": "Milestone name", "targetDate": null, "status": "pending", "dependencies": []}],
    "risks": [{"id": "1", "description": "Risk description", "severity": "medium", "mitigation": "How to mitigate"}],
    "prerequisites": ["Prerequisite 1", "Prerequisite 2"]
}

Generate 3-4 milestones, 3-5 risks, and 2-4 prerequisites.`;

                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Platform Roadmap Manager'
                    },
                    body: JSON.stringify({
                        model: this.selectedModel,
                        messages: [
                            { role: 'system', content: 'You are a project planning expert. Return only valid JSON.' },
                            { role: 'user', content: prompt }
                        ]
                    })
                });

                const data = await response.json();
                const content = data.choices[0].message.content;

                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }

                return {
                    milestones: [],
                    risks: [],
                    prerequisites: []
                };
            },

            selectBestInspirationSources(researchResults) {
                // Take top 8 results and format for inspiration
                return researchResults.slice(0, 8).map(result => ({
                    id: Date.now().toString() + Math.random(),
                    title: result.title,
                    url: result.url,
                    description: result.content?.substring(0, 200) || '',
                    type: result.category || 'reference',
                    imageUrl: null,
                    score: result.score
                }));
            },

            // Inline edit handlers
            startInlineEdit(id, field, current) {
                if (field !== 'name') return;
                const rows = document.getElementById('tableBody').querySelectorAll('tr');
                rows.forEach((tr) => {
                    const cb = tr.querySelector('input[type="checkbox"]');
                    if (!cb) return;
                    const fidMatch = cb.getAttribute('onchange')?.match(/'([^']+)'/);
                    const fid = fidMatch ? fidMatch[1] : null;
                    if (fid === id) {
                        const nameCell = tr.children[1];
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = current;
                        input.className = 'focus-ring';
                        input.style.width = '100%';
                        input.onkeydown = (e) => {
                            if (e.key === 'Enter') { this.inlineSaveName(id, input.value.trim()); }
                            if (e.key === 'Escape') { this.renderTable(); }
                        };
                        input.onblur = () => { this.inlineSaveName(id, input.value.trim()); };
                        nameCell.innerHTML = '';
                        nameCell.appendChild(input);
                        input.focus();
                    }
                });
            },
            inlineSaveName(id, value) {
                if (!value) { this.renderTable(); return; }
                const f = this.features.find(x => x.id === id);
                if (f) {
                    f.name = value;
                    f.updatedAt = new Date().toISOString();
                    this.saveData();
                }
                this.renderTable();
            },
            inlineUpdateType(id, value) {
                const f = this.features.find(x => x.id === id);
                if (!f) return;
                f.type = value;
                f.updatedAt = new Date().toISOString();
                this.saveData();
                this.renderTable();
            },

            // Bulk selection & actions
            toggleSelectAll(checked) {
                const filtered = this.getFilteredFeatures();
                if (checked) { filtered.forEach(f => this.selectedFeatureIds.add(f.id)); }
                else { filtered.forEach(f => this.selectedFeatureIds.delete(f.id)); }
                this.renderTable();
            },
            toggleSelectOne(id, checked) {
                if (checked) this.selectedFeatureIds.add(id); else this.selectedFeatureIds.delete(id);
                this.updateBulkActionsBar();
            },
            updateBulkActionsBar() {
                const bar = document.getElementById('bulkActions');
                if (!bar) return;
                const count = this.selectedFeatureIds.size;
                const label = document.getElementById('bulkCount');
                if (label) label.textContent = count;
                if (count > 0) bar.classList.add('active'); else bar.classList.remove('active');
            },
            async bulkDeleteSelected() {
                if (this.selectedFeatureIds.size === 0) return;
                const ok = await this.showConfirm({ title: 'Delete selected features?', message: `This will delete ${this.selectedFeatureIds.size} feature(s). This cannot be undone.`, confirmText: 'Delete', cancelText: 'Cancel', variant: 'danger' });
                if (!ok) return;
                this.features = this.features.filter(f => !this.selectedFeatureIds.has(f.id));
                this.selectedFeatureIds.clear();
                this.saveData();
                this.renderTable();
                this.showToast('Deleted selected features', 'success');
            },
            exportSelectedToCSV() {
                if (this.selectedFeatureIds.size === 0) return this.exportToCSV();
                const original = this.features;
                const subset = original.filter(f => this.selectedFeatureIds.has(f.id));
                const backup = this.features;
                this.features = subset;
                try { this.exportToCSV(); } finally { this.features = backup; }
            },

            // Confirm modal
            showConfirm({ title = 'Are you sure?', message = '', confirmText = 'OK', cancelText = 'Cancel', variant = 'info', dontAskAgainKey = null } = {}) {
                return new Promise((resolve) => {
                    // Check if user has previously selected "don't ask again"
                    if (dontAskAgainKey) {
                        const dontAskAgain = localStorage.getItem(dontAskAgainKey);
                        if (dontAskAgain === 'true') {
                            resolve(true);
                            return;
                        }
                    }

                    const overlay = document.createElement('div');
                    overlay.className = 'link-picker-overlay';
                    const modal = document.createElement('div');
                    modal.className = 'link-picker-modal';
                    modal.setAttribute('role', 'dialog');
                    modal.setAttribute('aria-modal', 'true');

                    const dontAskAgainCheckbox = dontAskAgainKey ? `
                        <div style="margin-bottom:12px; padding:8px; background:rgba(0,0,0,0.05); border-radius:4px;">
                            <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:12px; color:var(--text-secondary);">
                                <input type="checkbox" id="dontAskAgainCheckbox" style="cursor:pointer;">
                                <span>Don't ask me again</span>
                            </label>
                        </div>
                    ` : '';

                    modal.innerHTML = `
                        <h3>${title}</h3>
                        <div style="color:var(--text-primary); font-size:13px; line-height:1.5; margin-bottom:10px;">${message}</div>
                        ${dontAskAgainCheckbox}
                        <div class="link-picker-actions">
                            <button id="confirm-cancel" style="background:var(--neutral-medium); color:var(--text-inverse);">${cancelText}</button>
                            <button id="confirm-ok" style="background:${variant==='danger' ? 'var(--danger)' : 'var(--success)'}; color:var(--text-inverse);">${confirmText}</button>
                        </div>
                    `;
                    const release = this.trapFocus(modal);
                    const closeAll = (val) => {
                        // Save "don't ask again" preference if checkbox exists and is checked
                        if (dontAskAgainKey && val) {
                            const checkbox = modal.querySelector('#dontAskAgainCheckbox');
                            if (checkbox && checkbox.checked) {
                                localStorage.setItem(dontAskAgainKey, 'true');
                            }
                        }

                        release && release();
                        document.body.removeChild(overlay);
                        document.body.removeChild(modal);
                        resolve(val);
                    };
                    overlay.addEventListener('click', () => closeAll(false));
                    modal.querySelector('#confirm-cancel').addEventListener('click', () => closeAll(false));
                    modal.querySelector('#confirm-ok').addEventListener('click', () => closeAll(true));
                    document.body.appendChild(overlay);
                    document.body.appendChild(modal);
                    setTimeout(() => modal.querySelector('#confirm-ok').focus(), 0);
                    const escHandler = (e) => { if (e.key === 'Escape') { closeAll(false); document.removeEventListener('keydown', escHandler); } };
                    document.addEventListener('keydown', escHandler);
                });
            },

            showAlert({ title = 'Notice', message = '', buttonText = 'OK', variant = 'info' } = {}) {
                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.className = 'link-picker-overlay';
                    const modal = document.createElement('div');
                    modal.className = 'link-picker-modal';
                    modal.setAttribute('role', 'dialog');
                    modal.setAttribute('aria-modal', 'true');
                    modal.innerHTML = `
                        <h3>${title}</h3>
                        <div style="color:var(--text-primary); font-size:13px; line-height:1.5; margin-bottom:10px;">${message}</div>
                        <div class="link-picker-actions">
                            <button id="alert-ok" style="background:${variant==='danger' ? 'var(--danger)' : (variant==='warning' ? 'var(--warning)' : 'var(--info)')}; color:var(--text-inverse); width:100%">${buttonText}</button>
                        </div>
                    `;
                    const release = this.trapFocus(modal);
                    const closeAll = () => { release && release(); document.body.removeChild(overlay); document.body.removeChild(modal); resolve(true); };
                    overlay.addEventListener('click', closeAll);
                    modal.querySelector('#alert-ok').addEventListener('click', closeAll);
                    document.body.appendChild(overlay);
                    document.body.appendChild(modal);
                    setTimeout(() => modal.querySelector('#alert-ok').focus(), 0);
                    const escHandler = (e) => { if (e.key === 'Escape') { closeAll(); document.removeEventListener('keydown', escHandler); } };
                    document.addEventListener('keydown', escHandler);
                });
            },

            // Focus trap utility
            trapFocus(container) {
                const focusableSelector = 'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';
                const focusables = Array.from(container.querySelectorAll(focusableSelector)).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));
                const first = focusables[0];
                const last = focusables[focusables.length - 1];
                const prev = document.activeElement;
                const handler = (e) => {
                    if (e.key !== 'Tab') return;
                    if (e.shiftKey) {
                        if (document.activeElement === first) { e.preventDefault(); last.focus(); }
                    } else {
                        if (document.activeElement === last) { e.preventDefault(); first.focus(); }
                    }
                };
                document.addEventListener('keydown', handler);
                if (first) first.focus();
                return () => {
                    document.removeEventListener('keydown', handler);
                    if (prev && typeof prev.focus === 'function') { try { prev.focus(); } catch {} }
                };
            },

            sortTable(evt, column) {
                if (this.sortColumn === column) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortColumn = column;
                    this.sortDirection = 'asc';
                }

                // Update header styling
                document.querySelectorAll('th').forEach(th => {
                    th.classList.remove('sorted-asc', 'sorted-desc');
                });
                const thEl = (evt && evt.currentTarget) ? evt.currentTarget : (typeof event !== 'undefined' ? event.target : null);
                thEl && thEl.classList.add(`sorted-${this.sortDirection}`);

                this.saveUIState();
                this.renderTable();
            },

            getFilteredFeatures() {
                let filtered = [...this.features];

                // Apply search
                const search = document.getElementById('searchInput').value.toLowerCase();
                if (search) {
                    filtered = filtered.filter(f => {
                        // Search in feature-level fields
                        if (f.name.toLowerCase().includes(search) ||
                            (f.purpose && f.purpose.toLowerCase().includes(search)) ||
                            (f.tags && f.tags.some(t => t.toLowerCase().includes(search)))) {
                            return true;
                        }

                        // Search in timeline items
                        if (f.timelineItems) {
                            return f.timelineItems.some(item =>
                                (item.usp && item.usp.toLowerCase().includes(search)) ||
                                (item.integrationType && item.integrationType.toLowerCase().includes(search)) ||
                                (item.category && item.category.some(c => c.toLowerCase().includes(search)))
                            );
                        }
                        return false;
                    });
                }

                // Apply timeline filter (filter by ANY timeline item matching)
                const timeline = document.getElementById('timelineFilter').value;
                if (timeline) {
                    filtered = filtered.filter(f =>
                        f.timelineItems && f.timelineItems.some(item => item.timeline === timeline)
                    );
                }

                // Apply category filter (filter by ANY timeline item matching)
                const category = document.getElementById('categoryFilter').value;
                if (category) {
                    filtered = filtered.filter(f =>
                        f.timelineItems && f.timelineItems.some(item =>
                            item.category && item.category.includes(category)
                        )
                    );
                }

                // Apply difficulty filter (filter by ANY timeline item matching)
                const difficulty = document.getElementById('difficultyFilter').value;
                if (difficulty) {
                    filtered = filtered.filter(f =>
                        f.timelineItems && f.timelineItems.some(item => item.difficulty === difficulty)
                    );
                }

                // Apply sorting
                if (this.sortColumn) {
                    filtered.sort((a, b) => {
                        const aVal = a[this.sortColumn] || '';
                        const bVal = b[this.sortColumn] || '';
                        const comparison = aVal.toString().localeCompare(bVal.toString());
                        return this.sortDirection === 'asc' ? comparison : -comparison;
                    });
                }

                return filtered;
            },

            applyFilters() {
                this.saveUIState();
                this.renderTable();
            },

            clearFilters() {
                document.getElementById('searchInput').value = '';
                document.getElementById('timelineFilter').value = '';
                document.getElementById('categoryFilter').value = '';
                document.getElementById('difficultyFilter').value = '';
                this.applyFilters();
            },

            populateCategoryFilter() {
                const categoryFilter = document.getElementById('categoryFilter');
                if (!categoryFilter) return;

                // Get current selected value
                const currentValue = categoryFilter.value;

                // Get all unique categories from all timeline items
                const allCategories = this.getAllExistingCategories();

                // Rebuild dropdown
                categoryFilter.innerHTML = '<option value="">All Categories</option>';
                allCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    categoryFilter.appendChild(option);
                });

                // Restore selected value if it still exists
                if (currentValue && allCategories.includes(currentValue)) {
                    categoryFilter.value = currentValue;
                }
            },

            async exportToCSV() {
                if (this.features.length === 0) {
                    await this.showAlert({ title:'Nothing to export', message:'No features to export!' });
                    return;
                }

                const headers = ['Feature Name', 'Type', 'Purpose', 'Timeline', 'Difficulty', 'USP', 'Integration Type', 'Categories', 'Created', 'Updated'];

                // Flatten: one row per timeline item
                const rows = [];
                this.features.forEach(f => {
                    const timelineItems = f.timelineItems || [];

                    if (timelineItems.length === 0) {
                        // Handle features without timeline items (legacy data)
                        rows.push([
                            f.name,
                            f.type || 'Feature',
                            f.purpose || '',
                            '-',
                            '-',
                            '-',
                            '-',
                            '-',
                            new Date(f.createdAt).toLocaleDateString(),
                            new Date(f.updatedAt).toLocaleDateString()
                        ]);
                    } else {
                        // Create one row per timeline item
                        timelineItems.forEach(item => {
                            rows.push([
                                f.name,
                                f.type || 'Feature',
                                f.purpose || '',
                                item.timeline || '-',
                                item.difficulty || '-',
                                item.usp || '-',
                                item.integrationType || '-',
                                (item.category || []).join('; '),
                                new Date(f.createdAt).toLocaleDateString(),
                                new Date(f.updatedAt).toLocaleDateString()
                            ]);
                        });
                    }
                });

                const csv = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
                ].join('\n');

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roadmap-${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            },

            exportAllData() {
                const allData = {
                    version: '2.0', // Updated version for workspace support
                    exportDate: new Date().toISOString(),

                    // Workspace data
                    workspaces: this.workspaces,
                    currentWorkspaceId: this.currentWorkspaceId,

                    // Feature data (includes linkedItems in timelineItems)
                    features: this.features,

                    // AI data
                    memory: this.memory,
                    memorySuggestions: this.memorySuggestions,
                    customInstructions: this.customInstructions,
                    selectedModel: this.selectedModel,

                    // Link data
                    linkSuggestions: this.linkSuggestions,
                    rejectedLinks: this.rejectedLinks,

                    // AI action log
                    aiActionLog: this.aiActionLog,

                    // API keys (optional - user can choose to include)
                    // Note: API keys are stored separately in localStorage for security
                };

                const dataStr = JSON.stringify(allData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                const workspace = this.getCurrentWorkspace();
                const workspaceName = workspace ? workspace.name.replace(/[^a-z0-9]/gi, '-').toLowerCase() : 'all';
                a.download = `roadmap-backup-${workspaceName}-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                console.log('✅ Exported all data:', {
                    workspaces: this.workspaces.length,
                    features: this.features.length,
                    memory: this.memory.length,
                    linkSuggestions: this.linkSuggestions.length,
                    aiActionLog: this.aiActionLog.length
                });

                this.showAlert({
                    title:'Backup exported',
                    message:`Exported ${this.workspaces.length} workspace(s), ${this.features.length} features, ${this.memory.length} memory items, ${this.linkSuggestions.length} link suggestions.`,
                    variant:'success'
                });
            },

            importAllData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const importedData = JSON.parse(event.target.result);

                            // Validate data structure - only features is required
                            if (!importedData.features || !Array.isArray(importedData.features)) {
                                throw new Error('Invalid backup file: Missing or invalid "features" array. Please make sure you selected a valid roadmap backup file.');
                            }

                            // Check version for backward compatibility
                            // If no version field, treat as v1.0 (legacy format before workspace feature)
                            const isV2 = importedData.version === '2.0';
                            const workspaceCount = isV2 ? (importedData.workspaces?.length || 0) : 0;

                            // Confirm before overwriting
                            const confirmMsg = `This will restore:<br>` +
                                (isV2 ? `- ${workspaceCount} workspace(s)<br>` : `- Legacy format detected - a new workspace will be created<br>`) +
                                `- ${importedData.features.length} features<br>` +
                                `- ${importedData.memory?.length || 0} memory items<br>` +
                                `- ${importedData.linkSuggestions?.length || 0} link suggestions<br>` +
                                `- ${importedData.aiActionLog?.length || 0} AI actions<br><br>` +
                                `Current data will be REPLACED!`;

                            // use async confirm via microtask
                            Promise.resolve().then(async () => {
                                const ok = await this.showConfirm({
                                    title:'Import data from backup?',
                                    message: confirmMsg,
                                    confirmText:'Import',
                                    cancelText:'Cancel',
                                    variant:'warning'
                                });
                                if (!ok) return;

                                // Import workspace data (v2.0)
                                if (isV2 && importedData.workspaces) {
                                    this.workspaces = importedData.workspaces;
                                    this.currentWorkspaceId = importedData.currentWorkspaceId || (this.workspaces[0]?.id || null);
                                    localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));
                                    if (this.currentWorkspaceId) {
                                        localStorage.setItem('currentWorkspaceId', this.currentWorkspaceId);
                                    }
                                } else {
                                    // Backward compatibility: Create a default workspace for v1.0 imports
                                    const defaultWorkspace = {
                                        id: Date.now().toString(),
                                        name: 'Imported Roadmap',
                                        description: 'Imported from legacy backup',
                                        color: '#3b82f6',
                                        icon: '📊',
                                        customInstructions: importedData.customInstructions || '',
                                        aiMemory: importedData.memory || [],
                                        createdAt: new Date().toISOString(),
                                        updatedAt: new Date().toISOString()
                                    };
                                    this.workspaces = [defaultWorkspace];
                                    this.currentWorkspaceId = defaultWorkspace.id;

                                    // Assign workspace_id to all imported features
                                    importedData.features.forEach(f => {
                                        f.workspaceId = defaultWorkspace.id;
                                    });

                                    localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));
                                    localStorage.setItem('currentWorkspaceId', this.currentWorkspaceId);
                                }

                                // Import features
                                this.features = importedData.features || [];

                                // Import AI data
                                this.memory = importedData.memory || [];
                                this.memorySuggestions = importedData.memorySuggestions || [];
                                this.customInstructions = importedData.customInstructions || '';
                                if (importedData.selectedModel) {
                                    this.selectedModel = importedData.selectedModel;
                                }

                                // Import link data (v2.0)
                                if (isV2) {
                                    this.linkSuggestions = importedData.linkSuggestions || [];
                                    this.rejectedLinks = importedData.rejectedLinks || [];
                                    this.aiActionLog = importedData.aiActionLog || [];
                                }

                                // Rebuild tags
                                this.allTags = new Set();
                                this.features.forEach(f => {
                                    if (f.tags) f.tags.forEach(t => this.allTags.add(t));
                                    // Also collect categories from timeline items
                                    if (f.timelineItems) {
                                        f.timelineItems.forEach(item => {
                                            if (item.category) {
                                                item.category.forEach(c => this.allTags.add(c));
                                            }
                                        });
                                    }
                                });

                                // Save to localStorage and Supabase
                                this.saveData();
                                this.saveMemory();
                                this.saveMemorySuggestions();
                                this.saveCustomInstructions(this.customInstructions);
                                this.saveModel(this.selectedModel);
                                this.saveLinkSuggestions();
                                this.saveRejectedLinks();
                                this.saveAIActionLog();

                                // Update UI
                                this.renderWorkspaceSelector();
                                this.renderTable();
                                this.updateSuggestionNotification();
                                this.updateLinkNotification();
                                this.updateCounters();
                                this.updateActionLogCounter();

                                // Update custom instructions textarea
                                const textarea = document.getElementById('customInstructionsInput');
                                if (textarea) textarea.value = this.customInstructions;

                                // Update model select
                                const modelSelect = document.getElementById('modelSelect');
                                if (modelSelect) modelSelect.value = this.selectedModel;

                                console.log('✅ Imported all data successfully');
                                this.showAlert({
                                    title:'Import complete',
                                    message:`Restored ${this.workspaces.length} workspace(s), ${this.features.length} features, ${this.memory.length} memory items.`,
                                    variant:'success'
                                });
                            });

                        } catch (error) {
                            console.error('❌ Import error:', error);
                            let errorMsg = error.message;
                            if (error instanceof SyntaxError) {
                                errorMsg = 'The file is not a valid JSON file. Please make sure you selected a backup file exported from this application.';
                            }
                            this.showAlert({
                                title: 'Import failed',
                                message: `${errorMsg}<br><br>If you're trying to import an old backup, make sure it contains at least a "features" array.`,
                                variant: 'danger'
                            });
                        }
                    };

                    reader.readAsText(file);
                };

                input.click();
            },

            toggleChat() {
                const panel = document.getElementById('chatPanel');
                panel.classList.toggle('active');
            },

            async sendMessage() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();

                if (!message) return;

                if (!this.apiKey) {
                    await this.showAlert({ title:'API key required', message:'Please enter your OpenRouter API key first!' });
                    return;
                }

                // Add user message
                this.addChatMessage(message, 'user');
                this.conversationHistory.push({ role: 'user', content: message });
                this.messageCount++;
                this.updateCounters();

                input.value = '';
                input.style.height = 'auto'; // Reset textarea height

                // Check context length warning
                if (this.messageCount >= 20) {
                    document.getElementById('contextWarning')?.classList.remove('hidden');
                }

                // Show loading state
                const inputWrapper = document.querySelector('.chat-input-wrapper');
                const sendButton = inputWrapper?.querySelector('button');
                if (inputWrapper) inputWrapper.classList.add('loading');
                if (sendButton) sendButton.disabled = true;
                
                const loadingId = 'loading-' + Date.now();
                this.addChatMessage('<span class="loading"></span> <span id="loading-text">Composing response...</span>', 'ai', loadingId);
                
                // Update loading text periodically
                const loadingTexts = ['Composing response...', 'Thinking...', 'Processing...'];
                let loadingTextIndex = 0;
                const loadingTextInterval = setInterval(() => {
                    const loadingTextEl = document.getElementById('loading-text');
                    if (loadingTextEl) {
                        loadingTextIndex = (loadingTextIndex + 1) % loadingTexts.length;
                        loadingTextEl.textContent = loadingTexts[loadingTextIndex];
                    }
                }, 2000);

                try {
                    // Build system prompt with custom instructions and memory
                    let systemPrompt = '';

                    // CRITICAL: Platform Vision Context
                    systemPrompt += `🎯 PLATFORM VISION:\n`;
                    systemPrompt += `You are helping build a comprehensive trade platform that integrates sourcing, payments, research, customs, chat, logistics, and last mile delivery into a single unified platform.\n`;
                    systemPrompt += `This is a complete end-to-end solution for international trade management.\n\n`;

                    if (this.customInstructions) {
                        systemPrompt += this.customInstructions + '\n\n';
                    } else {
                        systemPrompt += `You are a Product Development Assistant for this trade platform roadmap manager.\n\n`;
                    }

                    systemPrompt += `📋 CURRENT ROADMAP CONTEXT:\n`;
                    systemPrompt += this.formatFeaturesForContext();
                    systemPrompt += `\n`;

                    if (this.memory.length > 0) {
                        systemPrompt += `🧠 MEMORY (Important information from previous conversations):\n`;
                        this.memory.forEach((item, index) => {
                            systemPrompt += `${index + 1}. ${item.content}\n`;
                        });
                        systemPrompt += `\n`;
                    }

                    systemPrompt += `📝 INSTRUCTIONS:\n`;
                    systemPrompt += `1. **ALWAYS** understand the platform context: You are helping build a unified trade platform with sourcing, payments, research, customs, chat, logistics, and last mile delivery\n`;
                    systemPrompt += `2. **ALWAYS** reference the roadmap features when answering questions - know what features are being developed\n`;
                    systemPrompt += `3. When user asks about competitors or similar platforms, understand they're building a COMPREHENSIVE TRADE PLATFORM and compare accordingly\n`;
                    systemPrompt += `4. Analyze features, suggest improvements, answer questions about the roadmap\n`;
                    systemPrompt += `5. Be concise and actionable\n`;
                    systemPrompt += `6. Learn from every conversation - identify important information that should be remembered\n`;
                    systemPrompt += `7. Important information includes: user preferences, project-specific details, integration decisions, architectural choices, platform vision details, competitive insights, etc.\n`;
                    
                    // Add search capability info
                    if (this.tavilyApiKey) {
                        systemPrompt += `\n🔍 INTERNET SEARCH:\n`;
                        systemPrompt += `You have access to internet search via the search_internet tool. Use it when you need:\n`;
                        systemPrompt += `- Current information or recent news\n`;
                        systemPrompt += `- Up-to-date documentation or technical details\n`;
                        systemPrompt += `- Real-time data or facts not in your training data\n`;
                        systemPrompt += `- Verification of current information\n`;
                        systemPrompt += `- Finding competitors or similar platforms (especially trade platforms)\n\n`;
                        systemPrompt += `**IMPORTANT SEARCH BEST PRACTICES:**\n`;
                        systemPrompt += `- Make ONE comprehensive search query instead of multiple separate searches\n`;
                        systemPrompt += `- Combine related topics into a single well-crafted query\n`;
                        systemPrompt += `- Example: Instead of 3 searches ("trade platforms", "B2B software", "import/export tools"), use ONE: "B2B trade platforms import export software comparison"\n`;
                        systemPrompt += `- Only make multiple searches if topics are genuinely unrelated\n`;
                        systemPrompt += `- Results will be more comprehensive and contextual with fewer, better queries\n`;
                    }
                    
                    if (this.aiEditingEnabled) {
                        systemPrompt += `\n✨ EDITING CAPABILITIES:\n`;
                        systemPrompt += `You have the ability to directly modify the roadmap using these tools:\n`;
                        systemPrompt += `- update_feature: Modify feature name, type, or purpose\n`;
                        systemPrompt += `- update_timeline_item: Change timeline item details (difficulty, categories, USP, integration)\n`;
                        systemPrompt += `- create_feature: Add a completely new feature with timeline items\n`;
                        systemPrompt += `- create_feature_with_research: Create comprehensive feature with AI research (see below)\n`;
                        systemPrompt += `- create_link_suggestion: Create cross-feature dependencies or complementary relationships\n`;
                        systemPrompt += `- add_timeline_item: Add new timeline phases to existing features\n`;
                        systemPrompt += `- delete_timeline_item: Remove timeline items (use cautiously)\n\n`;
                        systemPrompt += `⚠️ IMPORTANT - enhance_feature_with_research:\n`;
                        systemPrompt += `- This tool is ONLY available through the Enhancement Panel\n`;
                        systemPrompt += `- You CANNOT call it directly from chat\n`;
                        systemPrompt += `- User must click "AI Enhance" button to start the guided process\n`;
                        systemPrompt += `- If user asks to enhance a feature, direct them to use the button\n\n`;
                        systemPrompt += `TOOL USAGE GUIDELINES:\n`;
                        systemPrompt += `- Always confirm user intent before proposing changes\n`;
                        systemPrompt += `- Provide clear reasons for each proposed change\n`;
                        systemPrompt += `- Be specific and actionable in your suggestions\n`;
                        systemPrompt += `- For ambiguous requests, ask clarifying questions first\n`;
                        systemPrompt += `- Use tools when the user explicitly requests changes or improvements\n`;
                    }

                    // Add AI-Assisted Feature Creation instructions
                    if (this.aiFeatureCreationMode) {
                        systemPrompt += `\n🎨 AI-ASSISTED FEATURE CREATION MODE:\n`;
                        systemPrompt += `You are helping the user create a comprehensive feature with automated research.\n\n`;
                        systemPrompt += `WORKFLOW:\n`;
                        systemPrompt += `1. Ask 5-7 clarifying questions to understand the feature:\n`;
                        systemPrompt += `   - What is the feature name and main purpose?\n`;
                        systemPrompt += `   - Who are the target users and what problem does it solve?\n`;
                        systemPrompt += `   - What's the expected timeline (MVP/SHORT/LONG)?\n`;
                        systemPrompt += `   - Any specific integration requirements or dependencies?\n`;
                        systemPrompt += `   - Any budget or resource constraints?\n`;
                        systemPrompt += `   - Any similar platforms or features they like?\n`;
                        systemPrompt += `   - Any specific technologies they want to use?\n\n`;
                        systemPrompt += `2. After gathering answers, use create_feature_with_research tool:\n`;
                        systemPrompt += `   - This tool will automatically:\n`;
                        systemPrompt += `     * Research competitors and similar implementations\n`;
                        systemPrompt += `     * Find relevant technologies and tools\n`;
                        systemPrompt += `     * Generate 5-8 execution steps with time estimates\n`;
                        systemPrompt += `     * Suggest required resources (team, tech, budget)\n`;
                        systemPrompt += `     * Create planning milestones and identify risks\n`;
                        systemPrompt += `     * Find inspiration sources and references\n`;
                        systemPrompt += `   - The user can then review and edit everything in the detail view\n\n`;
                        systemPrompt += `3. Be conversational and helpful:\n`;
                        systemPrompt += `   - Ask questions one at a time or in small groups\n`;
                        systemPrompt += `   - Clarify ambiguous answers\n`;
                        systemPrompt += `   - Provide examples to help user think through requirements\n`;
                        systemPrompt += `   - Once you have enough information, call the tool immediately\n\n`;
                        systemPrompt += `SEARCH BEST PRACTICES (for research):\n`;
                        systemPrompt += `- For trading/finance features: "stock market data API", "trading platform", "financial data providers"\n`;
                        systemPrompt += `- For social features: "real-time messaging", "WebSocket chat", "notification systems"\n`;
                        systemPrompt += `- For analytics: "data visualization", "dashboard libraries", "analytics platforms"\n`;
                        systemPrompt += `- For e-commerce: "payment gateway", "checkout flow", "inventory management"\n`;
                        systemPrompt += `- Always use specific technical terms, not generic phrases\n`;
                        systemPrompt += `- Search for actual competitor platforms, not just implementation guides\n\n`;
                    }

                    if (this.aiFeatureEnhancementMode) {
                        const feature = this.features.find(f => f.id === this.currentFeatureId);
                        const featureContext = feature ? `
Current Feature Being Enhanced:
- Name: ${feature.name}
- Type: ${feature.type}
- Purpose: ${feature.purpose || 'Not specified'}
- Timeline Items: ${feature.timelineItems?.length || 0}
- Execution Steps: ${feature.executionSteps?.length || 0} (${feature.executionSteps?.length === 0 ? 'MISSING - needs generation' : 'exists'})
- Resources: ${feature.resources ? 'Exists' : 'MISSING - needs generation'}
- Planning: ${feature.planning ? 'Exists' : 'MISSING - needs generation'}
- Inspiration: ${feature.inspiration?.length || 0} sources (${feature.inspiration?.length === 0 ? 'MISSING - needs generation' : 'exists'})
` : '';

                        systemPrompt += `\n🔧 AI FEATURE ENHANCEMENT MODE:\n`;
                        systemPrompt += `⚠️ CRITICAL: Feature enhancement is DISABLED in chat mode.\n\n`;
                        systemPrompt += `${featureContext}\n`;
                        systemPrompt += `IMPORTANT RULES:\n`;
                        systemPrompt += `- You CANNOT enhance features through chat conversation\n`;
                        systemPrompt += `- You CANNOT call enhance_feature_with_research directly\n`;
                        systemPrompt += `- Enhancement REQUIRES the user to use the "AI Enhance" button on the feature\n`;
                        systemPrompt += `- This ensures proper context gathering through targeted questions\n\n`;
                        systemPrompt += `WHAT YOU CAN DO:\n`;
                        systemPrompt += `- Answer questions about the feature\n`;
                        systemPrompt += `- Suggest improvements or ideas\n`;
                        systemPrompt += `- Provide analysis and recommendations\n`;
                        systemPrompt += `- Help user understand what's missing\n\n`;
                        systemPrompt += `WHAT YOU SHOULD SAY:\n`;
                        systemPrompt += `If user asks you to enhance or improve a feature, respond:\n`;
                        systemPrompt += `"To properly enhance this feature, please click the 'AI Enhance' button on the feature card. This will start a guided process where I'll ask you targeted questions to gather all necessary context before making comprehensive improvements."\n\n`;
                        systemPrompt += `WHY THIS MATTERS:\n`;
                        systemPrompt += `- Ensures I ask relevant questions specific to the feature's gaps\n`;
                        systemPrompt += `- Prevents making changes without sufficient context\n`;
                        systemPrompt += `- Allows user to review all questions before research begins\n`;
                        systemPrompt += `- Creates better quality enhancements with proper information\n\n`;
                    }

                    const messages = [
                        { role: 'system', content: systemPrompt },
                        ...this.conversationHistory
                    ];

                    const requestBody = {
                        model: this.selectedModel,
                        messages: messages,
                        stream: true  // Enable streaming
                    };
                    
                    // Add tools - always include search if API key is available, and editing tools if enabled
                    const tools = this.getAITools();
                    // Filter tools based on availability
                    const availableTools = tools.filter(tool => {
                        if (tool.function.name === 'search_internet') {
                            return !!this.tavilyApiKey; // Only include search if API key is available
                        }
                        return this.aiEditingEnabled; // Only include editing tools if editing is enabled
                    });
                    
                    if (availableTools.length > 0) {
                        requestBody.tools = availableTools;
                        requestBody.tool_choice = 'auto';
                    }

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    // Clear loading interval
                    clearInterval(loadingTextInterval);
                    
                    // Remove loading message and restore input state
                    const loadingEl = document.getElementById(loadingId);
                    if (loadingEl) loadingEl.remove();
                    if (inputWrapper) inputWrapper.classList.remove('loading');
                    if (sendButton) sendButton.disabled = false;

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.statusText}`);
                    }

                    // Process streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let fullContent = '';
                    let toolCalls = [];
                    let toolCallBuffer = {};
                    
                    // Create streaming message element
                    const streamMessageId = 'stream-' + Date.now();
                    this.addChatMessage('', 'ai', streamMessageId);
                    const streamMessageEl = document.getElementById(streamMessageId);
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep incomplete line in buffer
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') continue;
                                    
                                    try {
                                        const json = JSON.parse(data);
                                        const delta = json.choices?.[0]?.delta;
                                        
                                        if (delta) {
                                            // Handle content delta
                                            if (delta.content) {
                                                fullContent += delta.content;
                                                if (streamMessageEl) {
                                                    const formatted = this.formatMessage(fullContent);
                                                    streamMessageEl.innerHTML = this.sanitizeHtml(formatted) || fullContent;
                                                    // Auto-scroll
                                                    const messagesContainer = document.getElementById('chatMessages');
                                                    if (messagesContainer) {
                                                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                                    }
                                                }
                                            }
                                            
                                            // Handle tool calls
                                            if (delta.tool_calls) {
                                                for (const toolCallDelta of delta.tool_calls) {
                                                    const index = toolCallDelta.index;
                                                    if (!toolCallBuffer[index]) {
                                                        toolCallBuffer[index] = { id: '', function: { name: '', arguments: '' } };
                                                    }
                                                    
                                                    if (toolCallDelta.id) {
                                                        toolCallBuffer[index].id = toolCallDelta.id;
                                                    }
                                                    
                                                    if (toolCallDelta.function) {
                                                        if (toolCallDelta.function.name) {
                                                            toolCallBuffer[index].function.name = toolCallDelta.function.name;
                                                        }
                                                        if (toolCallDelta.function.arguments) {
                                                            toolCallBuffer[index].function.arguments += toolCallDelta.function.arguments;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        // Skip malformed JSON
                                        console.warn('Failed to parse stream data:', e);
                                    }
                                }
                            }
                        }
                    } finally {
                        reader.releaseLock();
                    }
                    
                    // Process completed tool calls
                    toolCalls = Object.values(toolCallBuffer).filter(tc => tc.id && tc.function.name);
                    
                    if (toolCalls.length > 0) {
                        // AI wants to use tools - separate read-only tools from editing tools
                        console.log(`AI wants to make ${toolCalls.length} tool call(s)`);
                        
                        const editingTools = [];
                        const readOnlyTools = [];
                        
                        // Process all tool calls
                        for (const toolCall of toolCalls) {
                            const functionName = toolCall.function.name;
                            let functionArgs;
                            try {
                                functionArgs = JSON.parse(toolCall.function.arguments);
                            } catch (e) {
                                console.error('Failed to parse tool arguments:', e);
                                continue;
                            }
                            
                            console.log('AI tool call:', functionName, functionArgs);
                            
                            // Search is read-only, execute immediately
                            if (functionName === 'search_internet') {
                                readOnlyTools.push({ toolCall, functionName, functionArgs });
                            } else {
                                // Editing tools need approval
                                editingTools.push({ toolCall, functionName, functionArgs });
                            }
                        }
                        
                        // Execute read-only tools - batch searches if multiple
                        if (readOnlyTools.length > 0) {
                            try {
                                if (readOnlyTools.length === 1) {
                                    // Single search - use regular execution
                                    await this.executeSearchInternet(readOnlyTools[0].functionArgs);
                                } else {
                                    // Multiple searches - batch them
                                    const searchPromises = readOnlyTools.map(tool =>
                                        this.executeSearchInternetSilent(tool.functionArgs)
                                    );
                                    const searchResults = await Promise.all(searchPromises);
                                    this.displayBatchedSearchResults(searchResults);
                                }
                            } catch (error) {
                                console.error('Search execution error:', error);
                                this.addChatMessage(`❌ Search error: ${error.message}`, 'ai');
                            }
                        }
                        
                        // Queue editing tools for approval
                        for (const tool of editingTools) {
                            this.pendingAIActions.push({ 
                                actionType: tool.functionName, 
                                actionData: tool.functionArgs, 
                                reason: tool.functionArgs.reason || 'No reason provided',
                                timestamp: new Date().toISOString() 
                            });
                        }
                        
                        // Show first editing action approval dialog if any
                        if (this.pendingAIActions.length > 0) {
                            const firstAction = this.pendingAIActions[0];
                            this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                        }
                        
                        // Store the conversation with tool call for context
                        this.conversationHistory.push({
                            role: 'assistant',
                            content: fullContent || `I'd like to make ${editingTools.length} change(s).`,
                            tool_calls: toolCalls
                        });
                    } else {
                        // Normal text response
                        this.conversationHistory.push({ role: 'assistant', content: fullContent });
                        this.messageCount++;
                        this.updateCounters();
                    }

                    // Trigger memory analysis every 5 messages
                    if (this.messageCount - this.lastAnalysisCount >= 5) {
                        this.lastAnalysisCount = this.messageCount;
                        // Run analysis in background without blocking
                        setTimeout(() => this.analyzeConversationForMemory(), 1000);
                    }

                } catch (error) {
                    // Clear loading interval
                    clearInterval(loadingTextInterval);
                    
                    // Remove loading message and restore input state
                    const loadingEl = document.getElementById(loadingId);
                    if (loadingEl) loadingEl.remove();
                    if (inputWrapper) inputWrapper.classList.remove('loading');
                    if (sendButton) sendButton.disabled = false;
                    
                    this.addChatMessage(`❌ Error: ${error.message}. Please check your API key.`, 'ai');
                }
            },

            updateCounters() {
                document.getElementById('messageCounter').textContent = this.messageCount;
                document.getElementById('memoryCounter').textContent = this.memory.length;
                this.updateMemoryContextIndicator();
            },

            updateMemoryContextIndicator() {
                const indicator = document.getElementById('memoryContextIndicator');
                const text = document.getElementById('memoryContextText');
                if (!indicator || !text) return;

                if (this.memory.length === 0) {
                    text.textContent = 'No memory items • Click to add';
                    indicator.classList.remove('has-memory');
                    indicator.title = 'Click to add memory items that persist across conversations';
                } else {
                    text.textContent = `${this.memory.length} memory item${this.memory.length !== 1 ? 's' : ''} included in context`;
                    indicator.classList.add('has-memory');
                    indicator.title = `Click to manage ${this.memory.length} memory item${this.memory.length !== 1 ? 's' : ''}`;
                }
            },

            setupChatPanelResize() {
                const resizer = document.getElementById('chatPanelResizer');
                const panel = document.getElementById('chatPanel');
                if (!resizer || !panel) return;

                let isResizing = false;
                let startX = 0;
                let startWidth = 0;

                const startResize = (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = panel.offsetWidth;
                    resizer.classList.add('dragging');
                    panel.style.transition = 'none';
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                    e.stopPropagation();
                };

                const doResize = (e) => {
                    if (!isResizing) return;
                    const diff = startX - e.clientX; // Reverse because we're resizing from left
                    const newWidth = Math.max(300, Math.min(window.innerWidth * 0.9, startWidth + diff));
                    panel.style.width = newWidth + 'px';
                    e.preventDefault();
                };

                const stopResize = () => {
                    if (isResizing) {
                        isResizing = false;
                        resizer.classList.remove('dragging');
                        panel.style.transition = '';
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                };

                resizer.addEventListener('mousedown', startResize);
                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopResize);
                
                // Also handle mouseleave to stop resize if mouse leaves window
                document.addEventListener('mouseleave', stopResize);
            },

            formatTables(text) {
                // Detect and convert markdown tables to HTML
                const lines = text.split('\n');
                let result = [];
                let inTable = false;
                let tableRows = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    // Check if this line is a table row (contains | characters)
                    if (line.includes('|') && line.split('|').length > 2) {
                        const cells = line.split('|').map(c => c.trim()).filter(c => c);

                        // Check if this is a separator line (---|---|---)
                        const isSeparator = cells.every(cell => /^[-:]+$/.test(cell));

                        if (isSeparator) {
                            continue; // Skip separator lines
                        }

                        if (!inTable) {
                            // Start of table
                            inTable = true;
                            tableRows = [];
                        }

                        tableRows.push(cells);
                    } else {
                        // End of table or regular line
                        if (inTable && tableRows.length > 0) {
                            // Convert accumulated rows to HTML table
                            let tableHtml = '<table>';

                            // First row is header
                            tableHtml += '<thead><tr>';
                            tableRows[0].forEach(cell => {
                                tableHtml += `<th>${cell}</th>`;
                            });
                            tableHtml += '</tr></thead>';

                            // Rest are body rows
                            if (tableRows.length > 1) {
                                tableHtml += '<tbody>';
                                for (let j = 1; j < tableRows.length; j++) {
                                    tableHtml += '<tr>';
                                    tableRows[j].forEach(cell => {
                                        tableHtml += `<td>${cell}</td>`;
                                    });
                                    tableHtml += '</tr>';
                                }
                                tableHtml += '</tbody>';
                            }

                            tableHtml += '</table>';
                            result.push(`<div class="table-wrapper">${tableHtml}</div>`);
                            tableRows = [];
                            inTable = false;
                        }
                        result.push(line);
                    }
                }

                // Handle case where table is at end of text
                if (inTable && tableRows.length > 0) {
                    let tableHtml = '<table>';
                    tableHtml += '<thead><tr>';
                    tableRows[0].forEach(cell => {
                        tableHtml += `<th>${cell}</th>`;
                    });
                    tableHtml += '</tr></thead>';

                    if (tableRows.length > 1) {
                        tableHtml += '<tbody>';
                        for (let j = 1; j < tableRows.length; j++) {
                            tableHtml += '<tr>';
                            tableRows[j].forEach(cell => {
                                tableHtml += `<td>${cell}</td>`;
                            });
                            tableHtml += '</tr>';
                        }
                        tableHtml += '</tbody>';
                    }
                    tableHtml += '</table>';
                    result.push(`<div class="table-wrapper">${tableHtml}</div>`);
                }

                return result.join('\n');
            },

            formatMessage(text) {
                // Convert markdown-like syntax to HTML
                let formatted = text;

                // Tables (must be processed before other formatting)
                formatted = this.formatTables(formatted);

                // Code blocks (```code```)
                formatted = formatted.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');

                // Inline code (`code`)
                formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');

                // Bold (**text** or __text__)
                formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                formatted = formatted.replace(/__([^_]+)__/g, '<strong>$1</strong>');

                // Italic (*text* or _text_)
                formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                formatted = formatted.replace(/_([^_]+)_/g, '<em>$1</em>');

                // Headers (### Header)
                formatted = formatted.replace(/^### (.+)$/gm, '<h3>$1</h3>');
                formatted = formatted.replace(/^## (.+)$/gm, '<h2>$1</h2>');
                formatted = formatted.replace(/^# (.+)$/gm, '<h1>$1</h1>');

                // Bullet points (- item or * item)
                const lines = formatted.split('\n');
                let inList = false;
                let result = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const bulletMatch = line.match(/^[\s]*[-*]\s+(.+)$/);
                    const numberMatch = line.match(/^[\s]*\d+\.\s+(.+)$/);

                    if (bulletMatch) {
                        if (!inList) {
                            result.push('<ul>');
                            inList = 'ul';
                        } else if (inList === 'ol') {
                            result.push('</ol><ul>');
                            inList = 'ul';
                        }
                        result.push(`<li>${bulletMatch[1]}</li>`);
                    } else if (numberMatch) {
                        if (!inList) {
                            result.push('<ol>');
                            inList = 'ol';
                        } else if (inList === 'ul') {
                            result.push('</ul><ol>');
                            inList = 'ol';
                        }
                        result.push(`<li>${numberMatch[1]}</li>`);
                    } else {
                        if (inList) {
                            result.push(inList === 'ul' ? '</ul>' : '</ol>');
                            inList = false;
                        }
                        if (line.trim() === '') {
                            result.push('<br>');
                        } else {
                            result.push(line);
                        }
                    }
                }

                if (inList) {
                    result.push(inList === 'ul' ? '</ul>' : '</ol>');
                }

                formatted = result.join('\n');

                // Convert double line breaks to paragraphs
                formatted = formatted.replace(/\n\n+/g, '</p><p>');
                formatted = '<p>' + formatted + '</p>';

                // Clean up empty paragraphs
                formatted = formatted.replace(/<p><\/p>/g, '');
                formatted = formatted.replace(/<p>\s*<br>\s*<\/p>/g, '<br>');

                return formatted;
            },

            sanitizeHtml(html) {
                try {
                    const allowed = new Set(['p','br','strong','em','code','pre','table','thead','tbody','tr','th','td','ul','ol','li','h1','h2','h3']);
                    const tpl = document.createElement('template');
                    tpl.innerHTML = html;
                    const walk = (node) => {
                        const children = Array.from(node.childNodes);
                        for (const child of children) {
                            if (child.nodeType === 1) {
                                const tag = child.tagName.toLowerCase();
                                if (!allowed.has(tag)) {
                                    child.replaceWith(document.createTextNode(child.textContent || ''));
                                    continue;
                                }
                                // strip attributes
                                Array.from(child.attributes).forEach(attr => child.removeAttribute(attr.name));
                                walk(child);
                            }
                        }
                    };
                    walk(tpl.content);
                    return tpl.innerHTML;
                } catch { return ''; }
            },

            addChatMessage(text, sender, id = null) {
                const messagesContainer = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}`;
                if (id) messageDiv.id = id;

                // Format AI messages, keep user messages as-is
                if (sender === 'ai' && !text.includes('<span class="loading">')) {
                    const formatted = this.formatMessage(text);
                    const safe = this.sanitizeHtml(formatted) || '';
                    if (safe) messageDiv.innerHTML = safe; else messageDiv.textContent = text;
                } else {
                    messageDiv.innerHTML = text;
                }

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        };

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>
