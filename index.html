<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platform Roadmap Manager</title>
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/views.css">
    <link rel="stylesheet" href="css/components/workflow-guide.css">
    <link rel="stylesheet" href="css/components/workflow-tabs.css">
    <link rel="stylesheet" href="css/components/graph-view.css">
    <link rel="stylesheet" href="css/components/insights-panel.css">
    <link rel="stylesheet" href="css/components/ai-enhancement.css">
    <link rel="stylesheet" href="css/components/loading-states.css">
    <link rel="stylesheet" href="css/components/form-validation.css">
    <link rel="stylesheet" href="css/components/mobile-navigation.css">

    <!-- Enhanced Interface CSS - Disabled: Causes style conflicts -->
    <!-- -->
</head>
<body>
    <div class="app-shell">
        <div class="app-container">
            <header class="header">
                <div class="header-left">
                    <h1>Platform Roadmap</h1>
                    <div id="workspaceSelector" class="workspace-selector-container"></div>
                </div>
                <div class="header-center">
                    <input 
                        type="search" 
                        id="searchInput" 
                        class="header-search" 
                        placeholder="Search features..."
                        oninput="featureTable.applyFilters(app)"
                    />
                </div>
                <div class="header-right">
                    <div class="primary-actions">
                        <button class="btn btn-primary" onclick="app.showAddModal()">
                            <span class="btn-icon">Ôºã</span>
                            <span>Add</span>
                        </button>
                        <button class="btn btn-outline" onclick="app.showAIMenu(event)">
                            <span class="btn-icon">‚ú®</span>
                            <span>AI</span>
                        </button>
                    </div>
                    <div class="data-actions">
                        <button class="btn btn-ghost" onclick="featureTable.exportToCSV(app)">
                            <span class="btn-icon">‚á£</span>
                            <span>Export</span>
                        </button>
                        <button class="btn btn-ghost" onclick="app.showImportModal()">
                            <span class="btn-icon">‚á°</span>
                            <span>Import</span>
                        </button>
                    </div>
                    <div class="quick-actions">
                        <button class="btn btn-icon-only" onclick="app.toggleKanbanView()" title="Toggle board view">‚ñ§</button>
                        <button class="btn btn-icon-only" onclick="app.openSettings()" title="Settings">‚öô</button>
                        <div id="syncStatus" class="sync-status sync-status-offline">
                            <span>‚óè</span><span>Offline</span>
                        </div>
                    </div>
                </div>
            </header>

            <main class="content">
                <div id="tableView" class="table-view"> class="table-container">
                <!-- Workspace Creation Banner -->
                <div class="workspace-banner" id="workspaceBanner">
                    <div class="workspace-banner-content">
                        <div class="workspace-banner-icon">üèóÔ∏è</div>
                        <div class="workspace-banner-text">
                            <h3>Create a Workspace</h3>
                            <p>Organize your features into workspaces for better project management</p>
                        </div>
                        <button class="btn-primary" onclick="app.showWorkspaceModal()">
                            <span class="btn-icon">‚ûï</span>
                            Create Workspace
                        </button>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th style="width:36px;"> <input type="checkbox" id="selectAll" onchange="app.toggleSelectAll(this.checked)" class="focus-ring" aria-label="Select all"> </th>
                            <th class="sortable" onclick="app.sortTable(event,'name')">Name</th>
                            <th class="sortable" onclick="app.sortTable(event,'type')">Type</th>
                            <th class="th-with-filter">
                                <span class="th-label">Timeline</span>
                                <select id="timelineFilter" class="th-filter" onchange="app.applyFilters()">
                                    <option value="">All</option>
                                    <option value="MVP">MVP</option>
                                    <option value="SHORT">SHORT</option>
                                    <option value="LONG">LONG</option>
                                </select>
                            </th>
                            <th class="th-with-filter">
                                <span class="th-label">Difficulty</span>
                                <select id="difficultyFilter" class="th-filter" onchange="app.applyFilters()">
                                    <option value="">All</option>
                                    <option value="Easy">Easy</option>
                                    <option value="Medium">Medium</option>
                                    <option value="Hard">Hard</option>
                                </select>
                            </th>
                            <th>Purpose</th>
                            <th>USP</th>
                            <th>Integration Type</th>
                            <th class="th-with-filter">
                                <span class="th-label">Category</span>
                                <select id="categoryFilter" class="th-filter" onchange="app.applyFilters()">
                                    <option value="">All</option>
                                </select>
                            </th>
                            <th>Linked Items</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Rows will be inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- Detail View -->
            <div id="detailView" class="detail-view hidden">
                <div class="detail-header">
                    <button class="back-btn" onclick="app.showTableView()" aria-label="Back to table">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 18l-8-8 8-8 1.4 1.4L5.8 9H18v2H5.8l5.6 5.6L10 18z"/>
                        </svg>
                        Back
                    </button>
                    <div class="detail-header-content">
                        <h1 id="detailFeatureName"></h1>
                        <div class="detail-badges" id="detailBadges"></div>
                    </div>
                    <div class="detail-header-actions">
                        <button class="btn-ai-create btn-compact" onclick="app.startAIEnhancementWorkflow(app.currentFeatureId)" title="AI Enhance Feature">
                            ‚ú® AI Enhance
                        </button>
                        <button class="btn-secondary" onclick="app.editFeatureFromDetail()" title="Edit feature">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5L13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5z"/>
                            </svg>
                            Edit
                        </button>
                    </div>
                </div>

                <!-- Tracking Section -->
                <div class="tracking-section" id="trackingSection">
                    <div class="tracking-grid">
                        <!-- Core Status -->
                        <div class="tracking-field">
                            <label>Status</label>
                            <select id="featureStatus" onchange="app.updateFeatureTracking('status', this.value)">
                                <option value="not_started">Not Started</option>
                                <option value="planning">Planning</option>
                                <option value="in_progress">In Progress</option>
                                <option value="blocked">Blocked</option>
                                <option value="review">Review</option>
                                <option value="completed">Completed</option>
                                <option value="on_hold">On Hold</option>
                                <option value="cancelled">Cancelled</option>
                            </select>
                        </div>

                        <div class="tracking-field">
                            <label>Priority</label>
                            <select id="featurePriority" onchange="app.updateFeatureTracking('priority', this.value)">
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                                <option value="critical">Critical</option>
                            </select>
                        </div>

                        <div class="tracking-field">
                            <label>Health</label>
                            <select id="featureHealth" onchange="app.updateFeatureTracking('health', this.value)">
                                <option value="on_track">‚úÖ On Track</option>
                                <option value="at_risk">‚ö†Ô∏è At Risk</option>
                                <option value="off_track">üî¥ Off Track</option>
                                <option value="unknown">‚ùì Unknown</option>
                            </select>
                        </div>

                        <div class="tracking-field">
                            <label>Business Value</label>
                            <select id="featureBusinessValue" onchange="app.updateFeatureTracking('businessValue', this.value)">
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                                <option value="critical">Critical</option>
                            </select>
                        </div>

                        <!-- Ownership -->
                        <div class="tracking-field">
                            <label>Owner</label>
                            <input type="text" id="featureOwner" placeholder="Feature owner" onchange="app.updateFeatureTracking('owner', this.value)">
                        </div>

                        <div class="tracking-field">
                            <label>Target Release</label>
                            <input type="text" id="featureTargetRelease" placeholder="e.g., Q1 2025" onchange="app.updateFeatureTracking('targetRelease', this.value)">
                        </div>

                        <!-- Timeline -->
                        <div class="tracking-field">
                            <label>Planned Start</label>
                            <input type="date" id="featurePlannedStart" onchange="app.updateFeatureTracking('plannedStartDate', this.value)">
                        </div>

                        <div class="tracking-field">
                            <label>Planned End</label>
                            <input type="date" id="featurePlannedEnd" onchange="app.updateFeatureTracking('plannedEndDate', this.value)">
                        </div>

                        <!-- Effort -->
                        <div class="tracking-field">
                            <label>Story Points</label>
                            <input type="number" id="featureStoryPoints" min="0" step="0.5" placeholder="0" onchange="app.updateFeatureTracking('storyPoints', parseFloat(this.value) || null)">
                        </div>

                        <div class="tracking-field">
                            <label>Estimated Hours</label>
                            <input type="number" id="featureEstimatedHours" min="0" step="1" placeholder="0" onchange="app.updateFeatureTracking('estimatedHours', parseFloat(this.value) || null)">
                        </div>

                        <div class="tracking-field">
                            <label>Actual Hours</label>
                            <input type="number" id="featureActualHours" min="0" step="1" placeholder="0" onchange="app.updateFeatureTracking('actualHours', parseFloat(this.value) || null)">
                        </div>

                        <div class="tracking-field">
                            <label>Effort Confidence</label>
                            <select id="featureEffortConfidence" onchange="app.updateFeatureTracking('effortConfidence', this.value)">
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                    </div>

                    <!-- Progress Bar -->
                    <div class="progress-section">
                        <div class="progress-header">
                            <label>Progress</label>
                            <span id="progressPercent" class="progress-percent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                        </div>
                        <div class="progress-details">
                            <span id="progressSteps">0 of 0 steps completed</span>
                        </div>
                    </div>

                    <!-- Team Members -->
                    <div class="team-section">
                        <div class="team-field">
                            <label>Contributors</label>
                            <div class="tags-input-wrapper">
                                <input type="text" id="contributorsInput" placeholder="Type name and press Enter" onkeydown="if(event.key==='Enter'){event.preventDefault();app.addContributor();}">
                                <div id="contributorsList" class="tags-list"></div>
                            </div>
                        </div>
                        <div class="team-field">
                            <label>Stakeholders</label>
                            <div class="tags-input-wrapper">
                                <input type="text" id="stakeholdersInput" placeholder="Type name and press Enter" onkeydown="if(event.key==='Enter'){event.preventDefault();app.addStakeholder();}">
                                <div id="stakeholdersList" class="tags-list"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Tags Section -->
                    <div class="team-field" style="grid-column: 1 / -1;">
                        <label>Tags</label>
                        <div class="tags-input-wrapper">
                            <input type="text" id="tagsInput" placeholder="Type tag and press Enter" onkeydown="if(event.key==='Enter'){event.preventDefault();app.addTag();}">
                            <div id="tagsList" class="tags-list"></div>
                        </div>
                    </div>
                </div>

                <div class="detail-tabs">
                    <button class="detail-tab active" onclick="app.switchDetailTab('overview')">Overview</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('execution')">Execution Guide</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('resources')">Resources</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('planning')">Planning</button>
                    <button class="detail-tab" onclick="app.switchDetailTab('inspiration')">Inspiration</button>
                </div>

                <div class="detail-content">
                    <!-- Overview Tab -->
                    <div id="overviewTab" class="detail-tab-content active">
                        <div class="detail-section">
                            <h2>Purpose</h2>
                            <p id="detailPurpose" class="detail-text"></p>
                        </div>

                        <div class="detail-section">
                            <h2>Unique Selling Proposition</h2>
                            <p id="detailUSP" class="detail-text"></p>
                        </div>

                        <div class="detail-section">
                            <h2>Integration Type</h2>
                            <p id="detailIntegration" class="detail-text"></p>
                        </div>

                        <div class="detail-section">
                            <h2>Timeline Items</h2>
                            <div id="detailTimelineItems" class="timeline-items-grid"></div>
                        </div>

                        <div class="detail-section">
                            <h2>Linked Features</h2>
                            <div id="detailLinkedItems" class="linked-items-list"></div>
                        </div>

                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Success Metrics</h2>
                                <button class="btn-secondary" onclick="app.addSuccessMetric()" style="padding: 8px 16px; font-size: 14px;">+ Add Metric</button>
                            </div>
                            <div id="successMetricsList" class="metrics-grid"></div>
                        </div>

                        <div class="detail-section">
                            <h2>Customer Impact</h2>
                            <textarea id="customerImpactText"
                                      class="detail-textarea"
                                      placeholder="Describe the customer impact..."
                                      onchange="app.updateFeatureTracking('customerImpact', this.value)"></textarea>
                        </div>

                        <div class="detail-section">
                            <h2>Strategic Alignment</h2>
                            <textarea id="strategicAlignmentText"
                                      class="detail-textarea"
                                      placeholder="Describe how this aligns with company strategy..."
                                      onchange="app.updateFeatureTracking('strategicAlignment', this.value)"></textarea>
                        </div>
                    </div>

                    <!-- Execution Guide Tab -->
                    <div id="executionTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Execution Steps</h2>
                                <button class="btn-ai" onclick="app.generateExecutionPlan()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Generate
                                </button>
                            </div>
                            <div id="executionStepsList" class="execution-steps"></div>
                            <button class="btn-secondary" onclick="app.addExecutionStep()">+ Add Step</button>
                        </div>
                    </div>

                    <!-- Resources Tab -->
                    <div id="resourcesTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Required Resources</h2>
                                <button class="btn-ai" onclick="app.suggestResources()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Suggest
                                </button>
                            </div>
                            <div id="resourcesContent" class="resources-grid"></div>
                        </div>
                    </div>

                    <!-- Planning Tab -->
                    <div id="planningTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Milestones</h2>
                                <button class="btn-ai" onclick="app.generateMilestones()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Generate
                                </button>
                            </div>
                            <div id="milestonesList" class="milestones-list"></div>
                            <button class="btn-secondary" onclick="app.addMilestone()">+ Add Milestone</button>
                        </div>

                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Risk Assessment</h2>
                                <button class="btn-ai" onclick="app.identifyRisks()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Identify
                                </button>
                            </div>
                            <div id="risksList" class="risks-list"></div>
                            <button class="btn-secondary" onclick="app.addRisk()">+ Add Risk</button>
                        </div>

                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Prerequisites</h2>
                                <button class="btn-ai" onclick="app.suggestPrerequisites()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Suggest
                                </button>
                            </div>
                            <div id="prerequisitesList" class="prerequisites-list"></div>
                            <button class="btn-secondary" onclick="app.addPrerequisite()">+ Add Prerequisite</button>
                        </div>

                        <!-- Acceptance Criteria Section -->
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Acceptance Criteria</h2>
                            </div>
                            <div class="checklist-input-wrapper">
                                <input type="text" id="acceptanceCriteriaInput" placeholder="Type criteria and press Enter" onkeydown="if(event.key==='Enter'){event.preventDefault();app.addAcceptanceCriteria();}">
                            </div>
                            <div id="acceptanceCriteriaList" class="checklist"></div>
                        </div>

                        <!-- Definition of Done Section -->
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Definition of Done</h2>
                            </div>
                            <div class="checklist-input-wrapper">
                                <input type="text" id="definitionOfDoneInput" placeholder="Type requirement and press Enter" onkeydown="if(event.key==='Enter'){event.preventDefault();app.addDefinitionOfDone();}">
                            </div>
                            <div id="definitionOfDoneList" class="checklist"></div>
                        </div>

                        <!-- Blockers Section -->
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>Blockers</h2>
                                <button class="btn-ai" onclick="app.identifyBlockers()">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                        <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                                    </svg>
                                    AI Identify
                                </button>
                            </div>
                            <div id="blockersList" class="blockers-list"></div>
                            <button class="btn-secondary" onclick="app.addBlocker()">+ Add Blocker</button>
                        </div>
                    </div>

                    <!-- Inspiration Tab -->
                    <div id="inspirationTab" class="detail-tab-content">
                        <div class="detail-section">
                            <div class="section-header">
                                <h2>References & Inspiration</h2>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                    <button class="btn-ai" onclick="app.findInspiration()" title="Search with Tavily (keyword search)">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                            <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                                        </svg>
                                        Tavily
                                    </button>
                                    <button class="btn-ai" onclick="app.findInspirationWithExa()" title="Semantic search with Exa (better for technical content)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                            <path d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
                                        </svg>
                                        Exa
                                    </button>
                                    <button class="btn-ai" onclick="app.getPerplexityInsights()" title="AI-powered Q&A with citations (comprehensive insights)" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                                            <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/>
                                        </svg>
                                        Perplexity
                                    </button>
                                    <button class="btn-ai" onclick="app.smartSearch()" title="Intelligently chooses the best search API based on your feature" style="background: linear-gradient(135deg, #f6d365 0%, #fda085 100%); font-weight: 600;">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                            <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zM7.5 3.5a.5.5 0 0 1 1 0v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 9.293V3.5z"/>
                                        </svg>
                                        Smart Search
                                    </button>
                                </div>
                            </div>
                            <div id="inspirationList" class="inspiration-grid"></div>
                            <button class="btn-secondary" onclick="app.addInspiration()">+ Add Reference</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Feature Modal -->
    <div id="featureModal" class="modal">
        <div class="modal-content enhanced-card">
            <div class="modal-header">
                <h2 id="modalTitle">Add Feature</h2>
                <button class="close-btn" onclick="app.closeModal()">&times;</button>
            </div>
            <form id="featureForm" onsubmit="app.saveFeature(event)">
                <div class="form-group">
                    <label>Name *</label>
                    <input type="text" id="featureName" required>
                </div>
                <div class="form-group">
                    <label>Type *</label>
                    <select id="featureType" required>
                        <option value="">Select type</option>
                        <option value="Feature">Feature</option>
                        <option value="Service">Service</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Purpose</label>
                    <textarea id="featurePurpose" placeholder="What is the purpose of this feature/service?"></textarea>
                </div>

                <!-- Timeline Breakdown Section -->
                <div class="form-group" style="border-top:2px solid var(--border); padding-top:15px; margin-top:15px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <label style="margin:0; font-size:16px; font-weight:600;">Timeline Breakdown *</label>
                        <button type="button" class="btn-primary" onclick="app.addTimelineItem()" style="font-size:12px; padding:6px 12px;">+ Add Timeline Item</button>
                    </div>
                    <div id="timelineItemsContainer">
                        <!-- Timeline items will be rendered here -->
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button type="button" class="btn-secondary" onclick="app.closeModal()">Cancel</button>
                    <button type="submit" class="btn-success">Save Feature</button>
                </div>
            </form>
        </div>
    </div>

    <!-- AI Chat -->
    <button class="chat-button" onclick="app.toggleChat()">üí¨</button>
    <div id="chatPanel" class="chat-panel">
        <div class="chat-panel-resizer" id="chatPanelResizer"></div>
        <div class="chat-header">
            <div class="chat-header-top">
                <div id="chatHeaderApiStatus" class="chat-header-api-status hidden" onclick="app.toggleApiKeyInput()">
                    <span class="chat-header-api-indicator"></span>
                    <span>API Connected</span>
                    <button class="chat-header-api-toggle" onclick="event.stopPropagation(); app.toggleApiKeyInput()">Settings</button>
                </div>
                <h3>ü§ñ AI Assistant</h3>
                <div class="chat-header-actions">
                    <button class="chat-icon-btn" onclick="app.toggleMemoryPanel()" title="Memory">üß†</button>
                    <button class="chat-icon-btn" onclick="app.compactConversation()" title="New Conversation">üîÑ</button>
                    <button class="close-btn" onclick="app.toggleChat()">&times;</button>
                </div>
            </div>
        </div>

        <!-- Link Picker Modal -->
        <div id="linkPickerOverlay" class="link-picker-overlay hidden" onclick="app.closeLinkPicker()"></div>
        <div id="linkPickerModal" class="link-picker-modal hidden">
            <h3>Add Link</h3>
            <div class="link-picker-form">
                <div>
                    <label>Target Feature *</label>
                    <select id="linkTargetFeature" onchange="app.updateLinkTargetItems()" required>
                        <option value="">Select feature...</option>
                    </select>
                </div>
                <div>
                    <label>Target Timeline Item *</label>
                    <select id="linkTargetItem" required>
                        <option value="">Select timeline item...</option>
                    </select>
                </div>
                <div>
                    <label>Relationship Type *</label>
                    <div style="display:flex; gap:15px; margin-top:8px;">
                        <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="linkType" value="dependency" checked>
                            <span>Dependency</span>
                        </label>
                        <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="radio" name="linkType" value="complements">
                            <span>Complements</span>
                        </label>
                    </div>
                </div>
                <div>
                    <label>Reason (Optional)</label>
                    <input type="text" id="linkReason" placeholder="Why are these items linked?">
                </div>
            </div>
            <div class="link-picker-actions">
                <button onclick="app.closeLinkPicker()" style="background:var(--neutral-medium); color:var(--text-inverse);">Cancel</button>
                <button onclick="app.saveManualLink()" style="background:var(--success); color:var(--text-inverse);">Add Link</button>
            </div>
        </div>

        <!-- Rejection Reason Modal -->
        <div id="rejectionReasonOverlay" class="link-picker-overlay hidden" onclick="app.closeRejectionReason()"></div>
        <div id="rejectionReasonModal" class="link-picker-modal hidden">
            <h3>Why reject this link?</h3>
            <div class="link-picker-form">
                <div>
                    <label>Rejection Reason *</label>
                    <select id="rejectionCategory" required>
                        <option value="">Select reason...</option>
                        <option value="not-related">Not related to each other</option>
                        <option value="wrong-type">Wrong relationship type</option>
                        <option value="timeline-mismatch">Timeline mismatch (too early/late)</option>
                        <option value="already-covered">Already covered by another link</option>
                        <option value="other">Other reason</option>
                    </select>
                </div>
                <div>
                    <label>Additional Notes (Optional)</label>
                    <input type="text" id="rejectionNotes" placeholder="Any additional context...">
                </div>
            </div>
            <div class="link-picker-actions">
                <button onclick="app.closeRejectionReason()" style="background:var(--neutral-medium); color:var(--text-inverse);">Cancel</button>
                <button onclick="app.confirmRejection()" style="background:var(--danger); color:var(--text-inverse);">Reject Link</button>
            </div>
        </div>

        <!-- AI Action Approval Modal -->
        <div id="aiActionOverlay" class="link-picker-overlay hidden" onclick="app.closeAIActionApproval()"></div>
        <div id="aiActionModal" class="link-picker-modal hidden" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <h3 id="aiActionTitle">AI Suggested Actions</h3>

            <!-- Summary header -->
            <div id="aiActionSummary" style="margin: 10px 0; padding: 10px; background: rgba(102, 126, 234, 0.1); border-radius: 6px; font-size: 13px; font-weight: 600; color: var(--text-primary); border-left: 4px solid #667eea;">
                <!-- Summary will be inserted here -->
            </div>

            <!-- Actions list -->
            <div id="aiActionsQueue" style="margin: 15px 0; max-height: 400px; overflow-y: auto;">
                <!-- Dynamic queue of actions will be inserted here -->
            </div>

            <!-- Bulk action buttons -->
            <div class="link-picker-actions" style="display: flex; gap: 8px; flex-wrap: wrap;">
                <button onclick="app.rejectAllAIActions()" style="background:var(--danger); color:var(--text-inverse);">‚úï Reject All</button>
                <button onclick="app.closeAIActionApproval()" style="background:var(--neutral-medium); color:var(--text-inverse);">Cancel</button>
                <button onclick="app.approveAllAIActions()" style="background:var(--success); color:var(--text-inverse); flex: 1;">‚úì Approve All</button>
            </div>
        </div>

        <!-- Migration Modal -->
        <div id="migrationOverlay" class="link-picker-overlay hidden"></div>
        <div id="migrationModal" class="link-picker-modal hidden" style="max-width: 500px;">
            <h3>üöÄ Migrate to Cloud Sync</h3>
            <div class="migration-content">
                <p>You have <strong id="migrationCount">0</strong> features saved locally.</p>
                <p>Would you like to migrate your data to the cloud for automatic sync across all your browsers and devices?</p>
                <div style="margin: 15px 0; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 6px; font-size: 13px;">
                    <strong>Benefits:</strong>
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Auto-sync across all browsers</li>
                        <li>Access from any device</li>
                        <li>Never lose your data</li>
                        <li>Real-time updates</li>
                    </ul>
                </div>
            </div>
            <div class="link-picker-actions" style="display: flex; gap: 8px;">
                <button onclick="app.skipMigration()" style="background:var(--neutral-medium); color:var(--text-inverse);">Skip</button>
                <button onclick="app.migrateToCloud()" style="background:var(--success); color:var(--text-inverse); flex: 1;">‚úì Migrate to Cloud</button>
            </div>
        </div>

        <!-- Memory Suggestion Notification -->
        <div id="memoryNotification" class="memory-notification hidden" onclick="app.toggleMemorySuggestions()">
            <div class="memory-notification-collapsed">
                <span>üß† <span id="suggestionCount">0</span> new memory suggestions</span>
                <span class="memory-notification-badge">Click to review</span>
            </div>
            <div class="memory-notification-expanded" id="memorySuggestionsList" onclick="event.stopPropagation()">
                <!-- Suggestions will be rendered here -->
            </div>
        </div>

        <!-- Memory Panel -->
        <div id="memoryPanel" class="memory-panel hidden">
            <h4>
                <span>Memory & Context</span>
                <div class="memory-actions">
                    <button onclick="app.clearMemory()">Clear All</button>
                    <button onclick="app.toggleMemoryPanel()">Close</button>
                </div>
            </h4>

            <!-- Custom Instructions -->
            <div style="margin-bottom:15px;">
                <label style="display:block; font-size:11px; font-weight:600; color:var(--text-muted); margin-bottom:5px;">Custom Instructions</label>
                <textarea id="customInstructionsInput"
                          placeholder="Enter custom instructions for the AI (e.g., your role, context, tone preferences)..."
                          style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:12px; font-family:inherit; resize:vertical; min-height:80px; background:var(--surface); color:var(--text-primary);"
                          onchange="app.saveCustomInstructions(this.value)"></textarea>
            </div>

            <!-- Memory Items -->
            <div>
                <label style="display:block; font-size:11px; font-weight:600; color:var(--text-muted); margin-bottom:5px;">Memory Items</label>

                <!-- Add Memory Input -->
                <div style="display:flex; gap:5px; margin-bottom:10px;">
                    <input type="text" id="addMemoryInput" placeholder="Add to memory..."
                           style="flex:1; padding:6px 8px; border:2px solid var(--border); border-radius:4px; font-size:12px; background:var(--surface); color:var(--text-primary);"
                           onkeypress="if(event.key==='Enter') app.addMemoryFromInput()">
                    <button onclick="app.addMemoryFromInput()"
                            style="padding:6px 12px; background:var(--primary); color:var(--text-inverse); border:none; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600;">Add</button>
                </div>

                <div id="memoryList"></div>
            </div>

            <!-- Message Counter -->
            <div style="margin-top:10px; padding:8px; background:var(--surface); border-radius:4px; font-size:11px; color:var(--text-muted);">
                Messages: <span id="messageCounter">0</span> | Memory items: <span id="memoryCounter">0</span>
            </div>
        </div>

        <!-- AI Action Log Panel -->
        <div id="actionLogPanel" class="memory-panel hidden">
            <h4>
                <span>AI Action Log</span>
                <div class="memory-actions">
                    <button onclick="app.exportAIActionLog()">Export</button>
                    <button onclick="app.clearAIActionLog()">Clear</button>
                    <button onclick="app.toggleAIActionPanel()">Close</button>
                </div>
            </h4>

            <div id="actionLogList" style="max-height:260px; overflow:auto;"></div>

            <div style="margin-top:10px; padding:8px; background:var(--surface); border-radius:4px; font-size:11px; color:var(--text-muted);">
                Total actions: <span id="aiActionTotal">0</span>
            </div>
        </div>

        <!-- Context Warning -->
        <div id="contextWarning" class="context-warning hidden">
            ‚ö†Ô∏è Conversation is getting long. Consider starting a new conversation to maintain performance.
            <button onclick="app.compactConversation()" style="margin-left:8px; padding:2px 8px; font-size:11px; background:var(--surface); border:1px solid var(--warning); border-radius:3px; cursor:pointer; color:var(--text-primary);">Start New</button>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="chat-message ai">
                üëã Hi! I'm your AI assistant. I can help you with:
                <br>‚Ä¢ Analyzing your features
                <br>‚Ä¢ Suggesting improvements
                <br>‚Ä¢ Cleaning up data
                <br>‚Ä¢ Answering questions
                <br><br>First, please add your OpenRouter API key below.
            </div>
        </div>
        <div class="chat-input-container">
            <div class="api-key-input">
                <div id="apiKeyInputSection" class="hidden">
                    <label>OpenRouter API Key</label>
                    <input type="password" id="apiKeyInput" placeholder="Enter your API key"
                           value="" onchange="app.saveApiKey(this.value)">
                    <label>AI Model</label>
                    <select id="modelSelect" onchange="app.saveModel(this.value)">
                        <option value="deepseek/deepseek-v3.1-terminus">DeepSeek V3.1 Terminus (671B params)</option>
                        <option value="anthropic/claude-haiku-4.5">Claude Haiku 4.5 (fastest)</option>
                        <option value="openai/gpt-4o-mini">GPT-4o Mini</option>
                        <option value="moonshotai/kimi-k2">Kimi K2 (1T params, 256K context)</option>
                        <option value="x-ai/grok-4-fast">Grok 4 Fast (2M context)</option>
                    </select>
                    <label style="margin-top: 10px;">Tavily API Key (Optional - for internet search)</label>
                    <input type="password" id="tavilyApiKeyInput" placeholder="Enter Tavily API key (optional)"
                           value="" onchange="app.saveTavilyApiKey(this.value)">
                    <small style="color: var(--text-muted); font-size: 11px; display: block; margin-top: 5px;">
                        Get free API key at <a href="https://tavily.com" target="_blank" style="color: #667eea;">tavily.com</a> (1000 searches/month free)
                    </small>
                    <label style="margin-top: 10px;">Exa API Key (Optional - for semantic search)</label>
                    <input type="password" id="exaApiKeyInput" placeholder="Enter Exa API key (optional)"
                           value="" onchange="app.saveExaApiKey(this.value)">
                    <small style="color: var(--text-muted); font-size: 11px; display: block; margin-top: 5px;">
                        Get API key at <a href="https://exa.ai" target="_blank" style="color: #667eea;">exa.ai</a> (Semantic web search)
                    </small>
                    <label style="margin-top: 10px;">Perplexity API Key (Optional - for Q&A with citations)</label>
                    <input type="password" id="perplexityApiKeyInput" placeholder="Enter Perplexity API key (optional)"
                           value="" onchange="app.savePerplexityApiKey(this.value)">
                    <small style="color: var(--text-muted); font-size: 11px; display: block; margin-top: 5px;">
                        Get API key at <a href="https://www.perplexity.ai" target="_blank" style="color: #667eea;">perplexity.ai</a> (AI-powered Q&A)
                    </small>
                    <button class="btn-secondary" style="width: 100%; margin-top: 10px;" onclick="app.toggleApiKeyInput()">Done</button>
                </div>
            </div>
            <div class="chat-input-wrapper">
                <div class="input-row">
                    <textarea id="chatInput" placeholder="Ask me anything..." rows="1"
                              oninput="app.autoResizeTextarea(this)"
                              onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); app.sendMessage(); }"></textarea>
                    <button class="btn-primary" onclick="app.sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhancement Panel (Independent) -->
    <div id="enhancementPanel" class="enhancement-panel hidden">
        <div class="enhancement-header">
            <h3>‚ú® AI Feature Enhancement</h3>
            <button class="close-btn" onclick="app.closeEnhancementPanel()">&times;</button>
        </div>

        <div class="enhancement-content">
            <!-- Understanding Section -->
            <div class="enhancement-section">
                <div class="enhancement-section-title">üìã Current Understanding</div>
                <div id="enhancementUnderstanding" class="enhancement-understanding">
                    <div class="understanding-item">
                        <span class="understanding-label">Feature:</span>
                        <span id="understandingName">-</span>
                    </div>
                    <div class="understanding-item">
                        <span class="understanding-label">Type:</span>
                        <span id="understandingType">-</span>
                    </div>
                    <div class="understanding-item">
                        <span class="understanding-label">Purpose:</span>
                        <span id="understandingPurpose">-</span>
                    </div>
                </div>
            </div>

            <!-- Gaps Section -->
            <div class="enhancement-section">
                <div class="enhancement-section-title">üéØ What's Missing</div>
                <div id="enhancementGaps" class="enhancement-gaps">
                    <!-- Gaps will be populated here -->
                </div>
            </div>

            <!-- Questions Section -->
            <div class="enhancement-section">
                <div class="enhancement-section-title">üí¨ Clarifying Questions</div>
                <div id="enhancementQuestions" class="enhancement-questions">
                    <p class="enhancement-loading">Analyzing feature...</p>
                </div>
            </div>

            <!-- Progress Section (hidden initially) -->
            <div id="enhancementProgress" class="enhancement-section hidden">
                <div class="enhancement-section-title">üîç Research Progress</div>
                <div class="enhancement-progress-bar">
                    <div id="enhancementProgressFill" class="enhancement-progress-fill"></div>
                </div>
                <div id="enhancementProgressText" class="enhancement-progress-text">Searching...</div>
            </div>

            <!-- Actions -->
            <div class="enhancement-actions">
                <button class="btn-secondary" onclick="app.closeEnhancementPanel()">Cancel</button>
                <button id="enhancementSubmitBtn" class="btn-primary" onclick="app.submitEnhancementAnswers()" disabled>
                    Start Enhancement
                </button>
            </div>
        </div>
    </div>

    <!-- Supabase JS Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Cytoscape.js for Graph Visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>

    <!-- Load app modules in order -->
    <!-- Utilities -->
    <script src="js/utils/loading-manager.js"></script>
    <script src="js/utils/form-validator.js"></script>
    <script src="js/utils/mobile-nav.js"></script>

    <!-- Core configuration -->
    <script src="js/config.js"></script>
    <script src="js/services/storage.js"></script>
    <script src="js/services/supabase.js"></script>
    <script src="js/services/ai-service.js"></script>
    <script src="js/services/tavily-search.js"></script>
    <script src="js/services/exa-api.js"></script>
    <script src="js/services/perplexity-api.js"></script>
    <script src="js/services/connection-manager.js"></script>
    <script src="js/services/importance-service.js"></script>
    <script src="js/services/correlation-service.js"></script>
    <script src="js/services/graph-analysis-service.js"></script>
    <script src="js/services/ai-enhancement-service.js"></script>
    <script src="js/services/ai-cost-manager.js"></script>
    <script src="js/services/ai-field-detector.js"></script>
    <script src="js/services/search-orchestrator.js"></script>
    <script src="js/data/workspace-manager.js"></script>
    <script src="js/data/feature-manager.js"></script>
    <script src="js/data/timeline-manager.js"></script>
    <script src="js/data/link-manager.js"></script>
    <script src="js/ui/modal-manager.js"></script>
    <script src="js/ui/chat-panel.js"></script>
    <script src="js/ui/feature-table.js"></script>
    <script src="js/ui/components/workflow-guide.js"></script>
    <script src="js/ui/components/workflow-tabs.js"></script>
    <script src="js/ui/components/graph-view.js"></script>
    <script src="js/ui/components/insights-panel.js"></script>
    <script src="js/ui/detail-view-core.js"></script>
    <script src="js/ui/detail-view-tabs.js"></script>
    <script src="js/ui/detail-view-crud.js"></script>
    <script src="js/ui/detail-view-ai.js"></script>
    <script src="js/ui/detail-view-ai-workflows.js"></script>
    <script src="js/ui/keyboard-shortcuts-overlay.js"></script>

    <!-- Enhanced Interface JavaScript - State Management (Foundation) -->
    <script src="js/state-management/state-store.js"></script>
    <script src="js/state-management/state-reducers.js"></script>
    <script src="js/state-management/state-actions.js"></script>
    <script src="js/state-management/state-middleware.js"></script>
    <script src="js/state-management/state-management-integration.js"></script>

    <!-- Enhanced Interface JavaScript - Navigation System -->
    <!-- Disabled: Creates duplicate UI elements -->
    <!-- <script src="js/navigation/enhanced-navigation.js"></script> -->
    <script src="js/navigation/interaction-flows.js"></script>
    <script src="js/navigation/gesture-navigation.js"></script>
    <script src="js/navigation/keyboard-navigation.js"></script>
    <script src="js/navigation/navigation-integration.js"></script>

    <!-- Enhanced Interface JavaScript - Interactions & Animations -->
    <script src="js/animations/animation-library.js"></script>
    <script src="js/micro-interactions/interaction-controller.js"></script>
    <script src="js/progressive-disclosure/disclosure-manager.js"></script>

    <!-- Enhanced Interface JavaScript - Accessibility & Responsive -->
    <script src="js/accessibility/accessibility-manager.js"></script>
    <script src="js/responsive/responsive-controller.js"></script>

    <!-- Enhanced Interface JavaScript - Real-Time Sync (Optional) -->
    <script src="js/real-time/websocket-client.js"></script>
    <script src="js/real-time/conflict-resolver.js"></script>
    <script src="js/real-time/sync-manager.js"></script>

    <!-- Enhanced Interface JavaScript - Master Integration -->
    <script src="js/integration/interaction-integration.js"></script>

    <script src="js/main.js"></script>

    <script>
        const app = {
            features: [],
            workspaces: [],
            currentWorkspaceId: null,
            currentView: 'table',
            currentFeatureId: null,
            currentTab: 'overview',
            editingId: null,
            currentTags: [],
            currentTimelineItems: [],
            allTags: new Set(),
            sortColumn: null,
            sortDirection: 'asc',
            apiKey: '',
            selectedModel: 'deepseek/deepseek-v3.1-terminus',
            tavilyApiKey: '',
            exaApiKey: '',
            perplexityApiKey: '',
            customInstructions: '',
            memory: [],
            memorySuggestions: [],
            linkSuggestions: [],
            rejectedLinks: [],
            conversationHistory: [],
            messageCount: 0,
            lastAnalysisCount: 0,
            pendingAIActions: [],
            aiActionLog: [],
            aiEditingEnabled: true,
            selectedFeatureIds: new Set(),
            inlineEditing: { id: null, field: null, prev: '' },
            isSavingFeature: false,
            aiFeatureCreationMode: false,
            aiFeatureEnhancementMode: false,

            async init() {
                console.log('üöÄ App initialization started');
                // Initialize Supabase connection first
                await supabaseService.init();

                // Test localStorage availability
                if (!this.testLocalStorage()) {
                    this.showAlert({ title:'Storage disabled', message:'Browser storage is disabled or unavailable. Your data will NOT be saved. Check private mode, browser settings, or storage quota.', variant:'warning' });
                }

                // Check origin/path changes
                this.checkOriginChange();

                // Verify data integrity and show recovery options if needed
                this.verifyDataIntegrity();

                // Load workspaces first
                await this.loadWorkspaces();

                // Check if we have workspaces
                console.log('üîç Workspace check:', { count: this.workspaces.length, workspaces: this.workspaces });
                if (this.workspaces.length === 0) {
                    // Check if there are features that need a workspace
                    const stored = localStorage.getItem('roadmapFeatures');
                    const localFeatures = stored ? JSON.parse(stored) : [];

                    if (localFeatures.length > 0) {
                        // Features exist but no workspace - create one automatically
                        console.log(`‚ö†Ô∏è Found ${localFeatures.length} features without workspace. Creating default workspace...`);

                        const defaultWorkspace = await this.createWorkspace(
                            'My Roadmap',
                            'Default workspace containing your features',
                            '#3b82f6',
                            'üìä'
                        );

                        // Assign all features to this workspace
                        localFeatures.forEach(f => {
                            if (!f.workspaceId) {
                                f.workspaceId = defaultWorkspace.id;
                            }
                        });
                        localStorage.setItem('roadmapFeatures', JSON.stringify(localFeatures));

                        // Set as current workspace
                        this.currentWorkspaceId = defaultWorkspace.id;
                        localStorage.setItem('currentWorkspaceId', defaultWorkspace.id);

                        // Sync to Supabase
                        await this.saveData();

                        console.log(`‚úÖ Created default workspace and assigned ${localFeatures.length} features`);
                        // Continue with normal initialization
                    } else {
                        // No workspaces AND no features - show welcome screen
                        console.log('‚ÑπÔ∏è No workspaces found - showing welcome screen');
                        this.loadApiKey();
                        this.loadModel();
                        this.loadTavilyApiKey();
                        this.loadExaApiKey();
                        this.loadPerplexityApiKey();
                        this.renderWorkspaceSelector();
                        this.showWorkspaceWelcome();
                        this.updateSyncStatus();
                        return;
                    }
                }

                // Load last used workspace or first workspace
                const lastWorkspaceId = localStorage.getItem('currentWorkspaceId');
                if (lastWorkspaceId && this.workspaces.find(w => w.id === lastWorkspaceId)) {
                    this.currentWorkspaceId = lastWorkspaceId;
                } else {
                    this.currentWorkspaceId = this.workspaces[0].id;
                    localStorage.setItem('currentWorkspaceId', this.currentWorkspaceId);
                }

                // Load features for current workspace
                // First, try to load from localStorage (primary source)
                const stored = localStorage.getItem('roadmapFeatures');
                if (stored) {
                    try {
                        const allFeatures = JSON.parse(stored);
                        this.features = allFeatures.filter(f => f.workspaceId === this.currentWorkspaceId);
                        console.log(`‚úÖ Loaded ${this.features.length} features for workspace ${this.currentWorkspaceId}`);
                    } catch (error) {
                        console.error('‚ùå Error parsing features from localStorage:', error);
                        this.features = [];
                    }
                } else {
                    this.features = [];
                    console.log('‚ÑπÔ∏è No features found in localStorage');
                }

                // Then try to sync with Supabase if connected
                if (supabaseService.isConnected) {
                    try {
                        const workspaceFeatures = await supabaseService.loadWorkspaceFeatures(this.currentWorkspaceId);
                        if (workspaceFeatures !== null && workspaceFeatures.length > 0) {
                            // If cloud has more features or different features, update local data
                            if (workspaceFeatures.length > this.features.length) {
                                // Merge features - prefer cloud data but keep local additions
                                const mergedFeatures = [...workspaceFeatures];

                                // Add any local features that aren't in cloud
                                this.features.forEach(localFeature => {
                                    if (!workspaceFeatures.find(cf => cf.id === localFeature.id)) {
                                        mergedFeatures.push(localFeature);
                                    }
                                });

                                this.features = mergedFeatures;
                                console.log(`‚úÖ Synced ${workspaceFeatures.length} features from cloud`);

                                // Update localStorage with merged data
                                const allStored = JSON.parse(localStorage.getItem('roadmapFeatures') || '[]');
                                const updatedStored = allStored.filter(f => f.workspaceId !== this.currentWorkspaceId);
                                updatedStored.push(...this.features);
                                localStorage.setItem('roadmapFeatures', JSON.stringify(updatedStored));
                            } else {
                                console.log(`‚úÖ Local features (${this.features.length}) are up to date`);
                            }
                        }
                    } catch (syncError) {
                        console.warn('‚ö†Ô∏è Could not sync features with cloud:', syncError.message);
                        // Continue with local data
                    }
                } else {
                    console.log('‚ÑπÔ∏è Offline mode - using local feature data only');
                }

                // Load workspace-specific AI settings
                const currentWorkspace = this.getCurrentWorkspace();
                if (currentWorkspace) {
                    this.customInstructions = currentWorkspace.customInstructions || '';
                    this.memory = currentWorkspace.aiMemory || [];
                }

                this.loadApiKey();
                this.loadModel();
                this.loadTavilyApiKey();
                this.loadExaApiKey();
                this.loadPerplexityApiKey();
                this.loadMemorySuggestions();
                this.loadLinkSuggestions();
                this.loadRejectedLinks();

                // Update workspace banner visibility
                this.updateWorkspaceBanner();
                this.loadAIActionLog();
                this.renderWorkspaceSelector();
                this.renderTable();
                this.setupTagInput();
                this.updateSuggestionNotification();
                this.updateLinkNotification();
                this.updateCounters();
                this.updateActionLogCounter();
                this.setupChatPanelResize();
                // set up debounced filters and restore UI state
                this.debouncedApplyFilters = this.debounce(this.applyFilters.bind(this), 200);
                this.restoreUIState();
                this.bindShortcuts();
                this.ensureLiveRegion();
                this.loadTheme();

                // Handle URL hash routing for deep links
                this.setupHashRouting();

                // Setup real-time sync for cross-browser updates
                if (supabaseService.isConnected) {
                    supabaseService.subscribeToChanges((updatedFeatures) => {
                        console.log('üîÑ Real-time update received from another device/browser');
                        // Only update if features belong to current workspace
                        this.features = updatedFeatures.filter(f => f.workspaceId === this.currentWorkspaceId);
                        this.renderTable();
                        this.updateCounters();
                        // Also save to localStorage as cache
                        this.saveToLocalStorage();
                    });
                }

                // Show sync status
                this.updateSyncStatus();
            },

            setupHashRouting() {
                // Handle hash changes (back/forward buttons)
                window.addEventListener('hashchange', () => {
                    this.handleHashChange();
                });

                // Handle initial hash on page load
                this.handleHashChange();
            },

            handleHashChange() {
                const hash = window.location.hash.substring(1); // Remove #

                if (hash.startsWith('feature/')) {
                    const featureId = hash.substring(8); // Remove 'feature/'
                    if (featureId && this.features.find(f => f.id === featureId)) {
                        this.showDetailView(featureId);
                    } else {
                        this.showTableView();
                    }
                } else {
                    // No hash or unrecognized hash - show table
                    if (this.currentView !== 'table') {
                        this.showTableView();
                    }
                }
            },

            // --- Utilities: debounce + UI state persistence + shortcuts ---
            _debounceTimer: null,
            debounce(fn, wait = 200) {
                return (...args) => {
                    clearTimeout(this._debounceTimer);
                    this._debounceTimer = setTimeout(() => fn.apply(this, args), wait);
                };
            },
            debouncedApplyFilters: null,
            saveUIState() {
                try {
                    const state = {
                        search: document.getElementById('searchInput')?.value || '',
                        timeline: document.getElementById('timelineFilter')?.value || '',
                        difficulty: document.getElementById('difficultyFilter')?.value || '',
                        category: document.getElementById('categoryFilter')?.value || '',
                        sortColumn: this.sortColumn,
                        sortDirection: this.sortDirection
                    };
                    localStorage.setItem('uiState', JSON.stringify(state));
                } catch {}
            },
            restoreUIState() {
                try {
                    const raw = localStorage.getItem('uiState');
                    if (!raw) return;
                    const state = JSON.parse(raw);
                    const si = document.getElementById('searchInput');
                    if (si) si.value = state.search || '';
                    const tf = document.getElementById('timelineFilter');
                    if (tf) tf.value = state.timeline || '';
                    const df = document.getElementById('difficultyFilter');
                    if (df) df.value = state.difficulty || '';
                    const cf = document.getElementById('categoryFilter');
                    if (cf) cf.value = state.category || '';
                    this.sortColumn = state.sortColumn || this.sortColumn;
                    this.sortDirection = state.sortDirection || this.sortDirection;
                    this.applyFilters();
                } catch {}
            },
            bindShortcuts() {
                document.addEventListener('keydown', (e) => {
                    const inEditable = ['INPUT','TEXTAREA','SELECT'].includes((e.target || {}).tagName);
                    const mod = e.ctrlKey || e.metaKey;
                    if (mod && e.key.toLowerCase() === 'k') {
                        e.preventDefault();
                        document.getElementById('searchInput')?.focus();
                        return;
                    }
                    if (!inEditable) {
                        if (e.key.toLowerCase() === 'n') { e.preventDefault(); this.showAddModal(); return; }
                        if (e.key === '/') { e.preventDefault(); this.toggleChat(); return; }
                        if (e.key === 'Escape') {
                            const modals = ['featureModal','linkPickerModal','rejectionReasonModal','aiActionModal'];
                            for (let id of modals) {
                                const el = document.getElementById(id);
                                if (!el) continue;
                                const visible = (id==='featureModal') ? el.classList.contains('active') : !el.classList.contains('hidden');
                                if (visible) {
                                    if (id==='featureModal') this.closeModal();
                                    if (id==='linkPickerModal') this.closeLinkPicker();
                                    if (id==='rejectionReasonModal') this.closeRejectionReason();
                                    if (id==='aiActionModal') this.closeAIActionApproval();
                                    break;
                                }
                            }
                        }
                    }
                });
            },

            ensureLiveRegion() {
                if (!document.getElementById('srLive')) {
                    const sr = document.createElement('div');
                    sr.id = 'srLive';
                    sr.setAttribute('aria-live', 'polite');
                    sr.setAttribute('role', 'status');
                    sr.style.position = 'absolute';
                    sr.style.width = '1px';
                    sr.style.height = '1px';
                    sr.style.overflow = 'hidden';
                    sr.style.clip = 'rect(1px, 1px, 1px, 1px)';
                    document.body.appendChild(sr);
                }
                const chat = document.getElementById('chatMessages');
                if (chat) { chat.setAttribute('aria-live','polite'); chat.setAttribute('role','log'); }
            },

            // Theme
            loadTheme() {
                const stored = localStorage.getItem('theme');
                const theme = stored === 'dark' ? 'dark' : 'light';
                document.body.setAttribute('data-theme', theme === 'dark' ? 'dark' : 'light');
            },
            toggleTheme() {
                const current = document.body.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
                const next = current === 'dark' ? 'light' : 'dark';
                document.body.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                this.showToast(next === 'dark' ? 'Dark mode on' : 'Light mode on', 'info');
            },

            toggleHeaderMenu(event) {
                if (event) event.stopPropagation();
                const dropdown = document.getElementById('headerMenuDropdown');
                if (dropdown) {
                    dropdown.classList.toggle('active');
                    if (dropdown.classList.contains('active')) {
                        // Close on outside click
                        setTimeout(() => {
                            document.addEventListener('click', this.closeHeaderMenu.bind(this), { once: true });
                        }, 0);
                    }
                }
            },

            closeHeaderMenu() {
                const dropdown = document.getElementById('headerMenuDropdown');
                if (dropdown) {
                    dropdown.classList.remove('active');
                }
            },

            async checkOriginChange() {
                const currentOrigin = window.location.href;
                const lastOrigin = localStorage.getItem('lastOrigin');

                console.log('Current location:', currentOrigin);

                if (lastOrigin && lastOrigin !== currentOrigin) {
                    console.warn('‚ö†Ô∏è Origin changed!', {
                        previous: lastOrigin,
                        current: currentOrigin
                    });

                    // Check if we have data
                    const hasData = this.features?.length > 0 || localStorage.getItem('roadmapFeatures');

                    if (!hasData) {
                        const ok = await this.showConfirm({
                            title: 'WARNING: File location changed!',
                            message: `Previous: ${lastOrigin}<br>Current: ${currentOrigin}<br><br>You may have lost your data because you're opening the file from a different location.<br><br>Each file path has separate storage. To recover your data:<br>1. Close this tab<br>2. Open the file from the original location<br>3. Click "Backup All" to export your data<br>4. Then you can open from any location and use "Import Backup"<br><br>Would you like to import a backup now?`,
                            confirmText: 'Import backup',
                            cancelText: 'Not now',
                            variant: 'warning'
                        });
                        if (ok) this.importAllData();
                    }
                }

                // Save current origin
                localStorage.setItem('lastOrigin', currentOrigin);
            },

            testLocalStorage() {
                try {
                    const test = '__localStorage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    console.error('localStorage not available:', e);
                    this.showAlert({ title: 'Storage disabled', message: 'Browser storage is disabled or unavailable. Your data will NOT be saved. Check private mode, browser settings, or storage quota.' , variant:'warning'});
                    return false;
                }
            },

            // Verify data integrity and provide recovery options
            verifyDataIntegrity() {
                try {
                    // Check if we have backup data from before potential corruption
                    const workspacesStored = localStorage.getItem('roadmapWorkspaces');
                    const featuresStored = localStorage.getItem('roadmapFeatures');
                    const currentWorkspaceId = localStorage.getItem('currentWorkspaceId');

                    let hasWorkspaces = false;
                    let hasFeatures = false;
                    let hasCurrentWorkspace = false;

                    if (workspacesStored) {
                        try {
                            const workspaces = JSON.parse(workspacesStored);
                            hasWorkspaces = Array.isArray(workspaces) && workspaces.length > 0;
                        } catch (e) {
                            console.warn('Corrupted workspaces data in localStorage');
                            // Try to create a backup before clearing
                            localStorage.setItem('roadmapWorkspaces_backup', workspacesStored);
                            localStorage.removeItem('roadmapWorkspaces');
                        }
                    }

                    if (featuresStored) {
                        try {
                            const features = JSON.parse(featuresStored);
                            hasFeatures = Array.isArray(features) && features.length > 0;
                        } catch (e) {
                            console.warn('Corrupted features data in localStorage');
                            // Try to create a backup before clearing
                            localStorage.setItem('roadmapFeatures_backup', featuresStored);
                            localStorage.removeItem('roadmapFeatures');
                        }
                    }

                    if (currentWorkspaceId) {
                        hasCurrentWorkspace = true;
                    }

                    // Log data status for debugging
                    console.log('üîç Data integrity check:', {
                        hasWorkspaces,
                        hasFeatures,
                        hasCurrentWorkspace,
                        supabaseConnected: supabaseService.isConnected
                    });

                    // If we have data but no current workspace, set one
                    if (hasWorkspaces && !hasCurrentWorkspace) {
                        try {
                            const workspaces = JSON.parse(localStorage.getItem('roadmapWorkspaces'));
                            if (workspaces && workspaces.length > 0) {
                                localStorage.setItem('currentWorkspaceId', workspaces[0].id);
                                console.log('‚úÖ Set default current workspace');
                            }
                        } catch (e) {
                            console.error('Could not set default workspace:', e);
                        }
                    }

                } catch (error) {
                    console.error('‚ùå Data integrity check failed:', error);
                }
            },

            // Export all data as JSON
            exportData() {
                try {
                    const data = {
                        workspaces: JSON.parse(localStorage.getItem('roadmapWorkspaces') || '[]'),
                        features: JSON.parse(localStorage.getItem('roadmapFeatures') || '[]'),
                        currentWorkspaceId: localStorage.getItem('currentWorkspaceId'),
                        apiKey: localStorage.getItem('openrouterApiKey'),
                        model: localStorage.getItem('selectedModel'),
                        tavilyApiKey: localStorage.getItem('tavilyApiKey'),
                        exportDate: new Date().toISOString(),
                        version: '2.0'
                    };

                    const dataStr = JSON.stringify(data, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });

                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `roadmap-backup-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    this.showAlert({ title: 'Export Complete', message: 'Your data has been exported successfully!', variant: 'success' });
                } catch (error) {
                    console.error('Export failed:', error);
                    this.showAlert({ title: 'Export Failed', message: 'Failed to export data. Check console for details.', variant: 'danger' });
                }
            },

            // Import data from JSON file
            importData(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const data = JSON.parse(e.target.result);

                            // Validate minimum required structure
                            if (!data.version || !data.features) {
                                throw new Error('Invalid backup file format: missing version or features');
                            }

                            // Handle v1.0 backups (pre-workspace) - migrate to workspace format
                            if (data.version === "1.0" && !data.workspaces) {
                                console.log('üì¶ Detected v1.0 backup - migrating to workspace format...');

                                // Create default workspace from old data
                                const defaultWorkspace = {
                                    id: Date.now().toString(),
                                    name: 'Import Platform',
                                    description: 'Imported from backup file',
                                    color: '#3b82f6',
                                    icon: 'üìä',
                                    customInstructions: data.customInstructions || '',
                                    aiMemory: data.memory || [],
                                    createdAt: new Date().toISOString(),
                                    updatedAt: new Date().toISOString()
                                };

                                // Add workspace to data
                                data.workspaces = [defaultWorkspace];

                                // Assign all features to this workspace
                                data.features.forEach(feature => {
                                    if (!feature.workspaceId) {
                                        feature.workspaceId = defaultWorkspace.id;
                                    }
                                });

                                // Set as current workspace
                                data.currentWorkspaceId = defaultWorkspace.id;

                                console.log(`‚úÖ Migration complete - created workspace "${defaultWorkspace.name}" with ${data.features.length} features`);
                            }

                            // Validate workspace structure is now present
                            if (!data.workspaces || !Array.isArray(data.workspaces)) {
                                throw new Error('Invalid backup file format: missing workspaces after migration');
                            }

                            // Confirm import
                            if (!confirm('This will replace all your current data. Are you sure you want to continue?')) {
                                resolve(false);
                                return;
                            }

                            // Import data to localStorage
                            if (data.workspaces && Array.isArray(data.workspaces)) {
                                localStorage.setItem('roadmapWorkspaces', JSON.stringify(data.workspaces));
                            }
                            if (data.features && Array.isArray(data.features)) {
                                localStorage.setItem('roadmapFeatures', JSON.stringify(data.features));
                            }
                            if (data.currentWorkspaceId) {
                                localStorage.setItem('currentWorkspaceId', data.currentWorkspaceId);
                            }
                            if (data.apiKey) {
                                localStorage.setItem('openrouterApiKey', data.apiKey);
                            }
                            if (data.model) {
                                localStorage.setItem('selectedModel', data.model);
                            }
                            if (data.tavilyApiKey) {
                                localStorage.setItem('tavilyApiKey', data.tavilyApiKey);
                            }

                            // Push to Supabase if connected
                            if (supabaseService.isConnected) {
                                console.log('üîÑ Pushing imported data to Supabase...');

                                // Push workspaces
                                for (const workspace of data.workspaces) {
                                    await supabaseService.createWorkspace(workspace);
                                }

                                // Push features
                                await supabaseService.syncFeatures(data.features);

                                console.log('‚úÖ Data pushed to Supabase successfully');
                                this.showAlert({ title: 'Import Complete', message: 'Your data has been imported and synced to cloud! Please refresh the page.', variant: 'success' });
                            } else {
                                this.showAlert({ title: 'Import Complete', message: 'Your data has been imported successfully! Please refresh the page.', variant: 'success' });
                            }

                            resolve(true);
                        } catch (error) {
                            console.error('Import failed:', error);
                            this.showAlert({ title: 'Import Failed', message: 'Failed to import data. The file may be corrupted or in the wrong format.', variant: 'danger' });
                            resolve(false);
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            },

            getAITools() {
                return chatPanel.getAITools();
            },

            // [Extracted method - now delegating to chatPanel]
            _oldGetAITools() {
                return [
                    {
                        type: "function",
                        function: {
                            name: "update_feature",
                            description: "Update an existing feature's basic information (name, type, or purpose). Use this when the user wants to modify feature details.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature to update"
                                    },
                                    updates: {
                                        type: "object",
                                        properties: {
                                            name: { type: "string", description: "New feature name" },
                                            type: { type: "string", description: "New feature type (Platform or User-Facing)" },
                                            purpose: { type: "string", description: "New feature purpose/description" }
                                        },
                                        description: "Object containing the fields to update"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this change is being made"
                                    }
                                },
                                required: ["featureId", "updates", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "update_timeline_item",
                            description: "Update a timeline item's metadata (difficulty, categories, integration type, or USP). Use this to refine timeline item details.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature containing the timeline item"
                                    },
                                    itemId: {
                                        type: "string",
                                        description: "The ID of the timeline item to update"
                                    },
                                    updates: {
                                        type: "object",
                                        properties: {
                                            difficulty: { type: "string", description: "New difficulty (Easy, Medium, or Hard)" },
                                            category: { type: "array", items: { type: "string" }, description: "New categories array" },
                                            integrationType: { type: "string", description: "New integration type" },
                                            usp: { type: "string", description: "New USP (unique selling proposition)" }
                                        },
                                        description: "Object containing the fields to update"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this change is being made"
                                    }
                                },
                                required: ["featureId", "itemId", "updates", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "create_feature",
                            description: "Create a new feature with timeline items. Use this when the user wants to add a completely new feature to the roadmap.",
                            parameters: {
                                type: "object",
                                properties: {
                                    name: {
                                        type: "string",
                                        description: "Feature name"
                                    },
                                    type: {
                                        type: "string",
                                        description: "Feature type (Platform or User-Facing)"
                                    },
                                    purpose: {
                                        type: "string",
                                        description: "Feature purpose/description"
                                    },
                                    timelineItems: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                timeline: { type: "string", description: "Timeline phase (MVP, SHORT, MID, LONG)" },
                                                difficulty: { type: "string", description: "Difficulty (Easy, Medium, Hard)" },
                                                category: { type: "array", items: { type: "string" }, description: "Categories" },
                                                integrationType: { type: "string", description: "Integration type" },
                                                usp: { type: "string", description: "Unique selling proposition" }
                                            }
                                        },
                                        description: "Array of timeline items for this feature"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this feature should be added"
                                    }
                                },
                                required: ["name", "type", "purpose", "timelineItems", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "create_link_suggestion",
                            description: "Suggest a new cross-feature link between timeline items. Use this when you identify a dependency or complementary relationship.",
                            parameters: {
                                type: "object",
                                properties: {
                                    sourceFeatureId: {
                                        type: "string",
                                        description: "ID of the source feature"
                                    },
                                    sourceItemId: {
                                        type: "string",
                                        description: "ID of the source timeline item"
                                    },
                                    targetFeatureId: {
                                        type: "string",
                                        description: "ID of the target feature"
                                    },
                                    targetItemId: {
                                        type: "string",
                                        description: "ID of the target timeline item"
                                    },
                                    relationshipType: {
                                        type: "string",
                                        enum: ["dependency", "complements"],
                                        description: "Type of relationship"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Explanation of why these items are linked"
                                    }
                                },
                                required: ["sourceFeatureId", "sourceItemId", "targetFeatureId", "targetItemId", "relationshipType", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "add_timeline_item",
                            description: "Add a new timeline item to an existing feature. Use this when a feature needs additional phases or milestones.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature to add the timeline item to"
                                    },
                                    timelineItem: {
                                        type: "object",
                                        properties: {
                                            timeline: { type: "string", description: "Timeline phase (MVP, SHORT, MID, LONG)" },
                                            difficulty: { type: "string", description: "Difficulty (Easy, Medium, Hard)" },
                                            category: { type: "array", items: { type: "string" }, description: "Categories" },
                                            integrationType: { type: "string", description: "Integration type" },
                                            usp: { type: "string", description: "Unique selling proposition" }
                                        },
                                        required: ["timeline", "difficulty"],
                                        description: "The timeline item to add"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this timeline item is being added"
                                    }
                                },
                                required: ["featureId", "timelineItem", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "delete_timeline_item",
                            description: "Remove a timeline item from a feature. Use this when a timeline phase is no longer needed. Be cautious with this action.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature containing the timeline item"
                                    },
                                    itemId: {
                                        type: "string",
                                        description: "The ID of the timeline item to delete"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this timeline item is being removed"
                                    }
                                },
                                required: ["featureId", "itemId", "reason"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "create_feature_with_research",
                            description: "Create a comprehensive feature with AI-powered research. Use this ONLY when the user explicitly wants to create a feature with AI assistance (like clicking 'AI Create'). This tool will automatically research and generate execution steps, resources, planning, and inspiration.",
                            parameters: {
                                type: "object",
                                properties: {
                                    name: {
                                        type: "string",
                                        description: "Feature name"
                                    },
                                    type: {
                                        type: "string",
                                        description: "Feature type (Feature or Service)"
                                    },
                                    purpose: {
                                        type: "string",
                                        description: "Detailed feature purpose/description"
                                    },
                                    timelineItems: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            properties: {
                                                timeline: { type: "string", description: "Timeline phase (MVP, SHORT, MID, LONG)" },
                                                difficulty: { type: "string", description: "Difficulty (Easy, Medium, Hard)" },
                                                category: { type: "array", items: { type: "string" }, description: "Categories" },
                                                integrationType: { type: "string", description: "Integration type" },
                                                usp: { type: "string", description: "Unique selling proposition" }
                                            }
                                        },
                                        description: "Timeline items (can be minimal, will be enhanced by research)"
                                    }
                                },
                                required: ["name", "purpose"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "enhance_feature_with_research",
                            description: "Enhance an existing feature with AI-powered research. Use this ONLY when the user explicitly wants to enhance/enrich a feature they're viewing (like clicking 'AI Enhance'). This tool will analyze the existing feature, research it, and automatically populate or update execution steps, resources, planning, and inspiration.",
                            parameters: {
                                type: "object",
                                properties: {
                                    featureId: {
                                        type: "string",
                                        description: "The ID of the feature to enhance"
                                    },
                                    name: {
                                        type: "string",
                                        description: "Feature name (may be same as existing or updated)"
                                    },
                                    type: {
                                        type: "string",
                                        description: "Feature type (Feature or Service)"
                                    },
                                    purpose: {
                                        type: "string",
                                        description: "Detailed feature purpose/description"
                                    },
                                    additionalInfo: {
                                        type: "string",
                                        description: "Any additional information or answers to clarifying questions that should be considered"
                                    }
                                },
                                required: ["featureId"]
                            }
                        }
                    },
                    {
                        type: "function",
                        function: {
                            name: "search_internet",
                            description: "Search the internet for current information, news, documentation, or any topic. Use this when you need up-to-date information that you don't have in your training data or when the user asks about current events, recent technologies, or real-time data.",
                            parameters: {
                                type: "object",
                                properties: {
                                    query: {
                                        type: "string",
                                        description: "The search query to find relevant information"
                                    },
                                    reason: {
                                        type: "string",
                                        description: "Brief explanation of why this search is needed"
                                    }
                                },
                                required: ["query", "reason"]
                            }
                        }
                    }
                ];
            },

            async loadData() {
                try {
                    let loadedFromCloud = false;

                    // Try loading from Supabase first if connected
                    if (supabaseService.isConnected) {
                        console.log('üîÑ Loading data from Supabase...');
                        const cloudFeatures = await supabaseService.loadFeatures();

                        if (cloudFeatures !== null) {
                            this.features = cloudFeatures;
                            this.features.forEach(f => {
                                if (f.tags) f.tags.forEach(t => this.allTags.add(t));
                            });
                            console.log(`‚úÖ Loaded ${this.features.length} features from Supabase`);
                            loadedFromCloud = true;

                            // Also save to localStorage as offline cache
                            this.saveToLocalStorage();

                            // Check if we need to show migration prompt
                            this.checkMigrationNeeded();
                        }
                    }

                    // Fallback to localStorage if Supabase not available or no data
                    if (!loadedFromCloud) {
                        console.log('üì¶ Loading data from localStorage...');
                        const stored = localStorage.getItem('roadmapFeatures');
                        if (stored) {
                            this.features = JSON.parse(stored);
                            this.features.forEach(f => {
                                if (f.tags) f.tags.forEach(t => this.allTags.add(t));
                            });
                            console.log(`‚úÖ Loaded ${this.features.length} features from localStorage`);

                            // Check if we should migrate to cloud
                            this.checkMigrationNeeded();
                        } else {
                            console.log('‚ÑπÔ∏è No saved features found - starting fresh');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error loading features:', error);
                    this.showAlert({ title:'Load error', message:'Error loading your saved features. Data may be corrupted.', variant:'danger' });
                    this.features = [];
                }
            },

            async saveData() {
                // Save to localStorage first (for offline cache)
                const localSaved = this.saveToLocalStorage();

                // Also sync to Supabase if connected
                if (supabaseService.isConnected) {
                    this.updateSyncStatus('syncing');
                    const cloudSaved = await supabaseService.syncFeatures(this.features);
                    if (cloudSaved) {
                        this.updateSyncStatus('synced');
                        console.log('‚úÖ Data synced to cloud');
                    } else {
                        this.updateSyncStatus('error');
                        console.warn('‚ö†Ô∏è Cloud sync failed, data saved locally only');
                    }
                } else {
                    this.updateSyncStatus('offline');
                }

                return localSaved;
            },

            // Separate method for localStorage-only saves
            saveToLocalStorage() {
                try {
                    // Get all stored features (all workspaces)
                    const allStored = JSON.parse(localStorage.getItem('roadmapFeatures') || '[]');

                    // Remove current workspace's old features
                    const otherWorkspaceFeatures = allStored.filter(f => f.workspaceId !== this.currentWorkspaceId);

                    // Add current workspace's updated features
                    const updatedFeatures = [...otherWorkspaceFeatures, ...this.features];

                    const dataToSave = JSON.stringify(updatedFeatures);
                    localStorage.setItem('roadmapFeatures', dataToSave);
                    console.log(`‚úÖ Saved ${this.features.length} features for current workspace (${updatedFeatures.length} total features in localStorage, ${dataToSave.length} bytes)`);
                    return true;
                } catch (error) {
                    console.error('‚ùå Error saving to localStorage:', error);
                    if (error.name === 'QuotaExceededError') {
                        this.showAlert({ title:'Storage quota exceeded', message:'Your browser has run out of storage space. Try deleting some features, clearing browser data, or exporting your data as CSV backup.', variant:'warning' });
                    } else {
                        this.showAlert({ title:'Save error', message:'Error saving your data. Check browser console for details.', variant:'danger' });
                    }
                    return false;
                }
            },

            // Update sync status indicator
            updateSyncStatus(status = null) {
                const statusEl = document.getElementById('syncStatus');
                if (!statusEl) return;

                if (status === null) {
                    // Auto-detect status
                    if (!supabaseService.isConnected) {
                        status = 'offline';
                    } else {
                        status = 'synced';
                    }
                }

                const statuses = {
                    'synced': { text: '‚úì Synced', class: 'sync-status-success', title: 'Data is synced to cloud' },
                    'syncing': { text: '‚ü≥ Syncing...', class: 'sync-status-syncing', title: 'Syncing data to cloud' },
                    'offline': { text: 'üì¶ Offline', class: 'sync-status-offline', title: 'Working offline - data saved locally' },
                    'error': { text: '‚ö† Sync Error', class: 'sync-status-error', title: 'Failed to sync to cloud' }
                };

                const statusInfo = statuses[status] || statuses['offline'];
                statusEl.textContent = statusInfo.text;
                statusEl.className = 'sync-status ' + statusInfo.class;
                statusEl.title = statusInfo.title;
            },

            // Check if migration from localStorage to cloud is needed
            checkMigrationNeeded() {
                // Don't show migration if already migrated
                if (localStorage.getItem('migrationCompleted') === 'true') {
                    return;
                }

                // Check if we have localStorage data but no cloud data
                const localData = localStorage.getItem('roadmapFeatures');
                if (localData && supabaseService.isConnected) {
                    const localFeatures = JSON.parse(localData);
                    // If we have local data and Supabase is connected but returned empty, offer migration
                    if (localFeatures.length > 0 && this.features.length === 0) {
                        this.showMigrationModal(localFeatures);
                    } else if (localFeatures.length > 0 && this.features.length > 0) {
                        // Data already synced, mark as migrated
                        localStorage.setItem('migrationCompleted', 'true');
                    }
                }
            },

            // Show migration modal
            showMigrationModal(localFeatures) {
                const modal = document.getElementById('migrationModal');
                const overlay = document.getElementById('migrationOverlay');
                const count = document.getElementById('migrationCount');

                if (!modal || !overlay) {
                    // Modal elements don't exist yet, will be created later
                    return;
                }

                count.textContent = localFeatures.length;
                modal.classList.remove('hidden');
                overlay.classList.remove('hidden');
            },

            // Migrate data to cloud
            async migrateToCloud() {
                const localData = localStorage.getItem('roadmapFeatures');
                if (!localData) {
                    this.closeMigrationModal();
                    return;
                }

                try {
                    const localFeatures = JSON.parse(localData);
                    console.log(`üîÑ Migrating ${localFeatures.length} features to cloud...`);

                    // Show progress
                    const modal = document.getElementById('migrationModal');
                    const content = modal.querySelector('.migration-content');
                    content.innerHTML = '<p>‚ü≥ Migrating your data to cloud...</p><p>Please wait...</p>';

                    // Sync to Supabase
                    const success = await supabaseService.syncFeatures(localFeatures);

                    if (success) {
                        this.features = localFeatures;
                        localStorage.setItem('migrationCompleted', 'true');
                        content.innerHTML = '<p>‚úÖ Migration completed successfully!</p><p>Your data is now synced across all browsers and devices.</p>';
                        setTimeout(() => {
                            this.closeMigrationModal();
                            this.renderTable();
                            this.updateSyncStatus('synced');
                        }, 2000);
                    } else {
                        content.innerHTML = '<p>‚ùå Migration failed. Please try again later.</p><button class="btn-primary" onclick="app.closeMigrationModal()">Close</button>';
                    }
                } catch (error) {
                    console.error('‚ùå Migration error:', error);
                    this.showAlert({ title:'Migration failed', message:'Failed to migrate data to cloud. Your data is still safe locally.', variant:'danger' });
                    this.closeMigrationModal();
                }
            },

            // Skip migration
            skipMigration() {
                localStorage.setItem('migrationCompleted', 'true');
                this.closeMigrationModal();
            },

            // Close migration modal
            closeMigrationModal() {
                const modal = document.getElementById('migrationModal');
                const overlay = document.getElementById('migrationOverlay');
                if (modal) modal.classList.add('hidden');
                if (overlay) overlay.classList.add('hidden');
            },

            // ========== WORKSPACE MANAGEMENT ==========

            // Load workspaces from Supabase or localStorage
            async loadWorkspaces() {
                try {
                    // First, try to load from localStorage (primary source for immediate availability)
                    const stored = localStorage.getItem('roadmapWorkspaces');
                    if (stored) {
                        this.workspaces = JSON.parse(stored);
                        console.log(`‚úÖ Loaded ${this.workspaces.length} workspaces from localStorage`);
                    } else {
                        this.workspaces = [];
                        console.log('‚ÑπÔ∏è No workspaces found in localStorage');
                    }

                    // Then try to sync with Supabase if connected (don't replace local data if connection fails)
                    if (supabaseService.isConnected) {
                        try {
                            const cloudWorkspaces = await supabaseService.loadWorkspaces();
                            if (cloudWorkspaces !== null && cloudWorkspaces.length > 0) {
                                // Convert database format to app format
                                const cloudWorkspacesFormatted = cloudWorkspaces.map(w => ({
                                    id: w.id,
                                    name: w.name,
                                    description: w.description || '',
                                    color: w.color || '#3b82f6',
                                    icon: w.icon || 'üìä',
                                    customInstructions: w.custom_instructions || '',
                                    aiMemory: w.ai_memory || [],
                                    workflowModeEnabled: w.workflow_mode_enabled || false,
                                    workflowConfig: w.workflow_config || {
                                        enableIdeationStage: true,
                                        enablePlanningStage: true,
                                        enableExecutionStage: true,
                                        autoAdvanceStages: false,
                                        showStageGuides: true,
                                        stageRequirements: {
                                            ideation: ['inspirationItems', 'risks'],
                                            planning: ['executionSteps', 'milestones'],
                                            execution: ['status', 'progress']
                                        }
                                    },
                                    createdAt: w.created_at,
                                    updatedAt: w.updated_at
                                }));

                                // Merge with local data - prefer cloud data for newer items, but keep local if cloud is empty
                                if (this.workspaces.length === 0 || cloudWorkspacesFormatted.length > this.workspaces.length) {
                                    this.workspaces = cloudWorkspacesFormatted;
                                    console.log(`‚úÖ Synced ${this.workspaces.length} workspaces from cloud`);
                                    // Update localStorage with cloud data
                                    localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));
                                } else {
                                    console.log(`‚úÖ Local workspaces (${this.workspaces.length}) are up to date or newer than cloud`);
                                }
                            }
                        } catch (syncError) {
                            console.warn('‚ö†Ô∏è Could not sync workspaces with cloud:', syncError.message);
                            // Continue with local data
                        }
                    } else {
                        console.log('‚ÑπÔ∏è Offline mode - using local workspace data only');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading workspaces:', error);
                    // Try to recover from localStorage even if JSON parsing failed
                    try {
                        const stored = localStorage.getItem('roadmapWorkspaces');
                        if (stored) {
                            this.workspaces = JSON.parse(stored);
                            console.log(`üîÑ Recovered ${this.workspaces.length} workspaces from localStorage after error`);
                        } else {
                            this.workspaces = [];
                        }
                    } catch (recoveryError) {
                        console.error('‚ùå Could not recover workspace data:', recoveryError);
                        this.workspaces = [];
                    }
                }
            },

            // Get current workspace object
            getCurrentWorkspace() {
                return this.workspaces.find(w => w.id === this.currentWorkspaceId) || null;
            },

            // Create a new workspace
            async createWorkspace(name, description, color, icon) {
                const workspace = {
                    id: Date.now().toString(),
                    name: name,
                    description: description || '',
                    color: color || '#3b82f6',
                    icon: icon || 'üìä',
                    customInstructions: '',
                    aiMemory: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                this.workspaces.push(workspace);

                // Save to localStorage
                localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));

                // Save to Supabase
                if (supabaseService.isConnected) {
                    await supabaseService.createWorkspace(workspace);
                }

                console.log('‚úÖ Created workspace:', workspace.name);
                return workspace;
            },

            // Update a workspace
            async updateWorkspace(workspaceId, updates) {
                const workspace = this.workspaces.find(w => w.id === workspaceId);
                if (!workspace) {
                    console.error('‚ùå Workspace not found:', workspaceId);
                    return false;
                }

                // Update properties
                if (updates.name !== undefined) workspace.name = updates.name;
                if (updates.description !== undefined) workspace.description = updates.description;
                if (updates.color !== undefined) workspace.color = updates.color;
                if (updates.icon !== undefined) workspace.icon = updates.icon;
                if (updates.customInstructions !== undefined) workspace.customInstructions = updates.customInstructions;
                if (updates.aiMemory !== undefined) workspace.aiMemory = updates.aiMemory;
                workspace.updatedAt = new Date().toISOString();

                // Save to localStorage
                localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));

                // Save to Supabase
                if (supabaseService.isConnected) {
                    await supabaseService.updateWorkspace(workspaceId, workspace);
                }

                console.log('‚úÖ Updated workspace:', workspace.name);

                // Update UI if this is the current workspace
                if (workspaceId === this.currentWorkspaceId) {
                    this.renderWorkspaceSelector();
                }

                return true;
            },

            // Delete a workspace
            async deleteWorkspace(workspaceId) {
                const workspace = this.workspaces.find(w => w.id === workspaceId);
                if (!workspace) {
                    console.error('‚ùå Workspace not found:', workspaceId);
                    return false;
                }

                // Count features in this workspace
                const featureCount = this.features.filter(f => f.workspaceId === workspaceId).length;

                // Confirm deletion
                const confirmed = confirm(`Delete workspace "${workspace.name}"?\n\nThis will permanently delete ${featureCount} feature(s) in this workspace.\n\nThis action cannot be undone.`);
                if (!confirmed) return false;

                // Delete from Supabase first
                if (supabaseService.isConnected) {
                    await supabaseService.deleteWorkspace(workspaceId);
                }

                // Remove from local array
                this.workspaces = this.workspaces.filter(w => w.id !== workspaceId);

                // Remove all features in this workspace
                this.features = this.features.filter(f => f.workspaceId !== workspaceId);

                // Save to localStorage
                localStorage.setItem('roadmapWorkspaces', JSON.stringify(this.workspaces));
                this.saveToLocalStorage();

                console.log('‚úÖ Deleted workspace:', workspace.name);

                // Switch to another workspace or show welcome screen
                if (workspaceId === this.currentWorkspaceId) {
                    if (this.workspaces.length > 0) {
                        await this.switchWorkspace(this.workspaces[0].id);
                    } else {
                        this.currentWorkspaceId = null;
                        this.showWorkspaceWelcome();
                    }
                }

                return true;
            },

            // Switch to a different workspace
            async switchWorkspace(workspaceId) {
                const workspace = this.workspaces.find(w => w.id === workspaceId);
                if (!workspace) {
                    console.error('‚ùå Workspace not found:', workspaceId);
                    return;
                }

                console.log('üîÑ Switching to workspace:', workspace.name);

                // Save current workspace ID
                this.currentWorkspaceId = workspaceId;
                localStorage.setItem('currentWorkspaceId', workspaceId);

                // Load features for this workspace
                if (supabaseService.isConnected) {
                    const workspaceFeatures = await supabaseService.loadWorkspaceFeatures(workspaceId);
                    if (workspaceFeatures !== null) {
                        this.features = workspaceFeatures;
                    } else {
                        // Filter from cached features
                        this.features = this.features.filter(f => f.workspaceId === workspaceId);
                    }
                } else {
                    // Filter from localStorage
                    this.features = this.features.filter(f => f.workspaceId === workspaceId);
                }

                // Load workspace-specific AI settings
                this.customInstructions = workspace.customInstructions || '';
                this.memory = workspace.aiMemory || [];

                // Clear AI conversation when switching workspaces
                this.conversationHistory = [];
                this.messageCount = 0;
                this.lastAnalysisCount = 0;

                // Update UI
                this.renderTable();
                this.renderWorkspaceSelector();
                this.updateCounters();

                // Clear any selection
                this.selectedFeatureIds.clear();

                // Return to table view if in detail view
                if (this.currentView === 'detail') {
                    this.currentView = 'table';
                    window.location.hash = '';
                }

                console.log(`‚úÖ Switched to workspace: ${workspace.name} (${this.features.length} features)`);
            },

            // Render workspace selector in header
            renderWorkspaceSelector() {
                const container = document.getElementById('workspaceSelector');
                if (!container) return;

                const currentWorkspace = this.getCurrentWorkspace();
                if (!currentWorkspace) {
                    container.innerHTML = `
                        <div class="workspace-welcome">
                            <div class="workspace-welcome-header">
                                <button class="btn-create-workspace" onclick="app.showWorkspaceModal()">
                                    <span class="workspace-icon">üèóÔ∏è</span>
                                    <span class="workspace-text">Create Your First Workspace</span>
                                    <span class="workspace-arrow">‚Üí</span>
                                </button>
                            </div>
                            <div class="workspace-welcome-content">
                                <h3>Welcome to Platform Roadmap! üéØ</h3>
                                <p>Create a workspace to start organizing your features and roadmaps.</p>
                                <div class="workspace-benefits">
                                    <span>üìä Organize features by project</span>
                                    <span>üé® Customize with colors & icons</span>
                                    <span>üìà Track progress visually</span>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }

                // Create dropdown button with current workspace
                container.innerHTML = `
                    <div class="workspace-dropdown">
                        <button class="btn-workspace" onclick="app.toggleWorkspaceDropdown()" id="workspaceDropdownBtn">
                            <span class="workspace-icon" style="color: ${currentWorkspace.color}">${currentWorkspace.icon}</span>
                            <span class="workspace-name">${this.escapeHtml(currentWorkspace.name)}</span>
                            <span class="workspace-arrow">‚ñº</span>
                        </button>
                        <div class="workspace-dropdown-menu hidden" id="workspaceDropdownMenu">
                            ${this.workspaces.map(w => `
                                <div class="workspace-item ${w.id === this.currentWorkspaceId ? 'active' : ''}"
                                     onclick="app.selectWorkspaceFromDropdown('${w.id}')">
                                    <span class="workspace-icon" style="color: ${w.color}">${w.icon}</span>
                                    <span class="workspace-name">${this.escapeHtml(w.name)}</span>
                                    <button class="workspace-edit" onclick="event.stopPropagation(); app.editWorkspaceFromDropdown('${w.id}')" title="Edit workspace">‚úèÔ∏è</button>
                                    ${w.id === this.currentWorkspaceId ? '<span class="workspace-check">‚úì</span>' : ''}
                                </div>
                            `).join('')}
                            <div class="workspace-divider"></div>
                            <button class="workspace-item workspace-item-primary" onclick="app.showWorkspaceModal(); app.updateWorkspaceBanner();">
                                <span class="workspace-icon">üèóÔ∏è</span>
                                <span class="workspace-name">üèóÔ∏è Create New Workspace</span>
                            </button>
                            <button class="workspace-item" onclick="app.showWorkspaceManageModal()">
                                <span class="workspace-icon">‚öôÔ∏è</span>
                                <span class="workspace-name">Manage Workspaces</span>
                            </button>
                        </div>
                    </div>
                `;
            },

            // Toggle workspace dropdown
            toggleWorkspaceDropdown() {
                const menu = document.getElementById('workspaceDropdownMenu');
                if (!menu) return;

                menu.classList.toggle('hidden');

                // Close dropdown when clicking outside
                if (!menu.classList.contains('hidden')) {
                    setTimeout(() => {
                        const closeDropdown = (e) => {
                            if (!e.target.closest('.workspace-dropdown')) {
                                menu.classList.add('hidden');
                                document.removeEventListener('click', closeDropdown);
                            }
                        };
                        document.addEventListener('click', closeDropdown);
                    }, 0);
                }
            },

            // Toggle more dropdown
            toggleMoreDropdown() {
                const menu = document.getElementById('moreDropdownMenu');
                const dropdown = document.querySelector('.more-dropdown');
                if (!menu || !dropdown) return;

                const isHidden = menu.classList.contains('hidden');
                menu.classList.toggle('hidden');

                // Close dropdown when clicking outside
                if (!menu.classList.contains('hidden')) {
                    setTimeout(() => {
                        const closeDropdown = (e) => {
                            if (!e.target.closest('.more-dropdown')) {
                                menu.classList.add('hidden');
                                document.removeEventListener('click', closeDropdown);
                            }
                        };
                        document.addEventListener('click', closeDropdown);
                    }, 0);
                }
            },

            // Show API settings
            showApiSettings() {
                // Show API key input section if hidden
                const apiSection = document.getElementById('apiKeyInputSection');
                if (apiSection) {
                    apiSection.classList.remove('hidden');
                    // Focus on the API key input
                    const apiInput = document.getElementById('apiKeyInput');
                    if (apiInput) {
                        setTimeout(() => apiInput.focus(), 100);
                    }
                    // Show a notification
                    this.showAlert({
                        title: 'API Settings',
                        message: 'Configure your API keys in the chat area below.',
                        variant: 'info'
                    });
                } else {
                    this.showAlert({
                        title: 'API Settings',
                        message: 'Open the chat panel to access API settings.',
                        variant: 'info'
                    });
                }
            },

            // Select workspace from dropdown
            async selectWorkspaceFromDropdown(workspaceId) {
                const menu = document.getElementById('workspaceDropdownMenu');
                if (menu) menu.classList.add('hidden');

                if (workspaceId !== this.currentWorkspaceId) {
                    await this.switchWorkspace(workspaceId);
                }
            },

            // Edit workspace from dropdown
            editWorkspaceFromDropdown(workspaceId) {
                const menu = document.getElementById('workspaceDropdownMenu');
                if (menu) menu.classList.add('hidden');

                this.showWorkspaceModal(workspaceId);
            },

            // Control workspace banner visibility
            updateWorkspaceBanner() {
                const banner = document.getElementById('workspaceBanner');
                if (banner) {
                    // Show banner if no workspaces exist or if user wants to see it
                    const shouldShow = this.workspaces.length === 0;
                    banner.style.display = shouldShow ? 'block' : 'none';
                }
            },

            // Show workspace welcome screen (no workspaces exist)
            showWorkspaceWelcome() {
                // Hide workspace banner since we're showing the full welcome screen
                const banner = document.getElementById('workspaceBanner');
                if (banner) banner.style.display = 'none';

                const container = document.getElementById('tableContainer');
                if (!container) return;

                container.innerHTML = `
                    <div class="workspace-welcome">
                        <div class="workspace-welcome-icon">üìä</div>
                        <h2>Welcome to Your Roadmap Manager</h2>
                        <p>Create your first workspace to start organizing your roadmaps and features.</p>
                        <p class="workspace-welcome-subtitle">Workspaces help you manage multiple projects independently.</p>
                        <button class="btn-primary btn-lg" onclick="app.showWorkspaceModal()">
                            ‚ûï Create Your First Workspace
                        </button>
                    </div>
                `;
            },

            // Show workspace creation/edit modal
            showWorkspaceModal(workspaceId = null) {
                const isEdit = workspaceId !== null;
                const workspace = isEdit ? this.workspaces.find(w => w.id === workspaceId) : null;

                const modal = document.createElement('div');
                modal.id = 'workspaceModalOverlay';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content workspace-modal">
                        <div class="modal-header">
                            <h3>${isEdit ? 'Edit Workspace' : 'Create New Workspace'}</h3>
                            <button class="modal-close" onclick="app.closeWorkspaceModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="workspaceName">Workspace Name *</label>
                                <input type="text" id="workspaceName" class="form-control"
                                       placeholder="e.g., Product Roadmap 2024"
                                       value="${isEdit ? this.escapeHtml(workspace.name) : ''}" required>
                            </div>
                            <div class="form-group">
                                <label for="workspaceDescription">Description</label>
                                <textarea id="workspaceDescription" class="form-control" rows="3"
                                          placeholder="Optional description for this workspace">${isEdit ? this.escapeHtml(workspace.description) : ''}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="workspaceColor">Color</label>
                                <div class="color-picker">
                                    <input type="color" id="workspaceColor" value="${isEdit ? workspace.color : '#3b82f6'}">
                                    <span class="color-preview" id="colorPreview"></span>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="workspaceIcon">Icon (Emoji)</label>
                                <div class="icon-picker" id="iconPicker">
                                    ${[
                                        'üìä', 'üìà', 'üìâ', 'üìã', 'üìù', 'üìÖ', 'üéØ', '‚≠ê', 'üöÄ', 'üí°',
                                        'üîß', '‚öôÔ∏è', 'üé®', 'üì±', 'üíª', 'üåê', 'üîó', 'üìÇ', 'üìÅ', 'üóÇÔ∏è',
                                        'üìÑ', 'üìÉ', 'üèóÔ∏è', 'üõ†Ô∏è', 'üîç', 'üìä', 'üíº', 'üè¢', 'üè≠', 'üè™'
                                    ].map(icon => `
                                        <button type="button" class="icon-option ${icon === (isEdit ? workspace.icon : 'üìä') ? 'selected' : ''}"
                                                onclick="app.selectWorkspaceIcon('${icon}')" title="${icon}">
                                            ${icon}
                                        </button>
                                    `).join('')}
                                </div>
                                <input type="hidden" id="workspaceIcon" value="${isEdit ? workspace.icon : 'üìä'}">
                                <small class="form-hint">Choose an emoji to represent this workspace</small>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" onclick="app.closeWorkspaceModal()">Cancel</button>
                            <button class="btn-primary" onclick="app.saveWorkspaceFromModal(${isEdit ? `'${workspaceId}'` : 'null'})">
                                ${isEdit ? 'Save Changes' : 'Create Workspace'}
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
                document.getElementById('workspaceName').focus();
            },

            // Select workspace icon from picker
            selectWorkspaceIcon(icon) {
                document.getElementById('workspaceIcon').value = icon;

                // Update visual selection
                const picker = document.getElementById('iconPicker');
                const options = picker.querySelectorAll('.icon-option');
                options.forEach(option => {
                    option.classList.remove('selected');
                    if (option.textContent.trim() === icon) {
                        option.classList.add('selected');
                    }
                });
            },

            // Save workspace from modal
            async saveWorkspaceFromModal(workspaceId) {
                const name = document.getElementById('workspaceName').value.trim();
                const description = document.getElementById('workspaceDescription').value.trim();
                const color = document.getElementById('workspaceColor').value;
                const icon = document.getElementById('workspaceIcon').value.trim() || 'üìä';

                if (!name) {
                    this.showAlert({ title: 'Validation Error', message: 'Workspace name is required', variant: 'warning' });
                    return;
                }

                try {
                    if (workspaceId) {
                        // Update existing workspace
                        await this.updateWorkspace(workspaceId, { name, description, color, icon });
                        this.showAlert({ title: 'Success', message: 'Workspace updated successfully', variant: 'success' });
                    } else {
                        // Create new workspace
                        const workspace = await this.createWorkspace(name, description, color, icon);

                        // Switch to the new workspace
                        await this.switchWorkspace(workspace.id);

                        this.showAlert({ title: 'Success', message: 'Workspace created successfully', variant: 'success' });
                    }

                    this.closeWorkspaceModal();
                } catch (error) {
                    console.error('‚ùå Error saving workspace:', error);
                    this.showAlert({ title: 'Error', message: 'Failed to save workspace. Please try again.', variant: 'danger' });
                }
            },

            // Close workspace modal
            closeWorkspaceModal() {
                const modal = document.getElementById('workspaceModalOverlay');
                if (modal) modal.remove();
            },

            // Show workspace management modal
            showWorkspaceManageModal() {
                // Close dropdown first
                const dropdown = document.getElementById('workspaceDropdownMenu');
                if (dropdown) dropdown.classList.add('hidden');

                const modal = document.createElement('div');
                modal.id = 'workspaceManageOverlay';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content workspace-manage-modal">
                        <div class="modal-header">
                            <h3>Manage Workspaces</h3>
                            <button class="modal-close" onclick="app.closeWorkspaceManageModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="workspace-list">
                                ${this.workspaces.map(w => {
                                    const featureCount = this.features.filter(f => f.workspaceId === w.id).length;
                                    return `
                                        <div class="workspace-list-item ${w.id === this.currentWorkspaceId ? 'active' : ''}">
                                            <div class="workspace-info">
                                                <span class="workspace-icon-lg" style="color: ${w.color}">${w.icon}</span>
                                                <div class="workspace-details">
                                                    <div class="workspace-title">${this.escapeHtml(w.name)}</div>
                                                    <div class="workspace-meta">
                                                        ${w.description ? `<div>${this.escapeHtml(w.description)}</div>` : ''}
                                                        <div class="workspace-stats">${featureCount} feature${featureCount !== 1 ? 's' : ''}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="workspace-actions">
                                                ${w.id === this.currentWorkspaceId ? '<span class="workspace-badge-current">Current</span>' : `<button class="btn-sm btn-secondary" onclick="app.selectWorkspaceFromManage('${w.id}')">Switch</button>`}
                                                <button class="btn-sm btn-secondary" onclick="app.editWorkspaceFromManage('${w.id}')">Edit</button>
                                                <button class="btn-sm btn-danger" onclick="app.deleteWorkspaceFromManage('${w.id}')">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-primary" onclick="app.showWorkspaceModalFromManage()">+ New Workspace</button>
                            <button class="btn-secondary" onclick="app.closeWorkspaceManageModal()">Close</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            },

            // Select workspace from manage modal
            async selectWorkspaceFromManage(workspaceId) {
                await this.switchWorkspace(workspaceId);
                this.closeWorkspaceManageModal();
            },

            // Edit workspace from manage modal
            editWorkspaceFromManage(workspaceId) {
                this.closeWorkspaceManageModal();
                this.showWorkspaceModal(workspaceId);
            },

            // Delete workspace from manage modal
            async deleteWorkspaceFromManage(workspaceId) {
                const deleted = await this.deleteWorkspace(workspaceId);
                if (deleted) {
                    this.closeWorkspaceManageModal();
                    // Reopen if there are still workspaces
                    if (this.workspaces.length > 0) {
                        setTimeout(() => this.showWorkspaceManageModal(), 300);
                    }
                }
            },

            // Show workspace modal from manage modal
            showWorkspaceModalFromManage() {
                this.closeWorkspaceManageModal();
                this.showWorkspaceModal();
            },

            // Close workspace manage modal
            closeWorkspaceManageModal() {
                const modal = document.getElementById('workspaceManageOverlay');
                if (modal) modal.remove();
            },

            // ========== END WORKSPACE MANAGEMENT ==========

            loadApiKey() {
                const stored = localStorage.getItem('openrouterApiKey');
                if (stored) {
                    this.apiKey = stored;
                    document.getElementById('apiKeyInput').value = stored;
                    // Hide input, show status
                    document.getElementById('apiKeyInputSection').classList.add('hidden');
                    const headerStatus = document.getElementById('chatHeaderApiStatus');
                    if (headerStatus) headerStatus.classList.remove('hidden');
                } else {
                    // No API key stored, show input section
                    document.getElementById('apiKeyInputSection').classList.remove('hidden');
                    const headerStatus = document.getElementById('chatHeaderApiStatus');
                    if (headerStatus) headerStatus.classList.add('hidden');
                }
            },

            saveApiKey(key) {
                this.apiKey = key;
                localStorage.setItem('openrouterApiKey', key);
                // Hide input, show status
                if (key) {
                    document.getElementById('apiKeyInputSection').classList.add('hidden');
                    const headerStatus = document.getElementById('chatHeaderApiStatus');
                    if (headerStatus) headerStatus.classList.remove('hidden');
                }
            },

            loadTavilyApiKey() {
                const stored = localStorage.getItem('tavilyApiKey');
                if (stored) {
                    this.tavilyApiKey = stored;
                    const input = document.getElementById('tavilyApiKeyInput');
                    if (input) input.value = stored;
                }
            },

            saveTavilyApiKey(key) {
                this.tavilyApiKey = key;
                localStorage.setItem('tavilyApiKey', key);
            },

            loadExaApiKey() {
                const stored = localStorage.getItem('exaApiKey');
                if (stored) {
                    this.exaApiKey = stored;
                    const input = document.getElementById('exaApiKeyInput');
                    if (input) input.value = stored;
                }
            },

            saveExaApiKey(key) {
                this.exaApiKey = key;
                localStorage.setItem('exaApiKey', key);
            },

            loadPerplexityApiKey() {
                const stored = localStorage.getItem('perplexityApiKey');
                if (stored) {
                    this.perplexityApiKey = stored;
                    const input = document.getElementById('perplexityApiKeyInput');
                    if (input) input.value = stored;
                }
            },

            savePerplexityApiKey(key) {
                this.perplexityApiKey = key;
                localStorage.setItem('perplexityApiKey', key);
            },

            toggleApiKeyInput() {
                const inputSection = document.getElementById('apiKeyInputSection');
                const headerStatus = document.getElementById('chatHeaderApiStatus');

                if (inputSection.classList.contains('hidden')) {
                    // Expanding settings
                    inputSection.classList.remove('hidden');
                    if (headerStatus) headerStatus.classList.add('hidden');
                } else {
                    // Minimizing settings - only if API key is set
                    if (this.apiKey) {
                        inputSection.classList.add('hidden');
                        if (headerStatus) headerStatus.classList.remove('hidden');
                    } else {
                        this.showAlert({ title: 'API key required', message: 'Please enter your API key first!' });
                    }
                }
            },

            autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
            },

            loadModel() {
                const stored = localStorage.getItem('selectedModel');
                if (stored) {
                    this.selectedModel = stored;
                    const modelSelect = document.getElementById('modelSelect');
                    if (modelSelect) modelSelect.value = stored;
                }
            },

            saveModel(model) {
                this.selectedModel = model;
                localStorage.setItem('selectedModel', model);
                const modelSelect = document.getElementById('modelSelect');
                if (modelSelect) modelSelect.value = model;
            },

            loadCustomInstructions() {
                const stored = localStorage.getItem('customInstructions');
                if (stored) {
                    this.customInstructions = stored;
                    const textarea = document.getElementById('customInstructionsInput');
                    if (textarea) {
                        textarea.value = stored;
                    }
                }
            },

            saveCustomInstructions(instructions) {
                this.customInstructions = instructions;
                localStorage.setItem('customInstructions', instructions);
            },

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            loadMemory() {
                try {
                    const stored = localStorage.getItem('aiMemory');
                    if (stored) {
                        this.memory = JSON.parse(stored);
                        console.log(`‚úÖ Loaded ${this.memory.length} memory items`);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading memory:', error);
                    this.memory = [];
                }
            },

            saveMemory() {
                try {
                    localStorage.setItem('aiMemory', JSON.stringify(this.memory));
                    console.log(`‚úÖ Saved ${this.memory.length} memory items`);
                } catch (error) {
                    console.error('‚ùå Error saving memory:', error);
                }
            },

            addToMemory(item) {
                this.memory.push({
                    content: item,
                    timestamp: new Date().toISOString()
                });
                this.saveMemory();
                this.renderMemoryList();
                this.updateCounters();
            },

            addMemoryFromInput() {
                const input = document.getElementById('addMemoryInput');
                const text = input?.value.trim();
                if (text) {
                    this.addToMemory(text);
                    input.value = '';
                }
            },

            removeFromMemory(index) {
                this.memory.splice(index, 1);
                this.saveMemory();
                this.renderMemoryList();
                this.updateCounters();
            },

            renderMemoryList() {
                const container = document.getElementById('memoryList');
                if (!container) return;

                if (this.memory.length === 0) {
                    container.innerHTML = '<div style="color:var(--text-muted); font-size:12px; padding:10px;">No memory items yet. The AI will suggest adding important information here.</div>';
                    return;
                }

                container.innerHTML = this.memory.map((item, index) => `
                    <div style="background:var(--surface-alt); padding:10px; border-radius:6px; margin-bottom:8px; font-size:12px;">
                        <div style="display:flex; justify-content:space-between; align-items:start;">
                            <div style="flex:1; color:var(--text-secondary);">${item.content}</div>
                            <button onclick="app.removeFromMemory(${index})" style="background:none; border:none; color:var(--danger); cursor:pointer; font-size:16px; padding:0 0 0 8px;">&times;</button>
                        </div>
                        <div style="color:var(--text-muted); font-size:10px; margin-top:4px;">${new Date(item.timestamp).toLocaleString()}</div>
                    </div>
                `).join('');
            },

            toggleMemoryPanel() {
                const panel = document.getElementById('memoryPanel');
                if (panel) {
                    panel.classList.toggle('hidden');
                    if (!panel.classList.contains('hidden')) {
                        this.renderMemoryList();
                    }
                }
            },

            async clearMemory() {
                const ok = await this.showConfirm({ title:'Clear all memory?', message:'This cannot be undone.', confirmText:'Clear', cancelText:'Cancel', variant:'danger' });
                if (!ok) return;
                this.memory = [];
                this.saveMemory();
                this.renderMemoryList();
                this.updateCounters();
            },

            async compactConversation() {
                await chatPanel.compactConversation(this);
            },

            loadMemorySuggestions() {
                try {
                    const stored = localStorage.getItem('memorySuggestions');
                    if (stored) {
                        this.memorySuggestions = JSON.parse(stored);
                        console.log(`‚úÖ Loaded ${this.memorySuggestions.length} memory suggestions`);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading memory suggestions:', error);
                    this.memorySuggestions = [];
                }
            },

            saveMemorySuggestions() {
                try {
                    localStorage.setItem('memorySuggestions', JSON.stringify(this.memorySuggestions));
                    console.log(`‚úÖ Saved ${this.memorySuggestions.length} memory suggestions`);
                } catch (error) {
                    console.error('‚ùå Error saving memory suggestions:', error);
                }
            },

            loadLinkSuggestions() {
                try {
                    const stored = localStorage.getItem('linkSuggestions');
                    if (stored) {
                        this.linkSuggestions = JSON.parse(stored);

                        // Clean up any same-feature suggestions that might have been stored
                        const originalCount = this.linkSuggestions.length;
                        this.linkSuggestions = this.linkSuggestions.filter(suggestion => {
                            return suggestion.sourceFeatureId !== suggestion.targetFeatureId;
                        });

                        if (this.linkSuggestions.length < originalCount) {
                            console.log(`üßπ Cleaned up ${originalCount - this.linkSuggestions.length} invalid same-feature suggestions`);
                            this.saveLinkSuggestions();
                        }

                        console.log(`‚úÖ Loaded ${this.linkSuggestions.length} link suggestions`);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading link suggestions:', error);
                    this.linkSuggestions = [];
                }
            },

            saveLinkSuggestions() {
                try {
                    localStorage.setItem('linkSuggestions', JSON.stringify(this.linkSuggestions));
                    console.log(`‚úÖ Saved ${this.linkSuggestions.length} link suggestions`);
                } catch (error) {
                    console.error('‚ùå Error saving link suggestions:', error);
                }
            },

            loadRejectedLinks() {
                try {
                    const stored = localStorage.getItem('rejectedLinks');
                    if (stored) {
                        this.rejectedLinks = JSON.parse(stored);
                        console.log(`‚úÖ Loaded ${this.rejectedLinks.length} rejected links`);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading rejected links:', error);
                    this.rejectedLinks = [];
                }
            },

            saveRejectedLinks() {
                try {
                    localStorage.setItem('rejectedLinks', JSON.stringify(this.rejectedLinks));
                    console.log(`‚úÖ Saved ${this.rejectedLinks.length} rejected links`);
                } catch (error) {
                    console.error('‚ùå Error saving rejected links:', error);
                }
            },

            addMemorySuggestion(content) {
                const suggestion = {
                    id: Date.now().toString(),
                    content: content,
                    timestamp: new Date().toISOString()
                };
                this.memorySuggestions.push(suggestion);
                this.saveMemorySuggestions();
                this.updateSuggestionNotification();
            },

            approveSuggestion(id) {
                const suggestion = this.memorySuggestions.find(s => s.id === id);
                if (suggestion) {
                    this.addToMemory(suggestion.content);
                    this.memorySuggestions = this.memorySuggestions.filter(s => s.id !== id);
                    this.saveMemorySuggestions();
                    this.renderMemorySuggestions();
                    this.updateSuggestionNotification();
                }
            },

            rejectSuggestion(id) {
                this.memorySuggestions = this.memorySuggestions.filter(s => s.id !== id);
                this.saveMemorySuggestions();
                this.renderMemorySuggestions();
                this.updateSuggestionNotification();
            },

            approveAllSuggestions() {
                this.memorySuggestions.forEach(suggestion => {
                    this.addToMemory(suggestion.content);
                });
                this.memorySuggestions = [];
                this.saveMemorySuggestions();
                this.renderMemorySuggestions();
                this.updateSuggestionNotification();
            },

            async rejectAllSuggestions() {
                const ok = await this.showConfirm({ title:'Reject all suggestions?', message:'This cannot be undone.', confirmText:'Reject all', cancelText:'Cancel', variant:'danger' });
                if (!ok) return;
                this.memorySuggestions = [];
                this.saveMemorySuggestions();
                this.renderMemorySuggestions();
                this.updateSuggestionNotification();
            },

            toggleMemorySuggestions() {
                const list = document.getElementById('memorySuggestionsList');
                if (list) {
                    const isExpanded = list.classList.contains('active');
                    if (!isExpanded) {
                        this.renderMemorySuggestions();
                    }
                    list.classList.toggle('active');
                }
            },

            toggleLinkSuggestions() {
                const list = document.getElementById('linkSuggestionsList');
                if (list) {
                    const isExpanded = list.classList.contains('active');
                    if (!isExpanded) {
                        this.renderLinkSuggestions();
                    }
                    list.classList.toggle('active');
                }
            },

            toggleLinkDetails(suggestionId) {
                const details = document.getElementById(`details-${suggestionId}`);
                const toggle = document.getElementById(`toggle-${suggestionId}`);
                if (details && toggle) {
                    const isVisible = details.style.display !== 'none';
                    details.style.display = isVisible ? 'none' : 'block';
                    toggle.textContent = isVisible ? '‚ñº Show Details' : '‚ñ≤ Hide Details';
                }
            },

            // Manual Link Management Functions
            currentLinkSourceItemId: null,
            currentRejectionId: null,

            showAddLinkModal(itemId) {
                this.currentLinkSourceItemId = itemId;

                // Find the current feature (to exclude it from target options)
                const currentFeature = this.editingId ? this.features.find(f => f.id === this.editingId) : null;

                // Populate feature dropdown (exclude current feature)
                const featureSelect = document.getElementById('linkTargetFeature');
                featureSelect.innerHTML = '<option value="">Select feature...</option>';

                this.features.forEach(feature => {
                    if (currentFeature && feature.id === currentFeature.id) return; // Skip same feature
                    featureSelect.innerHTML += `<option value="${feature.id}">${feature.name}</option>`;
                });

                // Clear other fields
                document.getElementById('linkTargetItem').innerHTML = '<option value="">Select timeline item...</option>';
                document.getElementById('linkReason').value = '';
                document.querySelector('input[name="linkType"][value="dependency"]').checked = true;

                // Show modal
                const overlay = document.getElementById('linkPickerOverlay');
                const modal = document.getElementById('linkPickerModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                overlay.classList.remove('hidden');
                modal.classList.remove('hidden');
                this._linkPickerRelease = this.trapFocus(modal);
            },

            updateLinkTargetItems() {
                const featureId = document.getElementById('linkTargetFeature').value;
                const itemSelect = document.getElementById('linkTargetItem');

                itemSelect.innerHTML = '<option value="">Select timeline item...</option>';

                if (!featureId) return;

                const feature = this.features.find(f => f.id === featureId);
                if (feature && feature.timelineItems) {
                    feature.timelineItems.forEach(item => {
                        itemSelect.innerHTML += `<option value="${item.id}">${item.timeline} - ${item.difficulty}</option>`;
                    });
                }
            },

            async saveManualLink() {
                const targetFeatureId = document.getElementById('linkTargetFeature').value;
                const targetItemId = document.getElementById('linkTargetItem').value;
                const linkType = document.querySelector('input[name="linkType"]:checked').value;
                const reason = document.getElementById('linkReason').value.trim() || 'Manually linked';

                if (!targetFeatureId || !targetItemId) {
                    await this.showAlert({ title:'Missing selection', message:'Please select both target feature and timeline item.' });
                    return;
                }

                // Find source item in currentTimelineItems
                const sourceItem = this.currentTimelineItems.find(i => i.id === this.currentLinkSourceItemId);
                if (!sourceItem) {
                    await this.showAlert({ title:'Not found', message:'Error: Source item not found.' , variant:'danger'});
                    return;
                }

                // Initialize linkedItems if not exists
                if (!sourceItem.linkedItems) {
                    sourceItem.linkedItems = [];
                }

                // Check if link already exists
                const linkExists = sourceItem.linkedItems.some(l => l.linkedItemId === targetItemId);
                if (linkExists) {
                    await this.showAlert({ title:'Duplicate link', message:'This link already exists.' });
                    return;
                }

                // Add outgoing link to source
                sourceItem.linkedItems.push({
                    linkedItemId: targetItemId,
                    linkedFeatureId: targetFeatureId,
                    relationshipType: linkType,
                    reason: reason,
                    direction: 'outgoing'
                });

                // Add bidirectional link to target (in the actual feature, not currentTimelineItems)
                if (this.editingId) {
                    const targetFeature = this.features.find(f => f.id === targetFeatureId);
                    if (targetFeature) {
                        const targetItem = targetFeature.timelineItems.find(i => i.id === targetItemId);
                        if (targetItem) {
                            if (!targetItem.linkedItems) {
                                targetItem.linkedItems = [];
                            }
                            targetItem.linkedItems.push({
                                linkedItemId: this.currentLinkSourceItemId,
                                linkedFeatureId: this.editingId,
                                relationshipType: linkType,
                                reason: reason,
                                direction: 'incoming'
                            });
                        }
                    }
                }

                // Re-render timeline items to show new link
                this.renderTimelineItems();

                // Close modal
                this.closeLinkPicker();

                console.log('‚úÖ Manual link created');
            },

            async removeLink(sourceItemId, linkedItemId) {
                const ok = await this.showConfirm({ title:'Remove link?', message:'This will unlink the items.', confirmText:'Remove', cancelText:'Cancel', variant:'danger' });
                if (!ok) return;

                // Find source item
                const sourceItem = this.currentTimelineItems.find(i => i.id === sourceItemId);
                if (!sourceItem || !sourceItem.linkedItems) return;

                // Find the link to get target feature ID
                const link = sourceItem.linkedItems.find(l => l.linkedItemId === linkedItemId);
                if (!link) return;

                // Remove from source
                sourceItem.linkedItems = sourceItem.linkedItems.filter(l => l.linkedItemId !== linkedItemId);

                // Remove bidirectional link from target
                if (this.editingId) {
                    const targetFeature = this.features.find(f => f.id === link.linkedFeatureId);
                    if (targetFeature) {
                        const targetItem = targetFeature.timelineItems.find(i => i.id === linkedItemId);
                        if (targetItem && targetItem.linkedItems) {
                            targetItem.linkedItems = targetItem.linkedItems.filter(l => l.linkedItemId !== sourceItemId);
                        }
                    }
                }

                // Re-render
                this.renderTimelineItems();

                console.log('‚úÖ Link removed');
            },

            closeLinkPicker() {
                document.getElementById('linkPickerOverlay').classList.add('hidden');
                document.getElementById('linkPickerModal').classList.add('hidden');
                if (this._linkPickerRelease) { this._linkPickerRelease(); this._linkPickerRelease = null; }
                this.currentLinkSourceItemId = null;
            },

            buildNarrativeExplanation(sourceFeature, sourceItem, targetFeature, targetItem, relationshipType) {
                // Build a narrative explanation of how the features are linked
                const sourceName = sourceFeature.name;
                const targetName = targetFeature.name;
                const sourceCategories = (sourceItem.category || []).join(', ') || 'general functionality';
                const targetCategories = (targetItem.category || []).join(', ') || 'general functionality';
                const sourceIntegration = sourceItem.integrationType || 'standard implementation';
                const targetIntegration = targetItem.integrationType || 'standard implementation';
                const sourceUSP = sourceItem.usp || '';
                const targetUSP = targetItem.usp || '';
                
                let narrative = '';
                
                if (relationshipType === 'dependency') {
                    // Dependency narrative
                    narrative += `<strong>${sourceName}</strong> depends on <strong>${targetName}</strong> because `;
                    
                    // Add context about categories
                    if (sourceCategories !== 'general functionality' || targetCategories !== 'general functionality') {
                        narrative += `${sourceName}'s ${sourceCategories} functionality requires ${targetName}'s ${targetCategories} capabilities to be in place first. `;
                    } else {
                        narrative += `it requires the foundational capabilities provided by ${targetName}. `;
                    }
                    
                    // Add integration context if meaningful
                    if (sourceIntegration !== 'standard implementation' || targetIntegration !== 'standard implementation') {
                        narrative += `The ${sourceIntegration} used by ${sourceName} relies on ${targetName}'s ${targetIntegration} being operational. `;
                    }
                    
                    // Add USP context if available
                    if (sourceUSP && targetUSP) {
                        narrative += `While ${sourceName} ${sourceUSP}, this value proposition can only be delivered once ${targetName} ${targetUSP}. `;
                    } else if (sourceUSP) {
                        narrative += `This dependency ensures ${sourceName} can deliver its promise to ${sourceUSP}. `;
                    }
                    
                    // Add timeline context
                    narrative += `Timeline: ${targetName} (${targetItem.timeline}, ${targetItem.difficulty} difficulty) should be completed before ${sourceName} (${sourceItem.timeline}, ${sourceItem.difficulty} difficulty).`;
                    
                } else {
                    // Complements narrative
                    narrative += `<strong>${sourceName}</strong> and <strong>${targetName}</strong> complement each other because `;
                    
                    // Add synergy context
                    if (sourceCategories !== 'general functionality' && targetCategories !== 'general functionality') {
                        narrative += `${sourceName}'s ${sourceCategories} capabilities work synergistically with ${targetName}'s ${targetCategories} features to create a more comprehensive solution. `;
                    } else {
                        narrative += `together they create a more complete and valuable user experience. `;
                    }
                    
                    // Add integration synergy if meaningful
                    if (sourceIntegration !== 'standard implementation' && targetIntegration !== 'standard implementation') {
                        narrative += `The ${sourceIntegration} in ${sourceName} pairs naturally with ${targetName}'s ${targetIntegration}, enabling cross-feature workflows. `;
                    }
                    
                    // Add USP synergy if available
                    if (sourceUSP && targetUSP) {
                        narrative += `When ${sourceName} ${sourceUSP} alongside ${targetName} which ${targetUSP}, users gain enhanced value from both features working together. `;
                    } else if (sourceUSP) {
                        narrative += `${sourceName}'s ability to ${sourceUSP} is amplified when used in conjunction with ${targetName}. `;
                    } else if (targetUSP) {
                        narrative += `${targetName}'s ability to ${targetUSP} is enhanced when paired with ${sourceName}. `;
                    }
                    
                    // Add timeline context
                    narrative += `Timeline: Both features are planned for ${sourceItem.timeline === targetItem.timeline ? 'the same phase (' + sourceItem.timeline + ')' : 'nearby phases (' + sourceName + ': ' + sourceItem.timeline + ', ' + targetName + ': ' + targetItem.timeline + ')'}, making them natural complements.`;
                }
                
                return narrative;
            },

            renderLinkSuggestions() {
                const container = document.getElementById('linkSuggestionsList');
                if (!container) return;

                if (this.linkSuggestions.length === 0) {
                    container.innerHTML = '<div style="color:rgba(255,255,255,0.8); font-size:12px; padding:10px; text-align:center;">No link suggestions</div>';
                    return;
                }

                let html = '';
                this.linkSuggestions.forEach(suggestion => {
                    const sourceFeature = this.features.find(f => f.id === suggestion.sourceFeatureId);
                    const targetFeature = this.features.find(f => f.id === suggestion.targetFeatureId);
                    const sourceItem = sourceFeature?.timelineItems.find(i => i.id === suggestion.sourceItemId);
                    const targetItem = targetFeature?.timelineItems.find(i => i.id === suggestion.targetItemId);

                    if (!sourceFeature || !targetFeature || !sourceItem || !targetItem) return;

                    // CRITICAL: Skip same-feature suggestions (safety check during rendering)
                    if (sourceFeature.id === targetFeature.id) {
                        console.warn(`Blocked same-feature suggestion from rendering: ${sourceFeature.name}`);
                        return;
                    }

                    const typeClass = suggestion.type === 'dependency' ? 'link-type-dependency' : 'link-type-complements';
                    const typeLabel = suggestion.type === 'dependency' ? 'Dependency' : 'Complements';
                    const confidenceClass = suggestion.confidence === 'high' ? 'confidence-high' : 'confidence-medium';
                    const confidenceLabel = suggestion.confidence === 'high' ? 'High Confidence' : 'Medium Confidence';

                    // Build narrative explanation
                    const narrativeExplanation = this.buildNarrativeExplanation(
                        sourceFeature, sourceItem, targetFeature, targetItem, suggestion.type
                    );

                    html += `
                        <div class="link-suggestion-item">
                            <div class="link-suggestion-header">
                                <div class="link-suggestion-features">
                                    <strong>${sourceFeature.name}</strong> (${sourceItem.timeline})
                                    <span class="link-suggestion-arrow">${suggestion.type === 'dependency' ? '‚Üí' : '‚Üî'}</span>
                                    <strong>${targetFeature.name}</strong> (${targetItem.timeline})
                                    <span class="link-suggestion-type ${typeClass}">${typeLabel}</span>
                                    <span class="link-suggestion-confidence ${confidenceClass}">${confidenceLabel}</span>
                                </div>
                            </div>
                            <div class="link-suggestion-reason"><strong>AI Insight:</strong> ${suggestion.reason}</div>
                            <div class="link-suggestion-details" id="details-${suggestion.id}" style="display:none; margin-top:8px; padding:8px; background:rgba(255,255,255,0.1); border-radius:4px; font-size:12px; line-height:1.6;">
                                <div style="color:rgba(255,255,255,0.95);">
                                    ${narrativeExplanation}
                                </div>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
                                <button onclick="app.toggleLinkDetails('${suggestion.id}')" style="padding:4px 8px; font-size:11px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); color:white; border-radius:4px; cursor:pointer;">
                                    <span id="toggle-${suggestion.id}">‚ñº Show Details</span>
                                </button>
                                <div class="link-suggestion-actions">
                                    <button onclick="app.approveLinkSuggestion('${suggestion.id}')">‚úì Approve</button>
                                    <button onclick="app.rejectLinkSuggestion('${suggestion.id}')">‚úó Reject</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `
                    <div class="link-notification-bulk-actions">
                        <button onclick="app.approveAllLinkSuggestions()">‚úì Approve All</button>
                        <button onclick="app.rejectAllLinkSuggestions()">‚úó Reject All</button>
                    </div>
                `;

                container.innerHTML = html;
            },

            updateLinkNotification() {
                const notification = document.getElementById('linkNotification');
                const count = document.getElementById('linkSuggestionCount');

                if (count) {
                    count.textContent = this.linkSuggestions.length;
                }

                if (notification) {
                    if (this.linkSuggestions.length > 0) {
                        notification.classList.remove('hidden');
                    } else {
                        notification.classList.add('hidden');
                        document.getElementById('linkSuggestionsList')?.classList.remove('active');
                    }
                }
            },

            async approveLinkSuggestion(id) {
                const suggestion = this.linkSuggestions.find(s => s.id === id);
                if (suggestion) {
                    // CRITICAL: Final check - reject same-feature links
                    if (suggestion.sourceFeatureId === suggestion.targetFeatureId) {
                        console.error('‚ùå Blocked approval of same-feature link');
                        await this.showAlert({ title:'Cannot approve', message:'This link is between timeline items of the same feature, which is not allowed.', variant:'warning' });
                        // Remove the invalid suggestion
                        this.linkSuggestions = this.linkSuggestions.filter(s => s.id !== id);
                        this.saveLinkSuggestions();
                        this.renderLinkSuggestions();
                        this.updateLinkNotification();
                        return;
                    }

                    // Add the link to both timeline items
                    const sourceFeature = this.features.find(f => f.id === suggestion.sourceFeatureId);
                    const targetFeature = this.features.find(f => f.id === suggestion.targetFeatureId);
                    const sourceItem = sourceFeature?.timelineItems.find(i => i.id === suggestion.sourceItemId);
                    const targetItem = targetFeature?.timelineItems.find(i => i.id === suggestion.targetItemId);

                    if (sourceItem && targetItem) {
                        // Initialize linkedItems array if it doesn't exist
                        if (!sourceItem.linkedItems) sourceItem.linkedItems = [];
                        if (!targetItem.linkedItems) targetItem.linkedItems = [];

                        // Add bidirectional link
                        sourceItem.linkedItems.push({
                            linkedItemId: suggestion.targetItemId,
                            linkedFeatureId: suggestion.targetFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'outgoing'
                        });

                        targetItem.linkedItems.push({
                            linkedItemId: suggestion.sourceItemId,
                            linkedFeatureId: suggestion.sourceFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'incoming'
                        });

                        // Save features
                        this.saveData();
                    }

                    // Remove from suggestions
                    this.linkSuggestions = this.linkSuggestions.filter(s => s.id !== id);
                    this.saveLinkSuggestions();
                    this.renderLinkSuggestions();
                    this.updateLinkNotification();
                    this.renderTable(); // Refresh table to show new links
                }
            },

            rejectLinkSuggestion(id) {
                // Store the ID and show rejection reason modal
                this.currentRejectionId = id;

                // Clear previous values
                document.getElementById('rejectionCategory').value = '';
                document.getElementById('rejectionNotes').value = '';

                // Show modal
                const overlay = document.getElementById('rejectionReasonOverlay');
                const modal = document.getElementById('rejectionReasonModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                overlay.classList.remove('hidden');
                modal.classList.remove('hidden');
                this._rejectionRelease = this.trapFocus(modal);
            },

            closeRejectionReason() {
                document.getElementById('rejectionReasonOverlay').classList.add('hidden');
                document.getElementById('rejectionReasonModal').classList.add('hidden');
                if (this._rejectionRelease) { this._rejectionRelease(); this._rejectionRelease = null; }
                this.currentRejectionId = null;
            },

            async confirmRejection() {
                const category = document.getElementById('rejectionCategory').value;
                const notes = document.getElementById('rejectionNotes').value.trim();

                if (!category) {
                    await this.showAlert({ title:'Missing reason', message:'Please select a rejection reason.' });
                    return;
                }

                const suggestion = this.linkSuggestions.find(s => s.id === this.currentRejectionId);
                if (suggestion) {
                    // Add to rejected links with enhanced data (store both directions)
                    this.rejectedLinks.push({
                        sourceItemId: suggestion.sourceItemId,
                        targetItemId: suggestion.targetItemId,
                        rejectionReason: category,
                        rejectionNotes: notes,
                        originalType: suggestion.type,
                        originalConfidence: suggestion.confidence,
                        timestamp: new Date().toISOString()
                    });
                    this.rejectedLinks.push({
                        sourceItemId: suggestion.targetItemId,
                        targetItemId: suggestion.sourceItemId,
                        rejectionReason: category,
                        rejectionNotes: notes,
                        originalType: suggestion.type,
                        originalConfidence: suggestion.confidence,
                        timestamp: new Date().toISOString()
                    });
                    this.saveRejectedLinks();

                    console.log(`üìù Rejection logged: ${category} - ${notes || 'No notes'}`);
                }

                // Remove from suggestions
                this.linkSuggestions = this.linkSuggestions.filter(s => s.id !== this.currentRejectionId);
                this.saveLinkSuggestions();
                this.renderLinkSuggestions();
                this.updateLinkNotification();

                // Close modal
                this.closeRejectionReason();
            },

            // AI Action Approval Functions
            showAIActionApproval(actionType, actionData, reason) {
                if (!this.aiEditingEnabled) {
                    console.log('AI editing is disabled');
                    return;
                }

                const totalActions = this.pendingAIActions.length;

                // Update title and summary
                const title = document.getElementById('aiActionTitle');
                const summary = document.getElementById('aiActionSummary');
                const queueContainer = document.getElementById('aiActionsQueue');

                title.textContent = totalActions === 1 ? 'AI Suggested Action' : 'AI Suggested Actions';
                summary.innerHTML = totalActions === 1
                    ? '1 action pending your approval'
                    : `${totalActions} actions pending your approval`;

                // Build queue of all actions
                queueContainer.innerHTML = '';
                this.pendingAIActions.forEach((action, index) => {
                    const actionItem = document.createElement('div');
                    actionItem.className = 'ai-action-queue-item';
                    actionItem.id = `action-item-${index}`;

                    const header = `
                        <div class="ai-action-header">
                            <span class="ai-action-type">${this.getActionTypeLabel(action.actionType)}</span>
                            <span class="ai-action-number">Action ${index + 1} of ${totalActions}</span>
                        </div>
                    `;

                    const reasonHtml = `<div class="ai-action-reason">"${action.reason}"</div>`;

                    const preview = `<div class="ai-action-preview">${this.buildActionPreview(action.actionType, action.actionData, action.reason)}</div>`;

                    const buttons = `
                        <div class="ai-action-buttons">
                            <button class="reject-btn" onclick="app.rejectSingleAction(${index})">‚úï Reject</button>
                            <button class="approve-btn" onclick="app.approveSingleAction(${index})">‚úì Approve</button>
                        </div>
                    `;

                    actionItem.innerHTML = header + reasonHtml + preview + buttons;
                    queueContainer.appendChild(actionItem);
                });

                // Show modal
                const overlay = document.getElementById('aiActionOverlay');
                const modal = document.getElementById('aiActionModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                overlay.classList.remove('hidden');
                modal.classList.remove('hidden');
                this._aiActionRelease = this.trapFocus(modal);
            },

            getActionTypeLabel(actionType) {
                const labels = {
                    'update_feature': 'Update Feature',
                    'update_timeline_item': 'Update Timeline Item',
                    'create_feature': 'Create New Feature',
                    'create_link_suggestion': 'Create Link',
                    'add_timeline_item': 'Add Timeline Item',
                    'delete_timeline_item': 'Delete Timeline Item'
                };
                return labels[actionType] || actionType;
            },

            buildActionPreview(actionType, actionData, reason) {
                let html = `<div style="margin-bottom: 10px;"><strong>Reason:</strong> ${reason}</div>`;
                
                switch (actionType) {
                    case 'update_feature':
                        const feature = this.features.find(f => f.id === actionData.featureId);
                        if (feature) {
                            html += '<div style="margin-top: 10px;"><strong>Changes:</strong></div>';
                            if (actionData.updates.name) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Name:</strong><br>
                                    <span style="color: var(--danger);">- ${feature.name}</span><br>
                                    <span style="color: var(--success);">+ ${actionData.updates.name}</span>
                                </div>`;
                            }
                            if (actionData.updates.type) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Type:</strong><br>
                                    <span style="color: var(--danger);">- ${feature.type}</span><br>
                                    <span style="color: var(--success);">+ ${actionData.updates.type}</span>
                                </div>`;
                            }
                            if (actionData.updates.purpose) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Purpose:</strong><br>
                                    <span style="color: var(--danger);">- ${feature.purpose}</span><br>
                                    <span style="color: var(--success);">+ ${actionData.updates.purpose}</span>
                                </div>`;
                            }
                        }
                        break;
                        
                    case 'update_timeline_item':
                        const featureForItem = this.features.find(f => f.id === actionData.featureId);
                        const item = featureForItem?.timelineItems.find(i => i.id === actionData.itemId);
                        if (item) {
                            html += `<div style="margin-top: 10px;"><strong>Feature:</strong> ${featureForItem.name}</div>`;
                            html += `<div><strong>Timeline Item:</strong> ${item.timeline} - ${item.difficulty}</div>`;
                            html += '<div style="margin-top: 10px;"><strong>Changes:</strong></div>';
                            if (actionData.updates.difficulty) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Difficulty:</strong> ${item.difficulty} ‚Üí ${actionData.updates.difficulty}
                                </div>`;
                            }
                            if (actionData.updates.category) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Categories:</strong> ${(item.category || []).join(', ') || 'None'} ‚Üí ${actionData.updates.category.join(', ')}
                                </div>`;
                            }
                            if (actionData.updates.integrationType) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>Integration:</strong> ${item.integrationType || 'None'} ‚Üí ${actionData.updates.integrationType}
                                </div>`;
                            }
                            if (actionData.updates.usp) {
                                html += `<div style="padding: 5px; background: rgba(255,255,255,0.1); margin: 5px 0; border-radius: 4px;">
                                    <strong>USP:</strong> ${item.usp || 'None'} ‚Üí ${actionData.updates.usp}
                                </div>`;
                            }
                        }
                        break;
                        
                    case 'create_feature':
                        html += `<div style="margin-top: 10px;"><strong>New Feature:</strong></div>`;
                        html += `<div style="padding: 8px; background: rgba(16, 185, 129, 0.1); margin: 5px 0; border-radius: 4px;">
                            <div><strong>Name:</strong> ${actionData.name}</div>
                            <div><strong>Type:</strong> ${actionData.type}</div>
                            <div><strong>Purpose:</strong> ${actionData.purpose}</div>
                            <div style="margin-top: 8px;"><strong>Timeline Items:</strong> ${actionData.timelineItems.length}</div>
                            ${actionData.timelineItems.map(ti => `
                                <div style="padding: 5px; margin: 3px 0; background: rgba(255,255,255,0.1); border-radius: 3px;">
                                    ${ti.timeline} - ${ti.difficulty} ${ti.category ? '(' + ti.category.join(', ') + ')' : ''}
                                </div>
                            `).join('')}
                        </div>`;
                        break;
                        
                    case 'create_link_suggestion':
                        const srcFeature = this.features.find(f => f.id === actionData.sourceFeatureId);
                        const tgtFeature = this.features.find(f => f.id === actionData.targetFeatureId);
                        const srcItem = srcFeature?.timelineItems.find(i => i.id === actionData.sourceItemId);
                        const tgtItem = tgtFeature?.timelineItems.find(i => i.id === actionData.targetItemId);
                        html += `<div style="margin-top: 10px;"><strong>Link:</strong></div>`;
                        html += `<div style="padding: 8px; background: rgba(59, 130, 246, 0.1); margin: 5px 0; border-radius: 4px;">
                            <div><strong>${srcFeature?.name}</strong> (${srcItem?.timeline})</div>
                            <div style="text-align: center; margin: 5px 0;">${actionData.relationshipType === 'dependency' ? '‚Üí depends on' : '‚Üî complements'}</div>
                            <div><strong>${tgtFeature?.name}</strong> (${tgtItem?.timeline})</div>
                        </div>`;
                        break;
                        
                    case 'add_timeline_item':
                        const featureForAdd = this.features.find(f => f.id === actionData.featureId);
                        html += `<div style="margin-top: 10px;"><strong>Add to Feature:</strong> ${featureForAdd?.name}</div>`;
                        html += `<div style="padding: 8px; background: rgba(16, 185, 129, 0.1); margin: 5px 0; border-radius: 4px;">
                            <div><strong>Timeline:</strong> ${actionData.timelineItem.timeline}</div>
                            <div><strong>Difficulty:</strong> ${actionData.timelineItem.difficulty}</div>
                            ${actionData.timelineItem.category ? `<div><strong>Categories:</strong> ${actionData.timelineItem.category.join(', ')}</div>` : ''}
                            ${actionData.timelineItem.integrationType ? `<div><strong>Integration:</strong> ${actionData.timelineItem.integrationType}</div>` : ''}
                            ${actionData.timelineItem.usp ? `<div><strong>USP:</strong> ${actionData.timelineItem.usp}</div>` : ''}
                        </div>`;
                        break;
                        
                    case 'delete_timeline_item':
                        const featureForDel = this.features.find(f => f.id === actionData.featureId);
                        const itemToDel = featureForDel?.timelineItems.find(i => i.id === actionData.itemId);
                        html += `<div style="margin-top: 10px;"><strong>Delete from Feature:</strong> ${featureForDel?.name}</div>`;
                        html += `<div style="padding: 8px; background: var(--danger-light); margin: 5px 0; border-radius: 4px; color: var(--danger-text);">
                            <div><strong>Timeline Item:</strong> ${itemToDel?.timeline} - ${itemToDel?.difficulty}</div>
                            <div style="margin-top: 5px; font-size: 12px;">‚ö†Ô∏è This action cannot be undone easily!</div>
                        </div>`;
                        break;
                }
                
                return html;
            },

            closeAIActionApproval(clearQueue = true) {
                document.getElementById('aiActionOverlay').classList.add('hidden');
                document.getElementById('aiActionModal').classList.add('hidden');
                if (this._aiActionRelease) { this._aiActionRelease(); this._aiActionRelease = null; }
                // Only clear queue when explicitly closing (not when auto-advancing to next action)
                if (clearQueue) {
                    this.pendingAIActions = [];
                }
            },

            async approveAIAction() {
                if (this.pendingAIActions.length === 0) return;
                
                const action = this.pendingAIActions[0];
                
                try {
                    let result = null;
                    
                    switch (action.actionType) {
                        case 'update_feature':
                            result = await this.executeUpdateFeature(action.actionData);
                            break;
                        case 'update_timeline_item':
                            result = await this.executeUpdateTimelineItem(action.actionData);
                            break;
                        case 'create_feature':
                            result = await this.executeCreateFeature(action.actionData);
                            break;
                        case 'create_feature_with_research':
                            result = await this.executeCreateFeatureWithResearch(action.actionData);
                            break;
                        case 'enhance_feature_with_research':
                            result = await this.executeEnhanceFeatureWithResearch(action.actionData);
                            break;
                        case 'create_link_suggestion':
                            result = await this.executeCreateLink(action.actionData);
                            break;
                        case 'add_timeline_item':
                            result = await this.executeAddTimelineItem(action.actionData);
                            break;
                        case 'delete_timeline_item':
                            result = await this.executeDeleteTimelineItem(action.actionData);
                            break;
                    }
                    
                    // Log the action
                    this.aiActionLog.push({
                        ...action,
                        approved: true,
                        result: result,
                        approvedAt: new Date().toISOString()
                    });
                    
                    this.saveAIActionLog();
                    this.updateActionLogCounter();
                    
                    // Remove the processed action from queue
                    this.pendingAIActions.shift();
                    
                    // Show toast for this action
                    this.showToast(`‚úì AI action approved: ${this.getActionTypeLabel(action.actionType)}`, 'success');
                    
                    // Add a message to chat
                    this.addChatMessage(`‚úÖ I've successfully ${this.getActionTypeLabel(action.actionType).toLowerCase()}. The changes are now live in your roadmap.`, 'ai');
                    
                    // Check if there are more actions to process
                    if (this.pendingAIActions.length > 0) {
                        // Show next action in queue
                        const nextAction = this.pendingAIActions[0];
                        this.showAIActionApproval(nextAction.actionType, nextAction.actionData, nextAction.reason);
                    } else {
                        // No more actions, close the modal
                        this.closeAIActionApproval(true);
                    }
                    
                } catch (error) {
                    console.error('Error executing AI action:', error);
                    this.showToast(`‚ùå Error: ${error.message}`, 'error');
                    // On error, still remove the action and show next or close
                    this.pendingAIActions.shift();
                    if (this.pendingAIActions.length > 0) {
                        const nextAction = this.pendingAIActions[0];
                        this.showAIActionApproval(nextAction.actionType, nextAction.actionData, nextAction.reason);
                    } else {
                        this.closeAIActionApproval(true);
                    }
                }
            },

            rejectAIAction() {
                if (this.pendingAIActions.length === 0) return;

                const action = this.pendingAIActions[0];

                // Log the rejection
                this.aiActionLog.push({
                    ...action,
                    approved: false,
                    rejectedAt: new Date().toISOString()
                });

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Remove the rejected action from queue
                this.pendingAIActions.shift();

                this.showToast('AI action rejected', 'info');

                // Add a message to chat
                this.addChatMessage('I understand. I won\'t make that change. Feel free to let me know if you\'d like me to suggest something different.', 'ai');

                // Check if there are more actions to process
                if (this.pendingAIActions.length > 0) {
                    // Show next action in queue
                    const nextAction = this.pendingAIActions[0];
                    this.showAIActionApproval(nextAction.actionType, nextAction.actionData, nextAction.reason);
                } else {
                    // No more actions, close the modal
                    this.closeAIActionApproval(true);
                }
            },

            // Approve a single action from the queue
            async approveSingleAction(index) {
                if (index < 0 || index >= this.pendingAIActions.length) return;

                const action = this.pendingAIActions[index];

                // Mark as processing
                const actionItem = document.getElementById(`action-item-${index}`);
                if (actionItem) {
                    actionItem.classList.add('approved');
                    const buttons = actionItem.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = true);
                }

                try {
                    let result = null;

                    switch (action.actionType) {
                        case 'update_feature':
                            result = await this.executeUpdateFeature(action.actionData);
                            break;
                        case 'update_timeline_item':
                            result = await this.executeUpdateTimelineItem(action.actionData);
                            break;
                        case 'create_feature':
                            result = await this.executeCreateFeature(action.actionData);
                            break;
                        case 'create_feature_with_research':
                            result = await this.executeCreateFeatureWithResearch(action.actionData);
                            break;
                        case 'enhance_feature_with_research':
                            result = await this.executeEnhanceFeatureWithResearch(action.actionData);
                            break;
                        case 'create_link_suggestion':
                            result = await this.executeCreateLink(action.actionData);
                            break;
                        case 'add_timeline_item':
                            result = await this.executeAddTimelineItem(action.actionData);
                            break;
                        case 'delete_timeline_item':
                            result = await this.executeDeleteTimelineItem(action.actionData);
                            break;
                    }

                    // Log the action
                    this.aiActionLog.push({
                        ...action,
                        approved: true,
                        result: result,
                        approvedAt: new Date().toISOString()
                    });

                    this.saveAIActionLog();
                    this.updateActionLogCounter();

                    // Remove from pending queue
                    this.pendingAIActions.splice(index, 1);

                    this.showToast(`‚úì ${this.getActionTypeLabel(action.actionType)} approved`, 'success');

                    // Refresh the queue display
                    if (this.pendingAIActions.length > 0) {
                        const firstAction = this.pendingAIActions[0];
                        this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                    } else {
                        this.closeAIActionApproval(true);
                        this.addChatMessage(`‚úÖ All actions completed successfully!`, 'ai');
                    }

                } catch (error) {
                    console.error('Error executing action:', error);
                    this.showToast(`‚ùå Error: ${error.message}`, 'error');

                    // Remove failed action
                    this.pendingAIActions.splice(index, 1);

                    // Refresh display
                    if (this.pendingAIActions.length > 0) {
                        const firstAction = this.pendingAIActions[0];
                        this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                    } else {
                        this.closeAIActionApproval(true);
                    }
                }
            },

            // Reject a single action from the queue
            rejectSingleAction(index) {
                if (index < 0 || index >= this.pendingAIActions.length) return;

                const action = this.pendingAIActions[index];

                // Mark as rejected
                const actionItem = document.getElementById(`action-item-${index}`);
                if (actionItem) {
                    actionItem.classList.add('rejected');
                    const buttons = actionItem.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = true);
                }

                // Log the rejection
                this.aiActionLog.push({
                    ...action,
                    approved: false,
                    rejectedAt: new Date().toISOString()
                });

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Remove from pending queue
                this.pendingAIActions.splice(index, 1);

                this.showToast('Action rejected', 'info');

                // Refresh the queue display
                if (this.pendingAIActions.length > 0) {
                    const firstAction = this.pendingAIActions[0];
                    this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                } else {
                    this.closeAIActionApproval(true);
                    this.addChatMessage('I understand. I won\'t make those changes.', 'ai');
                }
            },

            // Approve all pending actions
            async approveAllAIActions() {
                if (this.pendingAIActions.length === 0) return;

                const totalActions = this.pendingAIActions.length;
                this.showToast(`Approving ${totalActions} actions...`, 'info');

                let successCount = 0;
                let errorCount = 0;

                // Process all actions
                while (this.pendingAIActions.length > 0) {
                    const action = this.pendingAIActions[0];

                    try {
                        let result = null;

                        switch (action.actionType) {
                            case 'update_feature':
                                result = await this.executeUpdateFeature(action.actionData);
                                break;
                            case 'update_timeline_item':
                                result = await this.executeUpdateTimelineItem(action.actionData);
                                break;
                            case 'create_feature':
                                result = await this.executeCreateFeature(action.actionData);
                                break;
                            case 'create_feature_with_research':
                                result = await this.executeCreateFeatureWithResearch(action.actionData);
                                break;
                            case 'enhance_feature_with_research':
                                result = await this.executeEnhanceFeatureWithResearch(action.actionData);
                                break;
                            case 'create_link_suggestion':
                                result = await this.executeCreateLink(action.actionData);
                                break;
                            case 'add_timeline_item':
                                result = await this.executeAddTimelineItem(action.actionData);
                                break;
                            case 'delete_timeline_item':
                                result = await this.executeDeleteTimelineItem(action.actionData);
                                break;
                        }

                        // Log the action
                        this.aiActionLog.push({
                            ...action,
                            approved: true,
                            result: result,
                            approvedAt: new Date().toISOString()
                        });

                        successCount++;

                    } catch (error) {
                        console.error('Error executing action:', error);
                        errorCount++;

                        // Log the failed action
                        this.aiActionLog.push({
                            ...action,
                            approved: false,
                            error: error.message,
                            failedAt: new Date().toISOString()
                        });
                    }

                    // Remove from queue
                    this.pendingAIActions.shift();
                }

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Close modal and show results
                this.closeAIActionApproval(true);

                if (errorCount === 0) {
                    this.showToast(`‚úì All ${successCount} actions approved successfully!`, 'success');
                    this.addChatMessage(`‚úÖ I've successfully completed all ${successCount} actions! Your roadmap has been updated.`, 'ai');
                } else {
                    this.showToast(`‚úì ${successCount} succeeded, ${errorCount} failed`, 'warning');
                    this.addChatMessage(`I've completed ${successCount} actions successfully, but ${errorCount} failed. Please check the action log for details.`, 'ai');
                }
            },

            // Reject all pending actions
            rejectAllAIActions() {
                if (this.pendingAIActions.length === 0) return;

                const totalActions = this.pendingAIActions.length;

                // Log all rejections
                this.pendingAIActions.forEach(action => {
                    this.aiActionLog.push({
                        ...action,
                        approved: false,
                        rejectedAt: new Date().toISOString()
                    });
                });

                this.saveAIActionLog();
                this.updateActionLogCounter();

                // Clear the queue
                this.pendingAIActions = [];

                // Close modal
                this.closeAIActionApproval(true);

                this.showToast(`Rejected ${totalActions} actions`, 'info');
                this.addChatMessage(`I understand. I won't make any of those ${totalActions} changes. Let me know if you'd like me to suggest something different.`, 'ai');
            },

            // AI Tool Executor Functions
            async executeUpdateFeature(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                if (actionData.updates.name) feature.name = actionData.updates.name;
                if (actionData.updates.type) feature.type = actionData.updates.type;
                if (actionData.updates.purpose) feature.purpose = actionData.updates.purpose;
                
                feature.updatedAt = new Date().toISOString();
                feature.aiModified = true;
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id };
            },

            async executeUpdateTimelineItem(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                const item = feature.timelineItems.find(i => i.id === actionData.itemId);
                if (!item) throw new Error('Timeline item not found');
                
                if (actionData.updates.difficulty) item.difficulty = actionData.updates.difficulty;
                if (actionData.updates.category) item.category = actionData.updates.category;
                if (actionData.updates.integrationType) item.integrationType = actionData.updates.integrationType;
                if (actionData.updates.usp) item.usp = actionData.updates.usp;
                
                item.aiModified = true;
                feature.updatedAt = new Date().toISOString();
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id, itemId: item.id };
            },

            async executeCreateFeature(actionData) {
                // Generate summaries for timeline items
                const summaries = await this.summarizeTimelineItems(actionData.timelineItems);
                
                const newFeature = {
                    id: Date.now().toString(),
                    name: actionData.name,
                    type: actionData.type,
                    purpose: actionData.purpose,
                    workspaceId: this.currentWorkspaceId,
                    timelineItems: actionData.timelineItems.map((item, index) => ({
                        id: Date.now().toString() + '_' + index,
                        timeline: item.timeline,
                        difficulty: item.difficulty,
                        category: item.category || [],
                        integrationType: item.integrationType || '',
                        usp: item.usp || '',
                        linkedItems: []
                    })),
                    summary: summaries,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    aiCreated: true
                };
                
                this.features.push(newFeature);
                
                // Add categories to allTags
                newFeature.timelineItems.forEach(item => {
                    item.category.forEach(c => this.allTags.add(c));
                });
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: newFeature.id };
            },

            async executeCreateLink(actionData) {
                const sourceFeature = this.features.find(f => f.id === actionData.sourceFeatureId);
                const targetFeature = this.features.find(f => f.id === actionData.targetFeatureId);
                
                if (!sourceFeature || !targetFeature) throw new Error('Feature not found');
                
                const sourceItem = sourceFeature.timelineItems.find(i => i.id === actionData.sourceItemId);
                const targetItem = targetFeature.timelineItems.find(i => i.id === actionData.targetItemId);
                
                if (!sourceItem || !targetItem) throw new Error('Timeline item not found');
                
                // Check if link already exists
                const linkExists = sourceItem.linkedItems?.some(l => 
                    l.linkedItemId === actionData.targetItemId && l.linkedFeatureId === actionData.targetFeatureId
                );
                
                if (linkExists) throw new Error('Link already exists');
                
                // Initialize linkedItems if needed
                if (!sourceItem.linkedItems) sourceItem.linkedItems = [];
                if (!targetItem.linkedItems) targetItem.linkedItems = [];
                
                // Add bidirectional link
                sourceItem.linkedItems.push({
                    linkedItemId: actionData.targetItemId,
                    linkedFeatureId: actionData.targetFeatureId,
                    relationshipType: actionData.relationshipType,
                    reason: actionData.reason,
                    direction: 'outgoing',
                    aiCreated: true
                });
                
                targetItem.linkedItems.push({
                    linkedItemId: actionData.sourceItemId,
                    linkedFeatureId: actionData.sourceFeatureId,
                    relationshipType: actionData.relationshipType,
                    reason: actionData.reason,
                    direction: 'incoming',
                    aiCreated: true
                });
                
                this.saveData();
                this.renderTable();
                
                return { success: true, sourceItemId: sourceItem.id, targetItemId: targetItem.id };
            },

            async executeAddTimelineItem(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                const newItem = {
                    id: Date.now().toString(),
                    timeline: actionData.timelineItem.timeline,
                    difficulty: actionData.timelineItem.difficulty,
                    category: actionData.timelineItem.category || [],
                    integrationType: actionData.timelineItem.integrationType || '',
                    usp: actionData.timelineItem.usp || '',
                    linkedItems: [],
                    aiCreated: true
                };
                
                feature.timelineItems.push(newItem);
                
                // Add categories to allTags
                newItem.category.forEach(c => this.allTags.add(c));
                
                // Regenerate summaries
                feature.summary = await this.summarizeTimelineItems(feature.timelineItems);
                feature.updatedAt = new Date().toISOString();
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id, itemId: newItem.id };
            },

            async executeDeleteTimelineItem(actionData) {
                const feature = this.features.find(f => f.id === actionData.featureId);
                if (!feature) throw new Error('Feature not found');
                
                const itemIndex = feature.timelineItems.findIndex(i => i.id === actionData.itemId);
                if (itemIndex === -1) throw new Error('Timeline item not found');
                
                // Remove the item
                feature.timelineItems.splice(itemIndex, 1);
                
                // Regenerate summaries
                if (feature.timelineItems.length > 0) {
                    feature.summary = await this.summarizeTimelineItems(feature.timelineItems);
                }
                feature.updatedAt = new Date().toISOString();
                
                this.saveData();
                this.renderTable();
                
                return { success: true, featureId: feature.id, deletedItemId: actionData.itemId };
            },

            async executeSearchInternet(actionData) {
                return await chatPanel.executeSearchInternet(actionData, this);
            },

            // [Extracted method - now delegating to chatPanel]
            async _oldExecuteSearchInternet(actionData) {
                if (!this.tavilyApiKey) {
                    throw new Error('Tavily API key not configured. Please add your Tavily API key in settings.');
                }

                if (!this.apiKey) {
                    throw new Error('OpenRouter API key required for synthesizing search results.');
                }

                try {
                    // Step 1: Execute search
                    const response = await fetch('https://api.tavily.com/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: this.tavilyApiKey,
                            query: actionData.query,
                            search_depth: 'advanced',
                            max_results: 10,
                            include_answer: true,
                            include_raw_content: true
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Tavily API error: ${response.statusText}`);
                    }

                    const searchData = await response.json();
                    
                    if (!searchData.results || searchData.results.length === 0) {
                        this.addChatMessage('üîç No search results found for your query.', 'ai');
                        return { 
                            success: true, 
                            query: actionData.query,
                            resultsCount: 0
                        };
                    }

                    // Step 2: Synthesize answer using AI
                    // Add feature context if in enhancement mode
                    let contextualInfo = '';
                    if (this.aiFeatureEnhancementMode && this.currentFeatureId) {
                        const feature = this.features.find(f => f.id === this.currentFeatureId);
                        if (feature) {
                            contextualInfo = `\n\nIMPORTANT CONTEXT - Answer specifically in relation to this feature:
Feature Name: ${feature.name}
Feature Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}
Current Status: ${feature.executionSteps ? 'Has execution steps' : 'Needs execution steps'}, ${feature.resources ? 'Has resources' : 'Needs resources'}, ${feature.planning ? 'Has planning' : 'Needs planning'}

Your answer should be tailored to help enhance THIS specific feature with relevant, actionable information.\n`;
                        }
                    }

                    const synthesisPrompt = `Based on the following search results, provide a comprehensive and well-structured answer to the user's question: "${actionData.query}"${contextualInfo}

Search Results:
${searchData.results.map((result, index) => `
[${index + 1}] ${result.title}
URL: ${result.url}
Content: ${result.content || 'No content available'}
`).join('\n\n')}

Please synthesize this information into a clear, informative answer that directly addresses the user's question. Be thorough but concise.`;

                    const synthesisResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { 
                                    role: 'system', 
                                    content: 'You are a helpful assistant that synthesizes search results into clear, comprehensive answers. Focus on providing accurate, well-structured information based on the search results provided.' 
                                },
                                { role: 'user', content: synthesisPrompt }
                            ],
                            temperature: 0.7
                        })
                    });

                    if (!synthesisResponse.ok) {
                        throw new Error(`Failed to synthesize answer: ${synthesisResponse.statusText}`);
                    }

                    const synthesisData = await synthesisResponse.json();
                    const synthesizedAnswer = synthesisData.choices[0].message.content;

                    // Step 3: Format and display with collapsible sources
                    const sourcesCount = searchData.results.length;
                    
                    // Escape HTML in source data
                    const escapeHtml = (text) => {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };
                    
                    const sourcesHtml = searchData.results.map((result, index) => {
                        const title = escapeHtml(result.title || 'Untitled');
                        const url = escapeHtml(result.url);
                        // URL for href should be properly encoded
                        const urlHref = result.url.replace(/"/g, '&quot;');
                        return `
                            <div class="source-item">
                                <div class="source-title">${title}</div>
                                <a href="${urlHref}" target="_blank" rel="noopener noreferrer" class="source-url">${url}</a>
                            </div>
                        `;
                    }).join('');

                    const formattedAnswer = this.formatMessage(synthesizedAnswer);
                    const searchResultsHtml = `
                        <div class="search-synthesis">
                            <div class="ai-answer">${formattedAnswer}</div>
                            <div class="search-sources">
                                <button class="sources-toggle" onclick="app.toggleSources(this)">
                                    View ${sourcesCount} source${sourcesCount !== 1 ? 's' : ''}
                                </button>
                                <div class="sources-list">
                                    ${sourcesHtml}
                                </div>
                            </div>
                        </div>
                    `;

                    // Add to chat with HTML (we control the HTML structure, so safe to set directly)
                    const messagesContainer = document.getElementById('chatMessages');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'chat-message ai';
                    // Set innerHTML directly since we're generating safe HTML ourselves
                    messageDiv.innerHTML = searchResultsHtml;
                    messagesContainer.appendChild(messageDiv);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    return { 
                        success: true, 
                        query: actionData.query,
                        resultsCount: sourcesCount,
                        synthesizedAnswer: synthesizedAnswer
                    };
                } catch (error) {
                    console.error('Search error:', error);
                    throw error;
                }
            },

            // Silent version of search for batching multiple searches
            async executeSearchInternetSilent(actionData) {
                return await chatPanel.executeSearchInternetSilent(actionData, this);
            },

            // [Extracted method - now delegating to chatPanel]
            async _oldExecuteSearchInternetSilent(actionData) {
                if (!this.tavilyApiKey) {
                    throw new Error('Tavily API key not configured.');
                }

                if (!this.apiKey) {
                    throw new Error('OpenRouter API key required for synthesizing search results.');
                }

                try {
                    // Step 1: Execute search
                    const response = await fetch('https://api.tavily.com/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: this.tavilyApiKey,
                            query: actionData.query,
                            search_depth: 'advanced',
                            max_results: 10,
                            include_answer: true,
                            include_raw_content: true
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Tavily API error: ${response.statusText}`);
                    }

                    const searchData = await response.json();

                    if (!searchData.results || searchData.results.length === 0) {
                        return {
                            success: true,
                            query: actionData.query,
                            resultsCount: 0,
                            results: [],
                            synthesizedAnswer: 'No search results found for your query.'
                        };
                    }

                    // Step 2: Synthesize answer using AI
                    // Add feature context if in enhancement mode
                    let contextualInfo = '';
                    if (this.aiFeatureEnhancementMode && this.currentFeatureId) {
                        const feature = this.features.find(f => f.id === this.currentFeatureId);
                        if (feature) {
                            contextualInfo = `\n\nIMPORTANT CONTEXT - Answer specifically in relation to this feature:
Feature Name: ${feature.name}
Feature Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}
Current Status: ${feature.executionSteps ? 'Has execution steps' : 'Needs execution steps'}, ${feature.resources ? 'Has resources' : 'Needs resources'}, ${feature.planning ? 'Has planning' : 'Needs planning'}

Your answer should be tailored to help enhance THIS specific feature with relevant, actionable information.\n`;
                        }
                    }

                    const synthesisPrompt = `Based on the following search results, provide a comprehensive and well-structured answer to the user's question: "${actionData.query}"${contextualInfo}

Search Results:
${searchData.results.map((result, index) => `
[${index + 1}] ${result.title}
URL: ${result.url}
Content: ${result.content || 'No content available'}
`).join('\n\n')}

Please synthesize this information into a clear, informative answer that directly addresses the user's question. Be thorough but concise.`;

                    const synthesisResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are a helpful assistant that synthesizes search results into clear, comprehensive answers. Focus on providing accurate, well-structured information based on the search results provided.'
                                },
                                { role: 'user', content: synthesisPrompt }
                            ],
                            temperature: 0.7
                        })
                    });

                    if (!synthesisResponse.ok) {
                        throw new Error(`Failed to synthesize answer: ${synthesisResponse.statusText}`);
                    }

                    const synthesisData = await synthesisResponse.json();
                    const synthesizedAnswer = synthesisData.choices[0].message.content;

                    // Return data without displaying
                    return {
                        success: true,
                        query: actionData.query,
                        resultsCount: searchData.results.length,
                        results: searchData.results,
                        synthesizedAnswer: synthesizedAnswer
                    };
                } catch (error) {
                    console.error('Silent search error:', error);
                    return {
                        success: false,
                        query: actionData.query,
                        error: error.message,
                        resultsCount: 0,
                        results: [],
                        synthesizedAnswer: `Error: ${error.message}`
                    };
                }
            },

            // Display multiple search results in one combined message
            displayBatchedSearchResults(searchResults) {
                chatPanel.displayBatchedSearchResults(searchResults, this);
            },

            // [Extracted method - now delegating to chatPanel]
            _oldDisplayBatchedSearchResults(searchResults) {
                if (!searchResults || searchResults.length === 0) {
                    return;
                }

                const messagesContainer = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message ai';

                // Escape HTML helper
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };

                // Build combined display
                let combinedHtml = '<div class="batched-search-results">';

                // Header showing number of searches
                const successfulSearches = searchResults.filter(r => r.success && r.resultsCount > 0);
                if (successfulSearches.length > 1) {
                    combinedHtml += `<div class="batch-search-header">üîç Searched ${successfulSearches.length} queries and found ${successfulSearches.reduce((sum, r) => sum + r.resultsCount, 0)} total results</div>`;
                }

                // Display each search result
                successfulSearches.forEach((result, index) => {
                    const queryLabel = successfulSearches.length > 1 ? `<div class="search-query-label">Query ${index + 1}: "${escapeHtml(result.query)}"</div>` : '';

                    // Format the synthesized answer
                    const formattedAnswer = this.formatMessage(result.synthesizedAnswer);

                    // Build sources HTML
                    const sourcesHtml = result.results.map((source, idx) => {
                        const title = escapeHtml(source.title || 'Untitled');
                        const url = escapeHtml(source.url);
                        const urlHref = source.url.replace(/"/g, '&quot;');
                        return `
                            <div class="source-item">
                                <div class="source-title">${title}</div>
                                <a href="${urlHref}" target="_blank" rel="noopener noreferrer" class="source-url">${url}</a>
                            </div>
                        `;
                    }).join('');

                    combinedHtml += `
                        <div class="search-result-section">
                            ${queryLabel}
                            <div class="search-synthesis">
                                <div class="ai-answer">${formattedAnswer}</div>
                                <div class="search-sources">
                                    <button class="sources-toggle" onclick="app.toggleSources(this)">
                                        View ${result.resultsCount} source${result.resultsCount !== 1 ? 's' : ''}
                                    </button>
                                    <div class="sources-list">
                                        ${sourcesHtml}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                // Show errors if any
                const failedSearches = searchResults.filter(r => !r.success || r.resultsCount === 0);
                if (failedSearches.length > 0) {
                    combinedHtml += '<div class="failed-searches">';
                    failedSearches.forEach(result => {
                        combinedHtml += `<div class="search-error">‚ö†Ô∏è No results for: "${escapeHtml(result.query)}"</div>`;
                    });
                    combinedHtml += '</div>';
                }

                combinedHtml += '</div>';

                messageDiv.innerHTML = combinedHtml;
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            },

            addChatMessage(text, sender, id = null) {
                chatPanel.addChatMessage(text, sender, id, this);
            },

            toggleMessageExpand(messageDiv, button) {
                chatPanel.toggleMessageExpand(messageDiv, button);
            },

            toggleSources(button) {
                chatPanel.toggleSources(button);
            },

            showToast(message, type = 'info') {
                // Create a simple toast notification
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 6px;
                    color: white;
                    font-size: 14px;
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                    max-width: 400px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                `;
                
                const colors = {
                    success: '#10b981',
                    error: '#ef4444',
                    info: '#3b82f6',
                    warning: '#f59e0b'
                };
                
                toast.style.background = colors[type] || colors.info;
                toast.textContent = message;
                
                document.body.appendChild(toast);
                // Announce via live region
                const sr = document.getElementById('srLive');
                if (sr) sr.textContent = message;
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            },

            saveAIActionLog() {
                try {
                    localStorage.setItem('aiActionLog', JSON.stringify(this.aiActionLog));
                } catch (error) {
                    console.error('Error saving AI action log:', error);
                }
            },

            loadAIActionLog() {
                try {
                    const stored = localStorage.getItem('aiActionLog');
                    if (stored) {
                        this.aiActionLog = JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Error loading AI action log:', error);
                    this.aiActionLog = [];
                }
            },

            // Action log UI helpers
            toggleAIActionPanel() {
                const panel = document.getElementById('actionLogPanel');
                if (!panel) return;
                const isHidden = panel.classList.contains('hidden');
                if (isHidden) this.renderActionLogList();
                panel.classList.toggle('hidden');
            },

            renderActionLogList() {
                const list = document.getElementById('actionLogList');
                if (!list) return;
                if (!this.aiActionLog || this.aiActionLog.length === 0) {
                    list.innerHTML = '<div style="color:var(--text-muted); font-size:12px;">No AI actions yet.</div>';
                } else {
                    list.innerHTML = this.aiActionLog.slice().reverse().map((entry, idx) => {
                        const approvedLabel = entry.approved ? '<span style="color:var(--success); font-weight:600;">Approved</span>' : '<span style="color:var(--danger); font-weight:600;">Rejected</span>';
                        const when = new Date(entry.approvedAt || entry.rejectedAt || entry.timestamp).toLocaleString();
                        return `
                        <div style="background:var(--surface-alt); padding:10px; border-radius:6px; margin-bottom:8px; font-size:12px;">
                            <div style="display:flex; justify-content:space-between; align-items:start; gap:8px;">
                                <div style="flex:1; color:var(--text-secondary);">
                                    <div style="font-weight:600;">${this.getActionTypeLabel(entry.actionType)}</div>
                                    <div style="margin-top:4px; color:var(--text-muted);">Reason: ${entry.reason || '‚Äî'}</div>
                                </div>
                                <div>${approvedLabel}</div>
                            </div>
                            <div style="color:var(--text-muted); font-size:10px; margin-top:6px;">${when}</div>
                        </div>`;
                    }).join('');
                }
                const total = document.getElementById('aiActionTotal');
                if (total) total.textContent = String(this.aiActionLog.length);
            },

            updateActionLogCounter() {
                const badge = document.getElementById('aiActionCount');
                if (badge) badge.textContent = String(this.aiActionLog?.length || 0);
            },

            async clearAIActionLog() {
                const ok = await this.showConfirm({ title: 'Clear AI action logs?', message: 'This will remove all entries from the action log.', confirmText: 'Clear', cancelText: 'Cancel', variant: 'danger' });
                if (!ok) return;
                this.aiActionLog = [];
                this.saveAIActionLog();
                this.renderActionLogList();
                this.updateActionLogCounter();
            },

            exportAIActionLog() {
                const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(this.aiActionLog, null, 2));
                const a = document.createElement('a');
                a.setAttribute('href', dataStr);
                a.setAttribute('download', 'ai_action_log.json');
                document.body.appendChild(a);
                a.click();
                a.remove();
            },

            // AI Learning Functions
            analyzeLearningPatterns() {
                const patterns = {
                    approvalCount: 0,
                    rejectionCount: this.rejectedLinks.length / 2, // Divide by 2 because we store bidirectional
                    commonApprovedCategories: new Map(),
                    commonRejectionReasons: new Map(),
                    commonApprovedTypes: { dependency: 0, complements: 0 },
                    commonTimelinePairs: new Map()
                };

                // Analyze approved links
                this.features.forEach(feature => {
                    (feature.timelineItems || []).forEach(item => {
                        if (item.linkedItems && item.linkedItems.length > 0) {
                            item.linkedItems.forEach(link => {
                                if (link.direction === 'outgoing') { // Count only outgoing to avoid double-counting
                                    patterns.approvalCount++;

                                    // Track relationship types
                                    if (link.relationshipType === 'dependency') {
                                        patterns.commonApprovedTypes.dependency++;
                                    } else {
                                        patterns.commonApprovedTypes.complements++;
                                    }

                                    // Track timeline pairs (e.g., MVP‚ÜíSHORT)
                                    const targetFeature = this.features.find(f => f.id === link.linkedFeatureId);
                                    const targetItem = targetFeature?.timelineItems.find(i => i.id === link.linkedItemId);
                                    if (targetItem) {
                                        const pairKey = `${item.timeline}‚Üí${targetItem.timeline}`;
                                        patterns.commonTimelinePairs.set(pairKey, (patterns.commonTimelinePairs.get(pairKey) || 0) + 1);
                                    }

                                    // Track categories
                                    (item.category || []).forEach(cat => {
                                        patterns.commonApprovedCategories.set(cat, (patterns.commonApprovedCategories.get(cat) || 0) + 1);
                                    });
                                }
                            });
                        }
                    });
                });

                // Analyze rejection reasons
                this.rejectedLinks.forEach(rejection => {
                    if (rejection.rejectionReason) {
                        patterns.commonRejectionReasons.set(
                            rejection.rejectionReason,
                            (patterns.commonRejectionReasons.get(rejection.rejectionReason) || 0) + 1
                        );
                    }
                });

                return patterns;
            },

            buildLearningContext() {
                const patterns = this.analyzeLearningPatterns();

                if (patterns.approvalCount === 0 && patterns.rejectionCount === 0) {
                    return ''; // No learning data yet
                }

                let context = '\n\n## LEARNING FROM PAST DECISIONS\n\n';

                context += `You have learned from ${patterns.approvalCount} approved and ${patterns.rejectionCount} rejected link suggestions.\n\n`;

                // Approved patterns
                if (patterns.approvalCount > 0) {
                    context += '**Approved Patterns (prioritize similar):**\n';

                    // Most common relationship type
                    const preferredType = patterns.commonApprovedTypes.dependency > patterns.commonApprovedTypes.complements
                        ? `dependency links (${patterns.commonApprovedTypes.dependency} approved)`
                        : `complements links (${patterns.commonApprovedTypes.complements} approved)`;
                    context += `- User prefers ${preferredType}\n`;

                    // Most common timeline pairs
                    if (patterns.commonTimelinePairs.size > 0) {
                        const topPairs = Array.from(patterns.commonTimelinePairs.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3);
                        context += '- Common timeline connections:\n';
                        topPairs.forEach(([pair, count]) => {
                            context += `  ‚Ä¢ ${pair} (${count} links)\n`;
                        });
                    }

                    // Most common categories
                    if (patterns.commonApprovedCategories.size > 0) {
                        const topCategories = Array.from(patterns.commonApprovedCategories.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5);
                        context += '- Frequently linked categories: ' + topCategories.map(([cat]) => cat).join(', ') + '\n';
                    }

                    context += '\n';
                }

                // Rejection patterns
                if (patterns.rejectionCount > 0 && patterns.commonRejectionReasons.size > 0) {
                    context += '**Rejection Patterns (avoid similar):**\n';
                    const topReasons = Array.from(patterns.commonRejectionReasons.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);

                    topReasons.forEach(([reason, count]) => {
                        const reasonLabel = {
                            'not-related': 'Items not related to each other',
                            'wrong-type': 'Wrong relationship type selected',
                            'timeline-mismatch': 'Timeline phases don\'t align',
                            'already-covered': 'Link already covered elsewhere',
                            'other': 'Other miscellaneous reasons'
                        }[reason] || reason;
                        context += `- ${reasonLabel} (${count} rejections)\n`;
                    });
                }

                return context;
            },

            async approveAllLinkSuggestions() {
                let skippedCount = 0;

                this.linkSuggestions.forEach(suggestion => {
                    // Skip same-feature links
                    if (suggestion.sourceFeatureId === suggestion.targetFeatureId) {
                        console.warn(`Skipping same-feature link during bulk approve`);
                        skippedCount++;
                        return;
                    }

                    const sourceFeature = this.features.find(f => f.id === suggestion.sourceFeatureId);
                    const targetFeature = this.features.find(f => f.id === suggestion.targetFeatureId);
                    const sourceItem = sourceFeature?.timelineItems.find(i => i.id === suggestion.sourceItemId);
                    const targetItem = targetFeature?.timelineItems.find(i => i.id === suggestion.targetItemId);

                    if (sourceItem && targetItem) {
                        if (!sourceItem.linkedItems) sourceItem.linkedItems = [];
                        if (!targetItem.linkedItems) targetItem.linkedItems = [];

                        sourceItem.linkedItems.push({
                            linkedItemId: suggestion.targetItemId,
                            linkedFeatureId: suggestion.targetFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'outgoing'
                        });

                        targetItem.linkedItems.push({
                            linkedItemId: suggestion.sourceItemId,
                            linkedFeatureId: suggestion.sourceFeatureId,
                            relationshipType: suggestion.type,
                            reason: suggestion.reason,
                            direction: 'incoming'
                        });
                    }
                });

                this.saveData();
                this.linkSuggestions = [];
                this.saveLinkSuggestions();
                this.renderLinkSuggestions();
                this.updateLinkNotification();
                this.renderTable();

                if (skippedCount > 0) {
                    await this.showAlert({ title:'Links approved', message:`Skipped ${skippedCount} invalid same-feature link(s).` , variant:'warning'});
                } else {
                    this.showToast('Links approved', 'success');
                }
            },

            async rejectAllLinkSuggestions() {
                const ok = await this.showConfirm({ title:'Reject all link suggestions?', message:'This cannot be undone.', confirmText:'Reject all', cancelText:'Cancel', variant:'danger' });
                if (ok) {
                    // Add all suggestions to rejected links before clearing
                    this.linkSuggestions.forEach(suggestion => {
                        this.rejectedLinks.push({
                            sourceItemId: suggestion.sourceItemId,
                            targetItemId: suggestion.targetItemId,
                            rejectionReason: 'bulk-reject',
                            rejectionNotes: 'Rejected via bulk action',
                            originalType: suggestion.type,
                            originalConfidence: suggestion.confidence,
                            timestamp: new Date().toISOString()
                        });
                        this.rejectedLinks.push({
                            sourceItemId: suggestion.targetItemId,
                            targetItemId: suggestion.sourceItemId,
                            rejectionReason: 'bulk-reject',
                            rejectionNotes: 'Rejected via bulk action',
                            originalType: suggestion.type,
                            originalConfidence: suggestion.confidence,
                            timestamp: new Date().toISOString()
                        });
                    });
                    this.saveRejectedLinks();

                    this.linkSuggestions = [];
                    this.saveLinkSuggestions();
                    this.renderLinkSuggestions();
                    this.updateLinkNotification();
                }
            },

            renderMemorySuggestions() {
                const container = document.getElementById('memorySuggestionsList');
                if (!container) return;

                if (this.memorySuggestions.length === 0) {
                    container.innerHTML = '<div style="color:rgba(255,255,255,0.8); font-size:12px; padding:10px; text-align:center;">No suggestions</div>';
                    return;
                }

                let html = `
                    <div style="padding:12px; background:rgba(255,255,255,0.1); border-radius:6px; margin-bottom:12px; font-size:11px; color:rgba(255,255,255,0.9); line-height:1.5;">
                        <strong>üí° How Memory Suggestions Work:</strong><br>
                        ‚Ä¢ Generated automatically every 5 messages<br>
                        ‚Ä¢ AI analyzes your conversation for valuable knowledge points<br>
                        ‚Ä¢ When you approve, items are added to permanent memory<br>
                        ‚Ä¢ Memory is included in every AI conversation to provide context<br>
                        ‚Ä¢ Memory persists across conversations (even after starting new chats)
                    </div>
                `;

                this.memorySuggestions.forEach(suggestion => {
                    html += `
                        <div class="memory-suggestion-item">
                            <div class="memory-suggestion-content">${suggestion.content}</div>
                            <div class="memory-suggestion-actions">
                                <button class="memory-suggestion-btn approve" onclick="app.approveSuggestion('${suggestion.id}')" title="Approve">‚úì</button>
                                <button class="memory-suggestion-btn reject" onclick="app.rejectSuggestion('${suggestion.id}')" title="Reject">‚úó</button>
                            </div>
                        </div>
                    `;
                });

                html += `
                    <div class="memory-notification-bulk-actions">
                        <button onclick="app.approveAllSuggestions()">‚úì Approve All</button>
                        <button onclick="app.rejectAllSuggestions()">‚úó Reject All</button>
                    </div>
                `;

                container.innerHTML = html;
            },

            updateSuggestionNotification() {
                const notification = document.getElementById('memoryNotification');
                const count = document.getElementById('suggestionCount');

                if (count) {
                    count.textContent = this.memorySuggestions.length;
                }

                if (notification) {
                    if (this.memorySuggestions.length > 0) {
                        notification.classList.remove('hidden');
                    } else {
                        notification.classList.add('hidden');
                        document.getElementById('memorySuggestionsList')?.classList.remove('active');
                    }
                }
            },

            showMemoryAnalysisToast(message, duration = 3000) {
                // Remove any existing toast
                const existingToast = document.querySelector('.memory-analysis-toast');
                if (existingToast) {
                    existingToast.classList.add('fade-out');
                    setTimeout(() => existingToast.remove(), 300);
                }

                // Create new toast
                const toast = document.createElement('div');
                toast.className = 'memory-analysis-toast';
                toast.innerHTML = `<span>${message}</span>`;
                document.body.appendChild(toast);

                // Remove after duration
                setTimeout(() => {
                    toast.classList.add('fade-out');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            },

            async analyzeConversationForMemory() {
                if (!this.apiKey || this.conversationHistory.length < 5) return;

                // Show toast when analysis starts
                this.showMemoryAnalysisToast('üîç Analyzing conversation for memory suggestions...', 2000);

                try {
                    // Get last 5 messages for analysis
                    const recentMessages = this.conversationHistory.slice(-5);

                    const analysisPrompt = `Analyze this conversation and identify 2-3 valuable knowledge points that should be remembered for future conversations.

CONTEXT: The user is building a comprehensive trade platform that integrates sourcing, payments, research, customs, chat, logistics, and last mile delivery into a single unified platform.

Focus on:
- Platform vision details and scope
- User preferences and requirements
- Project-specific details (integrations, features, tech stack)
- Architectural or design decisions
- Important constraints or requirements
- Specific use cases or workflows
- Competitive insights and market positioning
- Feature priorities and roadmap decisions

Return ONLY a numbered list of knowledge points, one per line. Each point should be concise (1 sentence max).
Example format:
1. User prefers microservices architecture for scalability
2. Project uses Stripe for payment processing
3. Authentication requires OAuth2 with Google provider
4. Platform focuses on SME market segment

Recent conversation:
${recentMessages.map(m => `${m.role}: ${m.content}`).join('\n\n')}`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'user', content: analysisPrompt }
                            ],
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) return;

                    const data = await response.json();
                    const analysisResult = data.choices[0].message.content;

                    // Parse numbered list
                    let suggestionsFound = 0;
                    const lines = analysisResult.split('\n').filter(line => line.trim());
                    lines.forEach(line => {
                        // Remove numbering and extract content
                        const match = line.match(/^\d+\.\s*(.+)$/);
                        if (match && match[1]) {
                            const content = match[1].trim();
                            // Check if not already in suggestions or memory
                            const isDuplicate =
                                this.memorySuggestions.some(s => s.content === content) ||
                                this.memory.some(m => m.content === content);

                            if (!isDuplicate && content.length > 10) {
                                this.addMemorySuggestion(content);
                                suggestionsFound++;
                            }
                        }
                    });

                    // Show completion toast
                    if (suggestionsFound > 0) {
                        this.showMemoryAnalysisToast(`‚úÖ Found ${suggestionsFound} new memory suggestion${suggestionsFound !== 1 ? 's' : ''}`, 3000);
                    } else {
                        this.showMemoryAnalysisToast('‚úÖ Analysis complete - no new suggestions', 2000);
                    }

                } catch (error) {
                    console.error('Memory analysis error:', error);
                    this.showMemoryAnalysisToast('‚ùå Analysis failed', 2000);
                }
            },

            formatFeaturesForContext() {
                return chatPanel.formatFeaturesForContext(this);
            },

            showAddModal() {
                this.editingId = null;
                this.currentTimelineItems = [{
                    id: Date.now().toString(),
                    timeline: '',
                    difficulty: '',
                    usp: '',
                    integrationType: '',
                    category: []
                }];
                document.getElementById('modalTitle').textContent = 'Add Feature';
                document.getElementById('featureForm').reset();
                this.renderTimelineItems();
                // Setup category inputs after DOM is ready
                setTimeout(() => this.setupAllCategoryInputs(), 0);
                const modal = document.getElementById('featureModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                modal.classList.add('active');
                this._featureModalRelease = this.trapFocus(modal.querySelector('.modal-content') || modal);
            },

            showEditModal(id) {
                const feature = this.features.find(f => f.id === id);
                if (!feature) return;

                this.editingId = id;
                this.currentTimelineItems = feature.timelineItems ? JSON.parse(JSON.stringify(feature.timelineItems)) : [{
                    id: Date.now().toString(),
                    timeline: '',
                    difficulty: '',
                    usp: '',
                    integrationType: '',
                    category: []
                }];

                document.getElementById('modalTitle').textContent = 'Edit Feature';
                document.getElementById('featureName').value = feature.name;
                document.getElementById('featureType').value = feature.type || 'Feature';
                document.getElementById('featurePurpose').value = feature.purpose || '';

                this.renderTimelineItems();
                // Setup category inputs after DOM is ready
                setTimeout(() => this.setupAllCategoryInputs(), 0);
                const modal = document.getElementById('featureModal');
                modal.setAttribute('role','dialog');
                modal.setAttribute('aria-modal','true');
                modal.classList.add('active');
                this._featureModalRelease = this.trapFocus(modal.querySelector('.modal-content') || modal);
            },

            closeModal() {
                document.getElementById('featureModal').classList.remove('active');
                if (this._featureModalRelease) { this._featureModalRelease(); this._featureModalRelease = null; }
                // Reset saving flag if modal is closed
                this.isSavingFeature = false;
                // Reset save button state
                const saveButton = document.querySelector('#featureModal button[type="submit"]');
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = 'Save Feature';
                    saveButton.style.opacity = '';
                    saveButton.style.cursor = '';
                }
            },

            async summarizeTimelineItems(timelineItems) {
                // If only one item or no API key, return simple concatenation
                if (timelineItems.length === 1 || !this.apiKey) {
                    return {
                        usp: timelineItems.map(item => item.usp).filter(u => u).join('; ') || '-',
                        integrationType: timelineItems.map(item => item.integrationType).filter(i => i).join('; ') || '-'
                    };
                }

                try {
                    const usps = timelineItems.map((item, idx) =>
                        `${item.timeline}: ${item.usp || 'N/A'}`
                    ).join('\n');

                    const integrations = timelineItems.map((item, idx) =>
                        `${item.timeline}: ${item.integrationType || 'N/A'}`
                    ).join('\n');

                    const prompt = `Summarize the following feature roadmap data into concise single-line summaries (max 100 characters each):

USPs by timeline:
${usps}

Integration types by timeline:
${integrations}

Provide ONLY two lines in your response:
1. USP: [combined summary of all USPs showing progression]
2. Integration: [combined summary of all integration approaches]`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        throw new Error('API call failed');
                    }

                    const data = await response.json();
                    const result = data.choices[0].message.content;

                    // Parse the response
                    const lines = result.split('\n');
                    let usp = '-';
                    let integrationType = '-';

                    lines.forEach(line => {
                        if (line.toLowerCase().startsWith('1. usp:') || line.toLowerCase().startsWith('usp:')) {
                            usp = line.replace(/^(\d+\.\s*)?usp:\s*/i, '').trim();
                        } else if (line.toLowerCase().startsWith('2. integration:') || line.toLowerCase().startsWith('integration:')) {
                            integrationType = line.replace(/^(\d+\.\s*)?integration:\s*/i, '').trim();
                        }
                    });

                    return { usp, integrationType };

                } catch (error) {
                    console.error('Summarization error:', error);
                    // Fallback to simple concatenation
                    return {
                        usp: timelineItems.map(item => item.usp).filter(u => u).join('; ') || '-',
                        integrationType: timelineItems.map(item => item.integrationType).filter(i => i).join('; ') || '-'
                    };
                }
            },

            async analyzeBatchLinks(evt) {
                if (!this.apiKey) {
                    await this.showAlert({ title:'API key required', message:'Please set your OpenRouter API key first (Chat panel ‚Üí Settings).', variant:'warning' });
                    return;
                }

                if (this.features.length < 2) {
                    await this.showAlert({ title:'Not enough features', message:'You need at least 2 features to analyze links.' });
                    return;
                }

                // Show loading state
                const button = (evt && evt.currentTarget) ? evt.currentTarget : (typeof event !== 'undefined' ? event.target : null);
                const originalText = button.textContent;
                button.textContent = 'üîÑ Analyzing...';
                button.disabled = true;

                try {
                    // Collect all timeline items from all features
                    const allItems = [];
                    this.features.forEach(feature => {
                        feature.timelineItems.forEach(item => {
                            allItems.push({
                                featureId: feature.id,
                                featureName: feature.name,
                                featureType: feature.type,
                                featurePurpose: feature.purpose,
                                itemId: item.id,
                                timeline: item.timeline,
                                difficulty: item.difficulty,
                                usp: item.usp,
                                integrationType: item.integrationType,
                                categories: item.category.join(', ')
                            });
                        });
                    });

                    // Build the analysis prompt - group by feature to make it clearer
                    const featureGroups = {};
                    allItems.forEach(item => {
                        if (!featureGroups[item.featureId]) {
                            featureGroups[item.featureId] = {
                                name: item.featureName,
                                type: item.featureType,
                                purpose: item.featurePurpose,
                                id: item.featureId,
                                items: []
                            };
                        }
                        featureGroups[item.featureId].items.push(item);
                    });

                    const itemsDescription = Object.values(featureGroups).map((feature, idx) => {
                        const items = feature.items.map(item =>
                            `     - Timeline: ${item.timeline}, Difficulty: ${item.difficulty}, ItemID: ${item.itemId}\n       USP: ${item.usp}\n       Integration: ${item.integrationType}\n       Categories: ${item.categories}`
                        ).join('\n');

                        return `
FEATURE ${idx + 1}: "${feature.name}" (${feature.type})
FeatureID: ${feature.id}
Purpose: ${feature.purpose}
Timeline Items (DO NOT LINK THESE TOGETHER):
${items}`;
                    }).join('\n\n');

                    const prompt = `Analyze the following roadmap timeline items and identify potential relationships BETWEEN DIFFERENT FEATURES ONLY.

IMPORTANT: Do NOT suggest links between timeline items of the same feature. Timeline items within a feature are already connected by design.

Focus on cross-feature relationships:
- Dependencies: Items from different features where one must be completed before another (e.g., Feature A's SHORT depends on Feature B's MVP)
- Complements: Items from different features that work well together or enhance each other

For each relationship, provide:
1. Source item ID (depends on or complements from)
2. Target item ID (the item being depended on or complemented)
3. Relationship type: "dependency" or "complements"
4. Brief reason (1 sentence max)
5. Confidence: "high", "medium", or "low"

Only suggest relationships with medium or high confidence.
CRITICAL: Source and target must be from DIFFERENT features.

TIMELINE ITEMS:
${itemsDescription}${this.buildLearningContext()}

Return ONLY a valid JSON array with this exact format:
[
  {
    "sourceItemId": "12345",
    "targetItemId": "67890",
    "type": "dependency",
    "reason": "Authentication required before user profiles",
    "confidence": "high"
  }
]

If no relationships found, return: []`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify({
                            model: this.selectedModel,
                            messages: [
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        throw new Error('API call failed');
                    }

                    const data = await response.json();
                    let result = data.choices[0].message.content.trim();

                    // Clean up the response - remove markdown code blocks if present
                    result = result.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                    // Parse the JSON
                    const suggestions = JSON.parse(result);

                    if (!Array.isArray(suggestions)) {
                        throw new Error('Invalid response format');
                    }

                    // Filter out low confidence suggestions, same-feature links, and duplicates
                    const validSuggestions = suggestions.filter(s => {
                        if (s.confidence === 'low') return false;

                        // Extra safety: ensure source and target are from different features
                        const sourceInfo = allItems.find(i => i.itemId === s.sourceItemId);
                        const targetInfo = allItems.find(i => i.itemId === s.targetItemId);

                        if (!sourceInfo || !targetInfo) return false;

                        // Skip if same feature
                        if (sourceInfo.featureId === targetInfo.featureId) {
                            console.log(`Skipping same-feature link: ${sourceInfo.featureName} - ${sourceInfo.timeline} ‚Üí ${targetInfo.timeline}`);
                            return false;
                        }

                        // Check if already rejected (both directions)
                        const isRejected = this.rejectedLinks.some(rl =>
                            (rl.sourceItemId === s.sourceItemId && rl.targetItemId === s.targetItemId) ||
                            (rl.sourceItemId === s.targetItemId && rl.targetItemId === s.sourceItemId)
                        );
                        if (isRejected) {
                            console.log(`Skipping previously rejected link: ${sourceInfo.featureName} (${sourceInfo.timeline}) ‚Üî ${targetInfo.featureName} (${targetInfo.timeline})`);
                            return false;
                        }

                        // Check if already approved (exists in linkedItems)
                        const sourceFeature = this.features.find(f => f.id === sourceInfo.featureId);
                        const sourceItem = sourceFeature?.timelineItems.find(i => i.id === s.sourceItemId);

                        if (sourceItem?.linkedItems) {
                            const alreadyLinked = sourceItem.linkedItems.some(link =>
                                link.linkedItemId === s.targetItemId
                            );
                            if (alreadyLinked) {
                                console.log(`Skipping already approved link: ${sourceInfo.featureName} (${sourceInfo.timeline}) ‚Üí ${targetInfo.featureName} (${targetInfo.timeline})`);
                                return false;
                            }
                        }

                        return true;
                    });

                    if (validSuggestions.length === 0) {
                        await this.showAlert({ title:'Analysis complete', message:'No new cross-feature relationships found.' });
                        button.textContent = originalText;
                        button.disabled = false;
                        return;
                    }

                    // Add to link suggestions
                    validSuggestions.forEach(suggestion => {
                        // Find the items to get feature IDs
                        const sourceInfo = allItems.find(i => i.itemId === suggestion.sourceItemId);
                        const targetInfo = allItems.find(i => i.itemId === suggestion.targetItemId);

                        if (sourceInfo && targetInfo) {
                            this.linkSuggestions.push({
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                sourceFeatureId: sourceInfo.featureId,
                                targetFeatureId: targetInfo.featureId,
                                sourceItemId: suggestion.sourceItemId,
                                targetItemId: suggestion.targetItemId,
                                type: suggestion.type,
                                reason: suggestion.reason,
                                confidence: suggestion.confidence,
                                timestamp: new Date().toISOString()
                            });
                        }
                    });

                    this.saveLinkSuggestions();
                    this.updateLinkNotification();

                    await this.showAlert({ title:'Analysis complete', message:`Found ${validSuggestions.length} potential link(s). Check the notification bar to review and approve them.` });

                } catch (error) {
                    console.error('Link analysis error:', error);
                    await this.showAlert({ title:'Analysis error', message: error.message, variant:'danger' });
                } finally {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            },

            async saveFeature(event) {
                event.preventDefault();

                // Prevent double-clicks
                if (this.isSavingFeature) {
                    return;
                }

                // Validate timeline items
                if (this.currentTimelineItems.length === 0) {
                    await this.showAlert({ title:'Add timeline item', message:'Please add at least one timeline item!' });
                    return;
                }

                // Validate each timeline item has required fields
                for (let item of this.currentTimelineItems) {
                    if (!item.timeline || !item.difficulty) {
                        await this.showAlert({ title:'Missing fields', message:'Please fill in Timeline and Difficulty for all timeline items!' });
                        return;
                    }
                }

                // Set saving flag and disable button
                this.isSavingFeature = true;
                const saveButton = event.target.closest('form')?.querySelector('button[type="submit"]');
                const originalText = saveButton?.textContent || 'Save Feature';
                if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = 'Saving...';
                    saveButton.style.opacity = '0.6';
                    saveButton.style.cursor = 'not-allowed';
                }

                try {
                    // Generate AI summaries
                    const summaries = await this.summarizeTimelineItems(this.currentTimelineItems);

                    const feature = {
                        id: this.editingId || Date.now().toString(),
                        name: document.getElementById('featureName').value,
                        type: document.getElementById('featureType').value,
                        purpose: document.getElementById('featurePurpose').value,
                        workspaceId: this.currentWorkspaceId,
                        timelineItems: JSON.parse(JSON.stringify(this.currentTimelineItems)),
                        summary: summaries,
                        createdAt: this.editingId ?
                            this.features.find(f => f.id === this.editingId).createdAt :
                            new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    if (this.editingId) {
                        const index = this.features.findIndex(f => f.id === this.editingId);
                        if (index !== -1) {
                            this.features[index] = feature;
                        }
                    } else {
                        // Check if feature already exists (prevent duplicates)
                        const existingFeature = this.features.find(f => 
                            f.name === feature.name && 
                            f.type === feature.type &&
                            Math.abs(new Date(f.createdAt).getTime() - new Date(feature.createdAt).getTime()) < 2000
                        );
                        if (!existingFeature) {
                            this.features.push(feature);
                        }
                    }

                    // Add all categories from timeline items to allTags
                    feature.timelineItems.forEach(item => {
                        item.category.forEach(c => this.allTags.add(c));
                    });

                    this.saveData();
                    this.closeModal();
                    this.renderTable();
                } catch (error) {
                    console.error('Save feature error:', error);
                    await this.showAlert({ title:'Save error', message:'Failed to save feature. Please try again.', variant:'danger' });
                } finally {
                    // Reset saving flag and re-enable button
                    this.isSavingFeature = false;
                    if (saveButton) {
                        saveButton.disabled = false;
                        saveButton.textContent = originalText;
                        saveButton.style.opacity = '';
                        saveButton.style.cursor = '';
                    }
                }
            },

            async deleteFeature(id) {
                const f = this.features.find(x => x.id === id);
                const ok = await this.showConfirm({ title: 'Delete feature?', message: `Delete "${f?.name || 'this feature'}". This cannot be undone.`, confirmText: 'Delete', cancelText: 'Cancel', variant: 'danger' });
                if (!ok) return;
                this.features = this.features.filter(f => f.id !== id);
                this.saveData();
                this.renderTable();
            },

            setupTagInput() {
                const input = document.getElementById('tagInput');
                const suggestions = document.getElementById('tagSuggestions');

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const tag = input.value.trim();
                        if (tag && !this.currentTags.includes(tag)) {
                            this.currentTags.push(tag);
                            this.allTags.add(tag);
                            input.value = '';
                            this.renderTags();
                            suggestions.classList.remove('active');
                        }
                    }
                });

                input.addEventListener('input', (e) => {
                    const value = e.target.value.toLowerCase();
                    if (value.length > 0) {
                        const matching = Array.from(this.allTags)
                            .filter(t => t.toLowerCase().includes(value) && !this.currentTags.includes(t));

                        if (matching.length > 0) {
                            suggestions.innerHTML = matching
                                .map(t => `<div class="tag-suggestion-item" onclick="app.addTag('${t}')">${t}</div>`)
                                .join('');
                            suggestions.classList.add('active');
                        } else {
                            suggestions.classList.remove('active');
                        }
                    } else {
                        suggestions.classList.remove('active');
                    }
                });
            },

            getAllExistingCategories() {
                return featureTable.getAllExistingCategories(this);
            },

            setupCategoryInput(itemId) {
                const input = document.getElementById(`timelineCategoryInput-${itemId}`);
                const suggestions = document.getElementById(`timelineCategorySuggestions-${itemId}`);

                if (!input || !suggestions) return;

                // Get current timeline item
                const currentItem = this.currentTimelineItems.find(i => i.id === itemId);
                if (!currentItem) return;

                input.addEventListener('input', (e) => {
                    const value = e.target.value.toLowerCase();
                    if (value.length > 0) {
                        const allCategories = this.getAllExistingCategories();
                        const matching = allCategories
                            .filter(cat =>
                                cat.toLowerCase().includes(value) &&
                                !currentItem.category.includes(cat)
                            );

                        if (matching.length > 0) {
                            suggestions.innerHTML = matching
                                .map(cat => `<div class="tag-suggestion-item" onclick="app.addCategoryFromSuggestion('${itemId}', '${cat}')">${cat}</div>`)
                                .join('');
                            suggestions.classList.add('active');
                        } else {
                            suggestions.classList.remove('active');
                        }
                    } else {
                        suggestions.classList.remove('active');
                    }
                });

                // Close suggestions on blur
                input.addEventListener('blur', () => {
                    // Delay to allow click on suggestion to register
                    setTimeout(() => suggestions.classList.remove('active'), 200);
                });
            },

            setupAllCategoryInputs() {
                // Setup autocomplete for all timeline item category inputs
                this.currentTimelineItems.forEach(item => {
                    this.setupCategoryInput(item.id);
                });
            },

            addCategoryFromSuggestion(itemId, category) {
                const input = document.getElementById(`timelineCategoryInput-${itemId}`);
                const suggestions = document.getElementById(`timelineCategorySuggestions-${itemId}`);

                this.addCategoryToTimelineItem(itemId, category);

                if (input) input.value = '';
                if (suggestions) suggestions.classList.remove('active');
            },

            addTag(tag) {
                if (!this.currentTags.includes(tag)) {
                    this.currentTags.push(tag);
                    document.getElementById('tagInput').value = '';
                    document.getElementById('tagSuggestions').classList.remove('active');
                    this.renderTags();
                }
            },

            removeTag(tag) {
                this.currentTags = this.currentTags.filter(t => t !== tag);
                this.renderTags();
            },

            renderTags() {
                const container = document.getElementById('tagInputContainer');
                const input = document.getElementById('tagInput');

                container.innerHTML = '';
                this.currentTags.forEach(tag => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'tag';
                    tagEl.innerHTML = `${tag} <span style="cursor:pointer; margin-left:5px;" onclick="app.removeTag('${tag}')">&times;</span>`;
                    container.appendChild(tagEl);
                });
                container.appendChild(input);
            },

            populateCategoryDropdown() {
                const select = document.getElementById('existingCategorySelect');
                if (!select) return;

                // Get all unique categories from existing features
                const existingCategories = new Set();
                this.features.forEach(f => {
                    if (f.tags && Array.isArray(f.tags)) {
                        f.tags.forEach(tag => existingCategories.add(tag));
                    }
                });

                // Also include tags from allTags
                this.allTags.forEach(tag => existingCategories.add(tag));

                // Clear and populate dropdown
                select.innerHTML = '<option value="">Select existing category...</option>';
                Array.from(existingCategories).sort().forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    select.appendChild(option);
                });
            },

            addCategoryFromSelect(value) {
                if (value) {
                    this.addTag(value);
                    document.getElementById('existingCategorySelect').value = '';
                }
            },

            // Timeline Items Management
            addTimelineItem() {
                const item = {
                    id: Date.now().toString(),
                    timeline: '',
                    difficulty: '',
                    usp: '',
                    integrationType: '',
                    category: []
                };
                this.currentTimelineItems.push(item);
                this.renderTimelineItems();
            },

            async removeTimelineItem(id) {
                if (this.currentTimelineItems.length <= 1) {
                    await this.showAlert({ title:'Cannot remove', message:'At least one timeline item is required!' });
                    return;
                }
                this.currentTimelineItems = this.currentTimelineItems.filter(i => i.id !== id);
                this.renderTimelineItems();
            },

            updateTimelineItem(id, field, value) {
                const item = this.currentTimelineItems.find(i => i.id === id);
                if (item) {
                    item[field] = value;
                }
            },

            addCategoryToTimelineItem(itemId, category) {
                const item = this.currentTimelineItems.find(i => i.id === itemId);
                if (item && !item.category.includes(category)) {
                    item.category.push(category);
                    this.renderTimelineItems();
                }
            },

            removeCategoryFromTimelineItem(itemId, category) {
                const item = this.currentTimelineItems.find(i => i.id === itemId);
                if (item) {
                    item.category = item.category.filter(c => c !== category);
                    this.renderTimelineItems();
                }
            },

            renderTimelineItems() {
                const container = document.getElementById('timelineItemsContainer');
                if (!container) return;

                container.innerHTML = this.currentTimelineItems.map((item, index) => `
                    <div style="background:var(--surface-alt); padding:15px; border-radius:8px; margin-bottom:15px; border:2px solid var(--border);">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                            <span style="font-weight:600; color:var(--text-secondary);">Timeline Item ${index + 1}</span>
                            ${this.currentTimelineItems.length > 1 ? `<button type="button" onclick="app.removeTimelineItem('${item.id}')" style="background:var(--danger); color:var(--text-inverse); border:none; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:12px;">Remove</button>` : ''}
                        </div>

                        <div style="display:grid; gap:10px;">
                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Timeline *</label>
                                <select onchange="app.updateTimelineItem('${item.id}', 'timeline', this.value)" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);" required>
                                    <option value="">Select timeline</option>
                                    <option value="MVP" ${item.timeline === 'MVP' ? 'selected' : ''}>MVP</option>
                                    <option value="SHORT" ${item.timeline === 'SHORT' ? 'selected' : ''}>SHORT</option>
                                    <option value="LONG" ${item.timeline === 'LONG' ? 'selected' : ''}>LONG</option>
                                </select>
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Difficulty *</label>
                                <select onchange="app.updateTimelineItem('${item.id}', 'difficulty', this.value)" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);" required>
                                    <option value="">Select difficulty</option>
                                    <option value="Easy" ${item.difficulty === 'Easy' ? 'selected' : ''}>Easy</option>
                                    <option value="Medium" ${item.difficulty === 'Medium' ? 'selected' : ''}>Medium</option>
                                    <option value="Hard" ${item.difficulty === 'Hard' ? 'selected' : ''}>Hard</option>
                                </select>
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">USP</label>
                                <textarea onchange="app.updateTimelineItem('${item.id}', 'usp', this.value)" placeholder="What makes this unique?" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; font-family:inherit; resize:vertical; min-height:60px; background:var(--surface); color:var(--text-primary);">${item.usp || ''}</textarea>
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Integration Type</label>
                                <input type="text" onchange="app.updateTimelineItem('${item.id}', 'integrationType', this.value)" value="${item.integrationType || ''}" placeholder="How will this be executed?" style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);">
                            </div>

                            <div>
                                <label style="display:block; font-size:12px; font-weight:600; color:var(--text-muted); margin-bottom:4px;">Category</label>
                                <div style="display:flex; flex-wrap:wrap; gap:5px; margin-bottom:5px; min-height:32px; align-items:center;">
                                    ${item.category.map(cat => `<span class="tag">${cat} <span style="cursor:pointer; margin-left:5px;" onclick="app.removeCategoryFromTimelineItem('${item.id}', '${cat}')">&times;</span></span>`).join('')}
                                </div>
                                <div class="tag-suggestions" style="position:relative;">
                                    <input type="text" id="timelineCategoryInput-${item.id}" placeholder="Type and press Enter"
                                        onkeypress="if(event.key==='Enter'){event.preventDefault(); const val=this.value.trim(); if(val){app.addCategoryToTimelineItem('${item.id}', val); this.value='';}}"
                                        style="width:100%; padding:8px; border:2px solid var(--border); border-radius:6px; font-size:14px; background:var(--surface); color:var(--text-primary);">
                                    <div id="timelineCategorySuggestions-${item.id}" class="tag-suggestions-list"></div>
                                </div>
                            </div>

                            <!-- Link Management Section -->
                            <div class="timeline-item-links">
                                <div class="timeline-item-links-header">
                                    <h4>Linked Items</h4>
                                    <button type="button" class="add-link-btn" onclick="app.showAddLinkModal('${item.id}')">+ Add Link</button>
                                </div>
                                <div id="links-${item.id}">
                                    ${(item.linkedItems || []).map(link => {
                                        const linkedFeature = this.features.find(f => f.id === link.linkedFeatureId);
                                        const linkedItem = linkedFeature?.timelineItems.find(i => i.id === link.linkedItemId);
                                        if (!linkedFeature || !linkedItem) return '';
                                        const typeLabel = link.relationshipType === 'dependency' ? 'Dependency' : 'Complements';
                                        const typeClass = link.relationshipType === 'dependency' ? 'dependency' : 'complements';
                                        return `
                                            <div class="link-item">
                                                <div class="link-item-info">
                                                    <span class="link-item-type ${typeClass}">${typeLabel}</span>
                                                    <strong>${linkedFeature.name}</strong> (${linkedItem.timeline})
                                                    <div style="font-size:11px; color:var(--text-muted); margin-top:2px;">${link.reason || 'No description'}</div>
                                                </div>
                                                <button type="button" class="remove-link-btn" onclick="app.removeLink('${item.id}', '${link.linkedItemId}')">‚úó</button>
                                            </div>
                                        `;
                                    }).join('') || '<div style="color:var(--text-muted); font-size:12px; padding:8px;">No links yet</div>'}
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

                // Setup category inputs after DOM is updated
                setTimeout(() => this.setupAllCategoryInputs(), 0);
            },

            renderTable() {
                featureTable.renderTable(this);
            },

            // ==================== Detail View Navigation ====================

            showDetailView(featureId) {
                detailViewCore.showDetailView(this, featureId);
            },

            showTableView() {
                detailViewCore.showTableView(this);
            },

            switchDetailTab(tabName) {
                detailViewCore.switchDetailTab(this, tabName);
            },

            editFeatureFromDetail() {
                detailViewCore.editFeatureFromDetail(this);
            },

            // ==================== Detail View Rendering ====================

            renderFeatureDetail(featureId) {
                detailViewCore.renderFeatureDetail(this, featureId);
            },

            renderTrackingSection(feature) {
                detailViewCore.renderTrackingSection(this, feature);
            },

            calculateProgress(feature) {
                return detailViewCore.calculateProgress(feature);
            },

            updateFeatureTracking(field, value) {
                detailViewCore.updateFeatureTracking(this, field, value);
            },

            renderContributors(contributors) {
                detailViewCrud.renderContributors(this, contributors);
            },

            addContributor() {
                detailViewCrud.addContributor(this);
            },

            removeContributor(name) {
                detailViewCrud.removeContributor(this, name);
            },

            renderStakeholders(stakeholders) {
                detailViewCrud.renderStakeholders(this, stakeholders);
            },

            addStakeholder() {
                detailViewCrud.addStakeholder(this);
            },

            removeStakeholder(name) {
                detailViewCrud.removeStakeholder(this, name);
            },

            renderOverviewTab(feature) {
                detailViewTabs.renderOverviewTab(this, feature);
            },

            getAllLinkedItems(featureId) {
                return detailViewTabs.getAllLinkedItems(this, featureId);
            },

            renderExecutionTab(feature) {
                detailViewTabs.renderExecutionTab(this, feature);
            },

            renderResourcesTab(feature) {
                detailViewTabs.renderResourcesTab(this, feature);
            },

            renderPlanningTab(feature) {
                detailViewTabs.renderPlanningTab(this, feature);
            },

            renderInspirationTab(feature) {
                detailViewTabs.renderInspirationTab(this, feature);
            },

            // ==================== Detail View Helper Functions ====================

            addExecutionStep() {
                detailViewCrud.addExecutionStep(this);
            },

            toggleStepComplete(featureId, stepId) {
                detailViewCrud.toggleStepComplete(this, featureId, stepId);
            },

            async deleteExecutionStep(featureId, stepId) {
                await detailViewCrud.deleteExecutionStep(this, featureId, stepId);
            },

            addMilestone() {
                detailViewCrud.addMilestone(this);
            },

            addRisk() {
                detailViewCrud.addRisk(this);
            },

            addPrerequisite() {
                detailViewCrud.addPrerequisite(this);
            },

            addInspiration() {
                detailViewCrud.addInspiration(this);
            },

            deleteInspiration(featureId, inspirationId) {
                detailViewCrud.deleteInspiration(this, featureId, inspirationId);
            },

            // ==================== AI Integration for Detail View ====================

            async generateExecutionPlan() {
                await detailViewAI.generateExecutionPlan(this);
            },

            async suggestResources() {
                await detailViewAI.suggestResources(this);
            },

            async identifyRisks() {
                await detailViewAI.identifyRisks(this);
            },

            async generateMilestones() {
                await detailViewAI.generateMilestones(this);
            },

            async suggestPrerequisites() {
                await detailViewAI.suggestPrerequisites(this);
            },

            async findInspiration() {
                await detailViewAI.findInspiration(this);
            },

            async analyzeFeatureForSearch(feature) {
                const prompt = `Analyze this feature for intelligent web search:

Feature: ${feature.name}
Type: ${feature.type}
Purpose: ${feature.purpose || 'Not specified'}

Extract JSON:
{
    "coreKeywords": ["keyword1", "keyword2", ...],
    "industryDomain": "fintech|social|analytics|ecommerce|general",
    "technicalComplexity": "simple|medium|complex",
    "searchFocus": ["implementation", "competitors", "tools", "providers"],
    "recommendedDomains": ["domain1.com", ...]
}`;

                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Platform Roadmap Manager'
                    },
                    body: JSON.stringify({
                        model: this.selectedModel,
                        messages: [
                            { role: 'system', content: 'You are a search query optimization expert. Return only valid JSON.' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.3
                    })
                });

                const data = await response.json();
                const content = data.choices[0].message.content;

                // Extract JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                return jsonMatch ? JSON.parse(jsonMatch[0]) : {
                    coreKeywords: [feature.name],
                    industryDomain: 'general',
                    technicalComplexity: 'medium',
                    searchFocus: ['implementation', 'tools'],
                    recommendedDomains: []
                };
            },

            generateSmartQueries(feature, context) {
                const queries = [];
                const keywords = context.coreKeywords.join(' ');
                const complexity = context.technicalComplexity;

                // Query 1: Implementation/Tutorial
                queries.push({
                    query: complexity === 'complex'
                        ? `${keywords} system architecture implementation guide`
                        : `how to implement ${keywords} step by step tutorial`,
                    search_depth: complexity === 'complex' ? 'advanced' : 'basic',
                    max_results: 7,
                    include_domains: ['github.com', 'medium.com', 'dev.to', 'stackoverflow.com'],
                    topic: 'general'
                });

                // Query 2: Tools/Libraries
                if (context.searchFocus.includes('tools')) {
                    queries.push({
                        query: `best ${keywords} libraries frameworks tools 2024`,
                        search_depth: 'basic',
                        max_results: 7,
                        include_domains: ['github.com', 'npmjs.com', 'pypi.org'],
                        topic: 'general'
                    });
                }

                // Query 3: Competitors/Examples
                if (context.searchFocus.includes('competitors')) {
                    queries.push({
                        query: `platforms with ${feature.name} feature examples`,
                        search_depth: 'basic',
                        max_results: 7,
                        include_domains: ['producthunt.com', 'g2.com', 'capterra.com'],
                        topic: 'general'
                    });
                }

                // Query 4: API/Service Providers
                if (context.searchFocus.includes('providers')) {
                    queries.push({
                        query: `${keywords} API service providers comparison`,
                        search_depth: 'basic',
                        max_results: 7,
                        include_domains: ['rapidapi.com', 'programmableweb.com', ...context.recommendedDomains],
                        topic: 'general'
                    });
                }

                // Query 5: Best Practices (for complex features)
                if (complexity === 'complex') {
                    queries.push({
                        query: `${keywords} security scalability best practices`,
                        search_depth: 'advanced',
                        max_results: 5,
                        include_domains: ['docs.microsoft.com', 'aws.amazon.com', 'github.com'],
                        topic: 'general'
                    });
                }

                return queries;
            },

            async executeTavilySearch(queryConfig) {
                const response = await fetch('https://api.tavily.com/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        api_key: this.tavilyApiKey,
                        ...queryConfig
                    })
                });

                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                return data.results || [];
            },

            deduplicateResults(results) {
                const seen = new Map();
                return results.filter(r => {
                    try {
                        const urlKey = new URL(r.url).hostname + new URL(r.url).pathname;
                        if (seen.has(urlKey)) return false;
                        seen.set(urlKey, true);
                        return true;
                    } catch {
                        return true; // Keep if URL parsing fails
                    }
                });
            },

            scoreResult(result, feature) {
                let score = 0;

                // Domain authority (0-30)
                const authorityScores = {
                    'github.com': 30, 'stackoverflow.com': 28, 'docs.microsoft.com': 30,
                    'aws.amazon.com': 30, 'cloud.google.com': 30, 'firebase.google.com': 28,
                    'stripe.com': 28, 'auth0.com': 28, 'medium.com': 22, 'dev.to': 20,
                    'smashingmagazine.com': 25, 'css-tricks.com': 25, 'freecodecamp.org': 24
                };
                try {
                    const domain = new URL(result.url).hostname.replace('www.', '');
                    score += authorityScores[domain] || 12;
                } catch {
                    score += 10;
                }

                // Keyword relevance (0-35)
                const searchText = (result.title + ' ' + (result.content || '')).toLowerCase();
                const featureText = (feature.name + ' ' + (feature.purpose || '')).toLowerCase();
                const words = featureText.split(/\s+/).filter(w => w.length > 3);
                const matches = words.filter(w => searchText.includes(w)).length;
                score += Math.min(matches * 7, 35);

                // Content type bonus (0-20)
                if (result.url.includes('github.com') && result.url.includes('/tree/')) score += 20;
                else if (result.title.match(/documentation|official docs/i)) score += 18;
                else if (result.title.match(/tutorial|guide|how.?to/i)) score += 15;
                else if (result.title.match(/best practices|patterns/i)) score += 16;

                // Recency (0-15)
                if (result.title.match(/2024/)) score += 15;
                else if (result.title.match(/2023/)) score += 12;
                else if (result.title.match(/202[0-2]/)) score += 8;

                return score;
            },

            categorizeResult(result) {
                const url = result.url.toLowerCase();
                const title = result.title.toLowerCase();

                if (url.includes('github.com')) return 'code';
                if (url.includes('stackoverflow.com')) return 'qa';
                if (title.match(/tutorial|guide|how.?to/)) return 'tutorial';
                if (url.match(/docs?\.|documentation/)) return 'documentation';
                if (title.match(/comparison|vs|alternative/)) return 'comparison';
                if (url.includes('medium.com') || url.includes('dev.to')) return 'article';

                return 'reference';
            },

            // ==================== Exa API Integration ====================

            async executeExaSearch(query, options = {}) {
                try {
                    const exaApiKey = localStorage.getItem('exaApiKey');
                    if (!exaApiKey) {
                        throw new Error('Exa API key not configured. Please add it in Settings.');
                    }

                    const requestBody = {
                        query: query,
                        type: options.type || 'neural', // 'neural' for semantic, 'keyword' for traditional
                        numResults: options.numResults || 10,
                        useAutoprompt: options.useAutoprompt !== false, // Default true
                        includeDomains: options.includeDomains || [],
                        excludeDomains: options.excludeDomains || [],
                        startPublishedDate: options.startPublishedDate || null,
                        contents: {
                            text: { maxCharacters: options.maxCharacters || 2000 }
                        }
                    };

                    // Optional filters
                    if (options.category) requestBody.category = options.category;
                    if (options.startCrawlDate) requestBody.startCrawlDate = options.startCrawlDate;

                    const response = await fetch('https://api.exa.ai/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': exaApiKey
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.message || 'Exa search failed');
                    }

                    const data = await response.json();
                    console.log('‚úÖ Exa search completed:', data.results.length, 'results');
                    return data.results || [];
                } catch (error) {
                    console.error('‚ùå Exa search error:', error);
                    throw error;
                }
            },

            analyzeFeatureForExaSearch(feature) {
                // Exa works best with semantic, natural language queries
                // Build query that captures intent and context
                const parts = [];

                // Core feature description
                parts.push(feature.name);
                if (feature.description) {
                    parts.push(feature.description.substring(0, 200));
                }

                // Technical context from categories
                if (feature.categories && feature.categories.length > 0) {
                    const techKeywords = feature.categories
                        .filter(cat => ['Frontend', 'Backend', 'Database', 'Infrastructure', 'Security'].includes(cat))
                        .join(' ');
                    if (techKeywords) parts.push(techKeywords);
                }

                // Extract technologies from resources
                if (feature.resources && feature.resources.technologies) {
                    const tech = feature.resources.technologies
                        .split(',')
                        .map(t => t.trim())
                        .join(' ');
                    if (tech) parts.push(tech);
                }

                return {
                    semanticQuery: parts.join('. '),
                    searchType: 'neural', // Semantic search
                    focus: this.determineSearchFocus(feature),
                    domains: this.getRelevantDomains(feature),
                    recencyImportance: this.calculateRecencyNeeds(feature)
                };
            },

            determineSearchFocus(feature) {
                // Determine what type of content we need
                const focus = [];

                if (!feature.executionSteps || feature.executionSteps.length === 0) {
                    focus.push('implementation');
                }

                if (!feature.resources || !feature.resources.technologies) {
                    focus.push('tools');
                    focus.push('libraries');
                }

                if (feature.risks && feature.risks.length > 0) {
                    focus.push('best-practices');
                    focus.push('solutions');
                }

                if (feature.categories?.includes('Research')) {
                    focus.push('academic');
                    focus.push('papers');
                }

                return focus;
            },

            getRelevantDomains(feature) {
                const domains = ['github.com', 'stackoverflow.com'];

                // Add domain based on categories
                if (feature.categories?.includes('Frontend')) {
                    domains.push('dev.to', 'css-tricks.com', 'web.dev');
                }

                if (feature.categories?.includes('Backend')) {
                    domains.push('medium.com', 'martinfowler.com');
                }

                if (feature.categories?.includes('AI/ML')) {
                    domains.push('arxiv.org', 'paperswithcode.com', 'huggingface.co');
                }

                if (feature.categories?.includes('Database')) {
                    domains.push('dba.stackexchange.com', 'percona.com');
                }

                return domains;
            },

            calculateRecencyNeeds(feature) {
                // Determine if we need recent results
                const categories = feature.categories || [];

                // High recency need
                if (categories.includes('AI/ML') || categories.includes('Frontend')) {
                    return 'high'; // Last 12 months
                }

                // Medium recency need
                if (categories.includes('Backend') || categories.includes('Infrastructure')) {
                    return 'medium'; // Last 24 months
                }

                // Lower recency need for stable technologies
                return 'low'; // Last 36 months
            },

            async findInspirationWithExa() {
                await detailViewAI.findInspirationWithExa(this);
            },

            categorizeExaResult(result) {
                const url = result.url.toLowerCase();
                const title = result.title?.toLowerCase() || '';

                if (url.includes('github.com')) return 'code';
                if (url.includes('stackoverflow.com')) return 'qa';
                if (url.includes('arxiv.org') || url.includes('paperswithcode.com')) return 'research';
                if (title.match(/tutorial|guide|how.?to/)) return 'tutorial';
                if (url.match(/docs?\.|documentation/)) return 'documentation';
                if (title.match(/comparison|vs|alternative/)) return 'comparison';
                if (url.includes('medium.com') || url.includes('dev.to')) return 'article';

                return 'reference';
            },

            rankExaResults(results, feature) {
                // Score each result based on multiple factors
                return results.map(result => {
                    let score = 0;

                    // 1. Exa's built-in relevance score (0-1, most important)
                    score += (result.score || 0) * 100;

                    // 2. Domain authority
                    const url = result.url.toLowerCase();
                    if (url.includes('github.com')) score += 25;
                    else if (url.includes('stackoverflow.com')) score += 20;
                    else if (url.includes('medium.com') || url.includes('dev.to')) score += 15;
                    else if (url.match(/\.edu|arxiv\.org/)) score += 30;
                    else if (url.match(/docs?\.|documentation/)) score += 22;

                    // 3. Content type preference (Exa provides rich text)
                    if (result.text && result.text.length > 1000) score += 15; // Substantial content
                    if (result.text && result.text.includes('```')) score += 10; // Contains code

                    // 4. Title relevance
                    const title = result.title?.toLowerCase() || '';
                    const featureName = feature.name.toLowerCase();
                    if (title.includes(featureName)) score += 20;

                    // Check for feature keywords
                    const keywords = featureName.split(' ');
                    keywords.forEach(keyword => {
                        if (keyword.length > 3 && title.includes(keyword)) {
                            score += 5;
                        }
                    });

                    // 5. Recency (Exa provides publishedDate)
                    if (result.publishedDate) {
                        const publishDate = new Date(result.publishedDate);
                        const monthsOld = (Date.now() - publishDate.getTime()) / (30 * 24 * 60 * 60 * 1000);

                        if (monthsOld < 6) score += 20;
                        else if (monthsOld < 12) score += 15;
                        else if (monthsOld < 24) score += 10;
                        else if (monthsOld < 36) score += 5;
                    }

                    // 6. Author credibility (if available)
                    if (result.author) score += 8;

                    // 7. Highlight matches (Exa provides highlights)
                    if (result.highlights && result.highlights.length > 0) {
                        score += Math.min(result.highlights.length * 3, 15);
                    }

                    return { ...result, finalScore: Math.round(score) };
                }).sort((a, b) => b.finalScore - a.finalScore);
            },

            // ==================== Perplexity API Integration ====================

            async executePerplexitySearch(query, options = {}) {
                try {
                    const perplexityApiKey = localStorage.getItem('perplexityApiKey');
                    if (!perplexityApiKey) {
                        throw new Error('Perplexity API key not configured. Please add it in Settings.');
                    }

                    const requestBody = {
                        model: options.model || 'llama-3.1-sonar-large-128k-online',
                        messages: [
                            {
                                role: 'system',
                                content: options.systemPrompt || 'You are a helpful research assistant. Provide accurate, well-cited information.'
                            },
                            {
                                role: 'user',
                                content: query
                            }
                        ],
                        temperature: options.temperature || 0.2,
                        max_tokens: options.maxTokens || 2000,
                        return_citations: true,
                        return_images: false,
                        search_domain_filter: options.searchDomainFilter || [],
                        search_recency_filter: options.searchRecencyFilter || null
                    };

                    const response = await fetch('https://api.perplexity.ai/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${perplexityApiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || 'Perplexity search failed');
                    }

                    const data = await response.json();
                    console.log('‚úÖ Perplexity search completed');
                    return {
                        content: data.choices[0].message.content,
                        citations: data.citations || [],
                        model: data.model
                    };
                } catch (error) {
                    console.error('‚ùå Perplexity search error:', error);
                    throw error;
                }
            },

            async getPerplexityInsights() {
                await detailViewAIWorkflows.getPerplexityInsights(this);
            },
            getPerplexityRecencyFilter(feature) {
                return detailViewAIWorkflows.getPerplexityRecencyFilter(feature);
            },
            getPerplexityDomainFilter(feature) {
                return detailViewAIWorkflows.getPerplexityDomainFilter(feature);
            },
            formatPerplexityCitations(citations) {
                return detailViewAIWorkflows.formatPerplexityCitations(citations);
            },

            // ==================== Smart Search Routing ====================

            async routeSearchQuery(feature, userIntent = 'auto') {
                return await detailViewAIWorkflows.routeSearchQuery(this, feature, userIntent);
            },

            analyzeSearchIntent(feature) {
                return detailViewAIWorkflows.analyzeSearchIntent(feature);
            },

            explainIntent(intent, feature) {
                return detailViewAIWorkflows.explainIntent(intent, feature);
            },

            async smartSearch() {
                await detailViewAIWorkflows.smartSearch(this);
            },

            // ==================== AI-Assisted Feature Creation Workflow ====================

            showAIAssistedFeatureCreation() {
                // Open chat panel if not open
                const chatPanel = document.getElementById('chatPanel');
                if (!chatPanel.classList.contains('active')) {
                    this.toggleChat();
                }

                // Set flag for AI to know we're in feature creation mode
                this.aiFeatureCreationMode = true;

                // Start AI conversation
                const initialPrompt = `I want to create a new feature for my platform roadmap. Please help me by:

1. Asking me clarifying questions to understand what I want to build
2. After gathering the requirements, automatically research and generate:
   - Execution steps with time estimates
   - Required resources (team, technologies, budget)
   - Planning milestones and risk assessment
   - Inspiration sources and reference links

Let's start! Ask me questions about the feature I want to add.`;

                // Add user message to chat
                this.addMessageToChat('user', initialPrompt);

                // Send to AI
                this.sendMessage();
            },

            // ==================== AI Feature Enhancement Workflow ====================

            showEnhancementPanel(featureId) {
                detailViewAIWorkflows.showEnhancementPanel(this, featureId);
            },

            async generateEnhancementQuestions(feature) {
                await detailViewAIWorkflows.generateEnhancementQuestions(this, feature);
            },

            checkEnhancementAnswers() {
                detailViewAIWorkflows.checkEnhancementAnswers(this);
            },

            closeEnhancementPanel() {
                detailViewAIWorkflows.closeEnhancementPanel(this);
            },

            async submitEnhancementAnswers() {
                await detailViewAIWorkflows.submitEnhancementAnswers(this);
            },

            updateEnhancementProgress(percent, message) {
                detailViewAIWorkflows.updateEnhancementProgress(percent, message);
            },

            startAIEnhancementWorkflow(featureId) {
                detailViewAIWorkflows.startAIEnhancementWorkflow(this, featureId);
            },

            // This will be called by AI when ready to enhance the feature
            async executeEnhanceFeatureWithResearch(actionData) {
                return await detailViewAIWorkflows.executeEnhanceFeatureWithResearch(this, actionData);
            },

            // This will be called by AI when ready to create the feature
            async executeCreateFeatureWithResearch(actionData) {
                return await detailViewAIWorkflows.executeCreateFeatureWithResearch(this, actionData);
            },

            async conductFeatureResearch(actionData) {
                return await detailViewAIWorkflows.conductFeatureResearch(this, actionData);
            },

            async generateExecutionStepsFromResearch(actionData, researchResults) {
                return await detailViewAIWorkflows.generateExecutionStepsFromResearch(this, actionData, researchResults);
            },

            async suggestResourcesFromResearch(actionData, researchResults) {
                return await detailViewAIWorkflows.suggestResourcesFromResearch(this, actionData, researchResults);
            },

            async generatePlanningFromResearch(actionData, researchResults) {
                return await detailViewAIWorkflows.generatePlanningFromResearch(this, actionData, researchResults);
            },

            selectBestInspirationSources(researchResults) {
                return detailViewAIWorkflows.selectBestInspirationSources(researchResults);
            },

            // Inline edit handlers
            startInlineEdit(id, field, current) {
                if (field !== 'name') return;
                const rows = document.getElementById('tableBody').querySelectorAll('tr');
                rows.forEach((tr) => {
                    const cb = tr.querySelector('input[type="checkbox"]');
                    if (!cb) return;
                    const fidMatch = cb.getAttribute('onchange')?.match(/'([^']+)'/);
                    const fid = fidMatch ? fidMatch[1] : null;
                    if (fid === id) {
                        const nameCell = tr.children[1];
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = current;
                        input.className = 'focus-ring';
                        input.style.width = '100%';
                        input.onkeydown = (e) => {
                            if (e.key === 'Enter') { this.inlineSaveName(id, input.value.trim()); }
                            if (e.key === 'Escape') { this.renderTable(); }
                        };
                        input.onblur = () => { this.inlineSaveName(id, input.value.trim()); };
                        nameCell.innerHTML = '';
                        nameCell.appendChild(input);
                        input.focus();
                    }
                });
            },
            inlineSaveName(id, value) {
                if (!value) { this.renderTable(); return; }
                const f = this.features.find(x => x.id === id);
                if (f) {
                    f.name = value;
                    f.updatedAt = new Date().toISOString();
                    this.saveData();
                }
                this.renderTable();
            },
            inlineUpdateType(id, value) {
                featureTable.inlineUpdateType(this, id, value);
            },

            // Bulk selection & actions
            toggleSelectAll(checked) {
                featureTable.toggleSelectAll(this, checked);
            },
            toggleSelectOne(id, checked) {
                featureTable.toggleSelectOne(this, id, checked);
            },
            updateBulkActionsBar() {
                featureTable.updateBulkActionsBar(this);
            },
            async bulkDeleteSelected() {
                await featureTable.bulkDeleteSelected(this);
            },
            exportSelectedToCSV() {
                featureTable.exportSelectedToCSV(this);
            },

            // Confirm modal
            showConfirm({ title = 'Are you sure?', message = '', confirmText = 'OK', cancelText = 'Cancel', variant = 'info', dontAskAgainKey = null } = {}) {
                return new Promise((resolve) => {
                    // Check if user has previously selected "don't ask again"
                    if (dontAskAgainKey) {
                        const dontAskAgain = localStorage.getItem(dontAskAgainKey);
                        if (dontAskAgain === 'true') {
                            resolve(true);
                            return;
                        }
                    }

                    const overlay = document.createElement('div');
                    overlay.className = 'link-picker-overlay';
                    const modal = document.createElement('div');
                    modal.className = 'link-picker-modal';
                    modal.setAttribute('role', 'dialog');
                    modal.setAttribute('aria-modal', 'true');

                    const dontAskAgainCheckbox = dontAskAgainKey ? `
                        <div style="margin-bottom:12px; padding:8px; background:rgba(0,0,0,0.05); border-radius:4px;">
                            <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:12px; color:var(--text-secondary);">
                                <input type="checkbox" id="dontAskAgainCheckbox" style="cursor:pointer;">
                                <span>Don't ask me again</span>
                            </label>
                        </div>
                    ` : '';

                    modal.innerHTML = `
                        <h3>${title}</h3>
                        <div style="color:var(--text-primary); font-size:13px; line-height:1.5; margin-bottom:10px;">${message}</div>
                        ${dontAskAgainCheckbox}
                        <div class="link-picker-actions">
                            <button id="confirm-cancel" style="background:var(--neutral-medium); color:var(--text-inverse);">${cancelText}</button>
                            <button id="confirm-ok" style="background:${variant==='danger' ? 'var(--danger)' : 'var(--success)'}; color:var(--text-inverse);">${confirmText}</button>
                        </div>
                    `;
                    const release = this.trapFocus(modal);
                    const closeAll = (val) => {
                        // Save "don't ask again" preference if checkbox exists and is checked
                        if (dontAskAgainKey && val) {
                            const checkbox = modal.querySelector('#dontAskAgainCheckbox');
                            if (checkbox && checkbox.checked) {
                                localStorage.setItem(dontAskAgainKey, 'true');
                            }
                        }

                        release && release();
                        document.body.removeChild(overlay);
                        document.body.removeChild(modal);
                        resolve(val);
                    };
                    overlay.addEventListener('click', () => closeAll(false));
                    modal.querySelector('#confirm-cancel').addEventListener('click', () => closeAll(false));
                    modal.querySelector('#confirm-ok').addEventListener('click', () => closeAll(true));
                    document.body.appendChild(overlay);
                    document.body.appendChild(modal);
                    setTimeout(() => modal.querySelector('#confirm-ok').focus(), 0);
                    const escHandler = (e) => { if (e.key === 'Escape') { closeAll(false); document.removeEventListener('keydown', escHandler); } };
                    document.addEventListener('keydown', escHandler);
                });
            },

            showAlert({ title = 'Notice', message = '', buttonText = 'OK', variant = 'info' } = {}) {
                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.className = 'link-picker-overlay';
                    const modal = document.createElement('div');
                    modal.className = 'link-picker-modal';
                    modal.setAttribute('role', 'dialog');
                    modal.setAttribute('aria-modal', 'true');
                    modal.innerHTML = `
                        <h3>${title}</h3>
                        <div style="color:var(--text-primary); font-size:13px; line-height:1.5; margin-bottom:10px;">${message}</div>
                        <div class="link-picker-actions">
                            <button id="alert-ok" style="background:${variant==='danger' ? 'var(--danger)' : (variant==='warning' ? 'var(--warning)' : 'var(--info)')}; color:var(--text-inverse); width:100%">${buttonText}</button>
                        </div>
                    `;
                    const release = this.trapFocus(modal);
                    const closeAll = () => { release && release(); document.body.removeChild(overlay); document.body.removeChild(modal); resolve(true); };
                    overlay.addEventListener('click', closeAll);
                    modal.querySelector('#alert-ok').addEventListener('click', closeAll);
                    document.body.appendChild(overlay);
                    document.body.appendChild(modal);
                    setTimeout(() => modal.querySelector('#alert-ok').focus(), 0);
                    const escHandler = (e) => { if (e.key === 'Escape') { closeAll(); document.removeEventListener('keydown', escHandler); } };
                    document.addEventListener('keydown', escHandler);
                });
            },

            // Focus trap utility
            trapFocus(container) {
                const focusableSelector = 'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';
                const focusables = Array.from(container.querySelectorAll(focusableSelector)).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));
                const first = focusables[0];
                const last = focusables[focusables.length - 1];
                const prev = document.activeElement;
                const handler = (e) => {
                    if (e.key !== 'Tab') return;
                    if (e.shiftKey) {
                        if (document.activeElement === first) { e.preventDefault(); last.focus(); }
                    } else {
                        if (document.activeElement === last) { e.preventDefault(); first.focus(); }
                    }
                };
                document.addEventListener('keydown', handler);
                if (first) first.focus();
                return () => {
                    document.removeEventListener('keydown', handler);
                    if (prev && typeof prev.focus === 'function') { try { prev.focus(); } catch {} }
                };
            },

            sortTable(evt, column) {
                featureTable.sortTable(this, evt, column);
            },

            getFilteredFeatures() {
                return featureTable.getFilteredFeatures(this);
            },

            applyFilters() {
                featureTable.applyFilters(this);
            },

            clearFilters() {
                featureTable.clearFilters(this);
            },

            populateCategoryFilter() {
                featureTable.populateCategoryFilter(this);
            },

            async exportToCSV() {
                await featureTable.exportToCSV(this);
            },

            exportAllData() {
                // Use the new exportData function which handles localStorage data
                this.exportData();
            },

            importAllData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const success = await this.importData(file);
                        if (success) {
                            // Refresh the page to load the imported data
                            setTimeout(() => window.location.reload(), 1000);
                        }
                    } catch (error) {
                        console.error('Import failed:', error);
                        this.showAlert({
                            title: 'Import failed',
                            message: 'Failed to import data. Please check the console for details.',
                            variant: 'danger'
                        });
                    }
                };

                input.click();
            },

            toggleChat() {
                chatPanel.toggleChat();
            },

            async sendMessage() {
                await chatPanel.sendMessage(this);
            },

            // [Extracted method - now delegating to chatPanel]
            // The original 400+ line implementation is preserved as _oldSendMessage for reference
            async _oldSendMessage() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();

                if (!message) return;

                if (!this.apiKey) {
                    await this.showAlert({ title:'API key required', message:'Please enter your OpenRouter API key first!' });
                    return;
                }

                // Add user message
                this.addChatMessage(message, 'user');
                this.conversationHistory.push({ role: 'user', content: message });
                this.messageCount++;
                this.updateCounters();

                input.value = '';
                input.style.height = 'auto'; // Reset textarea height

                // Check context length warning
                if (this.messageCount >= 20) {
                    document.getElementById('contextWarning')?.classList.remove('hidden');
                }

                // Show loading state
                const inputWrapper = document.querySelector('.chat-input-wrapper');
                const sendButton = inputWrapper?.querySelector('button');
                if (inputWrapper) inputWrapper.classList.add('loading');
                if (sendButton) sendButton.disabled = true;
                
                const loadingId = 'loading-' + Date.now();
                this.addChatMessage('<span class="loading"></span> <span id="loading-text">Composing response...</span>', 'ai', loadingId);
                
                // Update loading text periodically
                const loadingTexts = ['Composing response...', 'Thinking...', 'Processing...'];
                let loadingTextIndex = 0;
                const loadingTextInterval = setInterval(() => {
                    const loadingTextEl = document.getElementById('loading-text');
                    if (loadingTextEl) {
                        loadingTextIndex = (loadingTextIndex + 1) % loadingTexts.length;
                        loadingTextEl.textContent = loadingTexts[loadingTextIndex];
                    }
                }, 2000);

                try {
                    // Build system prompt with custom instructions and memory
                    let systemPrompt = '';

                    // CRITICAL: Platform Vision Context
                    systemPrompt += `üéØ PLATFORM VISION:\n`;
                    systemPrompt += `You are helping build a comprehensive trade platform that integrates sourcing, payments, research, customs, chat, logistics, and last mile delivery into a single unified platform.\n`;
                    systemPrompt += `This is a complete end-to-end solution for international trade management.\n\n`;

                    if (this.customInstructions) {
                        systemPrompt += this.customInstructions + '\n\n';
                    } else {
                        systemPrompt += `You are a Product Development Assistant for this trade platform roadmap manager.\n\n`;
                    }

                    systemPrompt += `üìã CURRENT ROADMAP CONTEXT:\n`;
                    systemPrompt += this.formatFeaturesForContext();
                    systemPrompt += `\n`;

                    if (this.memory.length > 0) {
                        systemPrompt += `üß† MEMORY (Important information from previous conversations):\n`;
                        this.memory.forEach((item, index) => {
                            systemPrompt += `${index + 1}. ${item.content}\n`;
                        });
                        systemPrompt += `\n`;
                    }

                    systemPrompt += `üìù INSTRUCTIONS:\n`;
                    systemPrompt += `1. **ALWAYS** understand the platform context: You are helping build a unified trade platform with sourcing, payments, research, customs, chat, logistics, and last mile delivery\n`;
                    systemPrompt += `2. **ALWAYS** reference the roadmap features when answering questions - know what features are being developed\n`;
                    systemPrompt += `3. When user asks about competitors or similar platforms, understand they're building a COMPREHENSIVE TRADE PLATFORM and compare accordingly\n`;
                    systemPrompt += `4. Analyze features, suggest improvements, answer questions about the roadmap\n`;
                    systemPrompt += `5. Be concise and actionable\n`;
                    systemPrompt += `6. Learn from every conversation - identify important information that should be remembered\n`;
                    systemPrompt += `7. Important information includes: user preferences, project-specific details, integration decisions, architectural choices, platform vision details, competitive insights, etc.\n`;
                    
                    // Add search capability info
                    if (this.tavilyApiKey) {
                        systemPrompt += `\nüîç INTERNET SEARCH:\n`;
                        systemPrompt += `You have access to internet search via the search_internet tool. Use it when you need:\n`;
                        systemPrompt += `- Current information or recent news\n`;
                        systemPrompt += `- Up-to-date documentation or technical details\n`;
                        systemPrompt += `- Real-time data or facts not in your training data\n`;
                        systemPrompt += `- Verification of current information\n`;
                        systemPrompt += `- Finding competitors or similar platforms (especially trade platforms)\n\n`;
                        systemPrompt += `**IMPORTANT SEARCH BEST PRACTICES:**\n`;
                        systemPrompt += `- Make ONE comprehensive search query instead of multiple separate searches\n`;
                        systemPrompt += `- Combine related topics into a single well-crafted query\n`;
                        systemPrompt += `- Example: Instead of 3 searches ("trade platforms", "B2B software", "import/export tools"), use ONE: "B2B trade platforms import export software comparison"\n`;
                        systemPrompt += `- Only make multiple searches if topics are genuinely unrelated\n`;
                        systemPrompt += `- Results will be more comprehensive and contextual with fewer, better queries\n`;
                    }
                    
                    if (this.aiEditingEnabled) {
                        systemPrompt += `\n‚ú® EDITING CAPABILITIES:\n`;
                        systemPrompt += `You have the ability to directly modify the roadmap using these tools:\n`;
                        systemPrompt += `- update_feature: Modify feature name, type, or purpose\n`;
                        systemPrompt += `- update_timeline_item: Change timeline item details (difficulty, categories, USP, integration)\n`;
                        systemPrompt += `- create_feature: Add a completely new feature with timeline items\n`;
                        systemPrompt += `- create_feature_with_research: Create comprehensive feature with AI research (see below)\n`;
                        systemPrompt += `- create_link_suggestion: Create cross-feature dependencies or complementary relationships\n`;
                        systemPrompt += `- add_timeline_item: Add new timeline phases to existing features\n`;
                        systemPrompt += `- delete_timeline_item: Remove timeline items (use cautiously)\n\n`;
                        systemPrompt += `‚ö†Ô∏è IMPORTANT - enhance_feature_with_research:\n`;
                        systemPrompt += `- This tool is ONLY available through the Enhancement Panel\n`;
                        systemPrompt += `- You CANNOT call it directly from chat\n`;
                        systemPrompt += `- User must click "AI Enhance" button to start the guided process\n`;
                        systemPrompt += `- If user asks to enhance a feature, direct them to use the button\n\n`;
                        systemPrompt += `TOOL USAGE GUIDELINES:\n`;
                        systemPrompt += `- Always confirm user intent before proposing changes\n`;
                        systemPrompt += `- Provide clear reasons for each proposed change\n`;
                        systemPrompt += `- Be specific and actionable in your suggestions\n`;
                        systemPrompt += `- For ambiguous requests, ask clarifying questions first\n`;
                        systemPrompt += `- Use tools when the user explicitly requests changes or improvements\n`;
                    }

                    // Add AI-Assisted Feature Creation instructions
                    if (this.aiFeatureCreationMode) {
                        systemPrompt += `\nüé® AI-ASSISTED FEATURE CREATION MODE:\n`;
                        systemPrompt += `You are helping the user create a comprehensive feature with automated research.\n\n`;
                        systemPrompt += `WORKFLOW:\n`;
                        systemPrompt += `1. Ask 5-7 clarifying questions to understand the feature:\n`;
                        systemPrompt += `   - What is the feature name and main purpose?\n`;
                        systemPrompt += `   - Who are the target users and what problem does it solve?\n`;
                        systemPrompt += `   - What's the expected timeline (MVP/SHORT/LONG)?\n`;
                        systemPrompt += `   - Any specific integration requirements or dependencies?\n`;
                        systemPrompt += `   - Any budget or resource constraints?\n`;
                        systemPrompt += `   - Any similar platforms or features they like?\n`;
                        systemPrompt += `   - Any specific technologies they want to use?\n\n`;
                        systemPrompt += `2. After gathering answers, use create_feature_with_research tool:\n`;
                        systemPrompt += `   - This tool will automatically:\n`;
                        systemPrompt += `     * Research competitors and similar implementations\n`;
                        systemPrompt += `     * Find relevant technologies and tools\n`;
                        systemPrompt += `     * Generate 5-8 execution steps with time estimates\n`;
                        systemPrompt += `     * Suggest required resources (team, tech, budget)\n`;
                        systemPrompt += `     * Create planning milestones and identify risks\n`;
                        systemPrompt += `     * Find inspiration sources and references\n`;
                        systemPrompt += `   - The user can then review and edit everything in the detail view\n\n`;
                        systemPrompt += `3. Be conversational and helpful:\n`;
                        systemPrompt += `   - Ask questions one at a time or in small groups\n`;
                        systemPrompt += `   - Clarify ambiguous answers\n`;
                        systemPrompt += `   - Provide examples to help user think through requirements\n`;
                        systemPrompt += `   - Once you have enough information, call the tool immediately\n\n`;
                        systemPrompt += `SEARCH BEST PRACTICES (for research):\n`;
                        systemPrompt += `- For trading/finance features: "stock market data API", "trading platform", "financial data providers"\n`;
                        systemPrompt += `- For social features: "real-time messaging", "WebSocket chat", "notification systems"\n`;
                        systemPrompt += `- For analytics: "data visualization", "dashboard libraries", "analytics platforms"\n`;
                        systemPrompt += `- For e-commerce: "payment gateway", "checkout flow", "inventory management"\n`;
                        systemPrompt += `- Always use specific technical terms, not generic phrases\n`;
                        systemPrompt += `- Search for actual competitor platforms, not just implementation guides\n\n`;
                    }

                    if (this.aiFeatureEnhancementMode) {
                        const feature = this.features.find(f => f.id === this.currentFeatureId);
                        const featureContext = feature ? `
Current Feature Being Enhanced:
- Name: ${feature.name}
- Type: ${feature.type}
- Purpose: ${feature.purpose || 'Not specified'}
- Timeline Items: ${feature.timelineItems?.length || 0}
- Execution Steps: ${feature.executionSteps?.length || 0} (${feature.executionSteps?.length === 0 ? 'MISSING - needs generation' : 'exists'})
- Resources: ${feature.resources ? 'Exists' : 'MISSING - needs generation'}
- Planning: ${feature.planning ? 'Exists' : 'MISSING - needs generation'}
- Inspiration: ${feature.inspiration?.length || 0} sources (${feature.inspiration?.length === 0 ? 'MISSING - needs generation' : 'exists'})
` : '';

                        systemPrompt += `\nüîß AI FEATURE ENHANCEMENT MODE:\n`;
                        systemPrompt += `‚ö†Ô∏è CRITICAL: Feature enhancement is DISABLED in chat mode.\n\n`;
                        systemPrompt += `${featureContext}\n`;
                        systemPrompt += `IMPORTANT RULES:\n`;
                        systemPrompt += `- You CANNOT enhance features through chat conversation\n`;
                        systemPrompt += `- You CANNOT call enhance_feature_with_research directly\n`;
                        systemPrompt += `- Enhancement REQUIRES the user to use the "AI Enhance" button on the feature\n`;
                        systemPrompt += `- This ensures proper context gathering through targeted questions\n\n`;
                        systemPrompt += `WHAT YOU CAN DO:\n`;
                        systemPrompt += `- Answer questions about the feature\n`;
                        systemPrompt += `- Suggest improvements or ideas\n`;
                        systemPrompt += `- Provide analysis and recommendations\n`;
                        systemPrompt += `- Help user understand what's missing\n\n`;
                        systemPrompt += `WHAT YOU SHOULD SAY:\n`;
                        systemPrompt += `If user asks you to enhance or improve a feature, respond:\n`;
                        systemPrompt += `"To properly enhance this feature, please click the 'AI Enhance' button on the feature card. This will start a guided process where I'll ask you targeted questions to gather all necessary context before making comprehensive improvements."\n\n`;
                        systemPrompt += `WHY THIS MATTERS:\n`;
                        systemPrompt += `- Ensures I ask relevant questions specific to the feature's gaps\n`;
                        systemPrompt += `- Prevents making changes without sufficient context\n`;
                        systemPrompt += `- Allows user to review all questions before research begins\n`;
                        systemPrompt += `- Creates better quality enhancements with proper information\n\n`;
                    }

                    const messages = [
                        { role: 'system', content: systemPrompt },
                        ...this.conversationHistory
                    ];

                    const requestBody = {
                        model: this.selectedModel,
                        messages: messages,
                        stream: true  // Enable streaming
                    };
                    
                    // Add tools - always include search if API key is available, and editing tools if enabled
                    const tools = this.getAITools();
                    // Filter tools based on availability
                    const availableTools = tools.filter(tool => {
                        if (tool.function.name === 'search_internet') {
                            return !!this.tavilyApiKey; // Only include search if API key is available
                        }
                        return this.aiEditingEnabled; // Only include editing tools if editing is enabled
                    });
                    
                    if (availableTools.length > 0) {
                        requestBody.tools = availableTools;
                        requestBody.tool_choice = 'auto';
                    }

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Platform Roadmap Manager'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    // Clear loading interval
                    clearInterval(loadingTextInterval);
                    
                    // Remove loading message and restore input state
                    const loadingEl = document.getElementById(loadingId);
                    if (loadingEl) loadingEl.remove();
                    if (inputWrapper) inputWrapper.classList.remove('loading');
                    if (sendButton) sendButton.disabled = false;

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.statusText}`);
                    }

                    // Process streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let fullContent = '';
                    let toolCalls = [];
                    let toolCallBuffer = {};
                    
                    // Create streaming message element
                    const streamMessageId = 'stream-' + Date.now();
                    this.addChatMessage('', 'ai', streamMessageId);
                    const streamMessageEl = document.getElementById(streamMessageId);
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep incomplete line in buffer
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') continue;
                                    
                                    try {
                                        const json = JSON.parse(data);
                                        const delta = json.choices?.[0]?.delta;
                                        
                                        if (delta) {
                                            // Handle content delta
                                            if (delta.content) {
                                                fullContent += delta.content;
                                                if (streamMessageEl) {
                                                    const formatted = this.formatMessage(fullContent);
                                                    streamMessageEl.innerHTML = this.sanitizeHtml(formatted) || fullContent;
                                                    // Auto-scroll
                                                    const messagesContainer = document.getElementById('chatMessages');
                                                    if (messagesContainer) {
                                                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                                    }
                                                }
                                            }
                                            
                                            // Handle tool calls
                                            if (delta.tool_calls) {
                                                for (const toolCallDelta of delta.tool_calls) {
                                                    const index = toolCallDelta.index;
                                                    if (!toolCallBuffer[index]) {
                                                        toolCallBuffer[index] = { id: '', function: { name: '', arguments: '' } };
                                                    }
                                                    
                                                    if (toolCallDelta.id) {
                                                        toolCallBuffer[index].id = toolCallDelta.id;
                                                    }
                                                    
                                                    if (toolCallDelta.function) {
                                                        if (toolCallDelta.function.name) {
                                                            toolCallBuffer[index].function.name = toolCallDelta.function.name;
                                                        }
                                                        if (toolCallDelta.function.arguments) {
                                                            toolCallBuffer[index].function.arguments += toolCallDelta.function.arguments;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        // Skip malformed JSON
                                        console.warn('Failed to parse stream data:', e);
                                    }
                                }
                            }
                        }
                    } finally {
                        reader.releaseLock();
                    }
                    
                    // Process completed tool calls
                    toolCalls = Object.values(toolCallBuffer).filter(tc => tc.id && tc.function.name);
                    
                    if (toolCalls.length > 0) {
                        // AI wants to use tools - separate read-only tools from editing tools
                        console.log(`AI wants to make ${toolCalls.length} tool call(s)`);
                        
                        const editingTools = [];
                        const readOnlyTools = [];
                        
                        // Process all tool calls
                        for (const toolCall of toolCalls) {
                            const functionName = toolCall.function.name;
                            let functionArgs;
                            try {
                                functionArgs = JSON.parse(toolCall.function.arguments);
                            } catch (e) {
                                console.error('Failed to parse tool arguments:', e);
                                continue;
                            }
                            
                            console.log('AI tool call:', functionName, functionArgs);
                            
                            // Search is read-only, execute immediately
                            if (functionName === 'search_internet') {
                                readOnlyTools.push({ toolCall, functionName, functionArgs });
                            } else {
                                // Editing tools need approval
                                editingTools.push({ toolCall, functionName, functionArgs });
                            }
                        }
                        
                        // Execute read-only tools - batch searches if multiple
                        if (readOnlyTools.length > 0) {
                            try {
                                if (readOnlyTools.length === 1) {
                                    // Single search - use regular execution
                                    await this.executeSearchInternet(readOnlyTools[0].functionArgs);
                                } else {
                                    // Multiple searches - batch them
                                    const searchPromises = readOnlyTools.map(tool =>
                                        this.executeSearchInternetSilent(tool.functionArgs)
                                    );
                                    const searchResults = await Promise.all(searchPromises);
                                    this.displayBatchedSearchResults(searchResults);
                                }
                            } catch (error) {
                                console.error('Search execution error:', error);
                                this.addChatMessage(`‚ùå Search error: ${error.message}`, 'ai');
                            }
                        }
                        
                        // Queue editing tools for approval
                        for (const tool of editingTools) {
                            this.pendingAIActions.push({ 
                                actionType: tool.functionName, 
                                actionData: tool.functionArgs, 
                                reason: tool.functionArgs.reason || 'No reason provided',
                                timestamp: new Date().toISOString() 
                            });
                        }
                        
                        // Show first editing action approval dialog if any
                        if (this.pendingAIActions.length > 0) {
                            const firstAction = this.pendingAIActions[0];
                            this.showAIActionApproval(firstAction.actionType, firstAction.actionData, firstAction.reason);
                        }
                        
                        // Store the conversation with tool call for context
                        this.conversationHistory.push({
                            role: 'assistant',
                            content: fullContent || `I'd like to make ${editingTools.length} change(s).`,
                            tool_calls: toolCalls
                        });
                    } else {
                        // Normal text response
                        this.conversationHistory.push({ role: 'assistant', content: fullContent });
                        this.messageCount++;
                        this.updateCounters();
                    }

                    // Trigger memory analysis every 5 messages
                    if (this.messageCount - this.lastAnalysisCount >= 5) {
                        this.lastAnalysisCount = this.messageCount;
                        // Run analysis in background without blocking
                        setTimeout(() => this.analyzeConversationForMemory(), 1000);
                    }

                } catch (error) {
                    // Clear loading interval
                    clearInterval(loadingTextInterval);
                    
                    // Remove loading message and restore input state
                    const loadingEl = document.getElementById(loadingId);
                    if (loadingEl) loadingEl.remove();
                    if (inputWrapper) inputWrapper.classList.remove('loading');
                    if (sendButton) sendButton.disabled = false;
                    
                    this.addChatMessage(`‚ùå Error: ${error.message}. Please check your API key.`, 'ai');
                }
            },

            updateCounters() {
                chatPanel.updateCounters(this);
            },

            updateMemoryContextIndicator() {
                chatPanel.updateMemoryContextIndicator(this);
            },

            setupChatPanelResize() {
                chatPanel.setupChatPanelResize();
            },

            formatTables(text) {
                return chatPanel.formatTables(text);
            },

            formatMessage(text) {
                return chatPanel.formatMessage(text);
            },

            sanitizeHtml(html) {
                return chatPanel.sanitizeHtml(html);
            },

            // [DUPLICATE REMOVED - addChatMessage is now handled at line 4654]
            // This was a duplicate definition. The active version delegates to chatPanel.addChatMessage()

            // ==================== Phase 3: Advanced Project Management Features ====================

            // Blockers Management
            addBlocker() {
                detailViewCrud.addBlocker(this);
            },

            toggleBlockerStatus(blockerId) {
                detailViewCrud.toggleBlockerStatus(this, blockerId);
            },

            deleteBlocker(blockerId) {
                detailViewCrud.deleteBlocker(this, blockerId);
            },

            async identifyBlockers() {
                await detailViewAI.identifyBlockers(this);
            },

            // Success Metrics Management
            addSuccessMetric() {
                detailViewCrud.addSuccessMetric(this);
            },

            updateMetricActual(metricId) {
                detailViewCrud.updateMetricActual(this, metricId);
            },

            deleteSuccessMetric(metricId) {
                detailViewCrud.deleteSuccessMetric(this, metricId);
            },

            calculateMetricProgress(metric) {
                return detailViewCrud.calculateMetricProgress(metric);
            },

            // Acceptance Criteria Management
            addAcceptanceCriteria() {
                detailViewCrud.addAcceptanceCriteria(this);
            },

            toggleAcceptanceCriteria(criteriaId) {
                detailViewCrud.toggleAcceptanceCriteria(this, criteriaId);
            },

            removeAcceptanceCriteria(criteriaId) {
                detailViewCrud.removeAcceptanceCriteria(this, criteriaId);
            },

            // Definition of Done Management
            addDefinitionOfDone() {
                detailViewCrud.addDefinitionOfDone(this);
            },

            toggleDefinitionOfDone(dodId) {
                detailViewCrud.toggleDefinitionOfDone(this, dodId);
            },

            removeDefinitionOfDone(dodId) {
                detailViewCrud.removeDefinitionOfDone(this, dodId);
            },

            // Tags Management
            addTag() {
                detailViewCrud.addTag(this);
            },

            removeTag(tag) {
                detailViewCrud.removeTag(this, tag);
            },

            renderTags(tags) {
                detailViewCrud.renderTags(this, tags);
            }
        };

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize core application
            app.init();

            // Initialize Enhanced Interface Systems
            try {
                console.log('üöÄ Initializing Enhanced Interface Systems...');

                // Initialize State Management (Foundation)
                if (typeof StateManagementIntegration !== 'undefined') {
                    const stateIntegration = new StateManagementIntegration();
                    await stateIntegration.initialize();
                    console.log('‚úÖ State Management initialized');
                    window.stateIntegration = stateIntegration; // Make available globally
                }

                // Initialize Navigation System
                if (typeof NavigationIntegration !== 'undefined') {
                    const navigationIntegration = new NavigationIntegration();
                    await navigationIntegration.initialize();
                    console.log('‚úÖ Navigation System initialized');
                    window.navigationIntegration = navigationIntegration; // Make available globally
                }

                // Initialize Interaction Integration (Master)
                if (typeof InteractionIntegration !== 'undefined') {
                    const interactionIntegration = new InteractionIntegration();
                    await interactionIntegration.initialize();
                    console.log('‚úÖ Interaction Integration initialized');
                    window.interactionIntegration = interactionIntegration; // Make available globally
                }

                console.log('üéâ Enhanced Interface Systems successfully initialized!');
            } catch (error) {
                console.error('‚ùå Error initializing Enhanced Interface Systems:', error);
                console.log('üìã Application will continue with basic functionality');
            }
        });
    </script>
</body>
</html>
